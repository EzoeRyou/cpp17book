<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2017-02-28" />
  <title>江添亮の詳説C++17</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">江添亮の詳説C++17</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2017-02-28</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#はじめに">はじめに</a></li>
<li><a href="#序">序</a><ul>
<li><a href="#cの規格">C++の規格</a><ul>
<li><a href="#c98">C++98</a></li>
<li><a href="#c03">C++03</a></li>
<li><a href="#c11">C++11</a></li>
<li><a href="#c14">C++14</a></li>
<li><a href="#c17">C++17</a></li>
</ul></li>
<li><a href="#cの将来の規格">C++の将来の規格</a><ul>
<li><a href="#c20">C++20</a></li>
</ul></li>
<li><a href="#コア言語とライブラリ">コア言語とライブラリ</a></li>
</ul></li>
<li><a href="#sd-6-cのための機能テスト推奨">SD-6 C++のための機能テスト推奨</a><ul>
<li><a href="#機能テストマクロ">機能テストマクロ</a></li>
<li><a href="#has_include式-ヘッダーファイルの存在を判定する">__has_include式 : ヘッダーファイルの存在を判定する</a></li>
<li><a href="#has_cpp_attribute式">__has_cpp_attribute式</a></li>
</ul></li>
<li><a href="#c14のコア言語の新機能">C++14のコア言語の新機能</a><ul>
<li><a href="#二進数リテラル">二進数リテラル</a></li>
<li><a href="#数値区切り文字">数値区切り文字</a></li>
<li><a href="#deprecated属性">[[deprecated]]属性</a></li>
<li><a href="#通常の関数の戻り値の型推定">通常の関数の戻り値の型推定</a></li>
<li><a href="#decltypeauto-厳格なauto">decltype(auto) : 厳格なauto</a></li>
<li><a href="#ジェネリックラムダ">ジェネリックラムダ</a></li>
<li><a href="#初期化ラムダキャプチャー">初期化ラムダキャプチャー</a></li>
<li><a href="#変数テンプレート">変数テンプレート</a><ul>
<li><a href="#意味は同じだが型が違う定数">意味は同じだが型が違う定数</a></li>
<li><a href="#traitsのラッパー">traitsのラッパー</a></li>
</ul></li>
<li><a href="#constexpr関数の制限緩和">constexpr関数の制限緩和</a></li>
<li><a href="#メンバー初期化子とアグリゲート初期化の組み合わせ">メンバー初期化子とアグリゲート初期化の組み合わせ</a></li>
<li><a href="#サイズ付き解放関数">サイズ付き解放関数</a></li>
</ul></li>
<li><a href="#c17のコア言語の新機能">C++17のコア言語の新機能</a><ul>
<li><a href="#トライグラフの廃止">トライグラフの廃止</a></li>
<li><a href="#進数浮動小数点数リテラル">16進数浮動小数点数リテラル</a></li>
<li><a href="#utf-8文字リテラル">UTF-8文字リテラル</a></li>
<li><a href="#関数型としての例外指定">関数型としての例外指定</a></li>
<li><a href="#fold式">fold式</a></li>
<li><a href="#ラムダ式でthisのコピーキャプチャー">ラムダ式で*thisのコピーキャプチャー</a></li>
<li><a href="#constexprラムダ式">constexprラムダ式</a></li>
<li><a href="#文字列なしstatic_assert">文字列なしstatic_assert</a></li>
<li><a href="#ネストされた名前空間定義">ネストされた名前空間定義</a></li>
<li><a href="#fallthrough属性">[[fallthrough]]属性</a></li>
<li><a href="#nodiscard属性">[[nodiscard]]属性</a></li>
<li><a href="#maybe_unused属性">[[maybe_unused]]属性</a></li>
<li><a href="#演算子のオペランドの評価順序の固定">演算子のオペランドの評価順序の固定</a></li>
<li><a href="#constexpr-if文-コンパイル時条件分岐">constexpr if文 : コンパイル時条件分岐</a><ul>
<li><a href="#実行時の条件分岐">実行時の条件分岐</a></li>
<li><a href="#プリプロセス時の条件分岐">プリプロセス時の条件分岐</a></li>
<li><a href="#コンパイル時の条件分岐">コンパイル時の条件分岐</a></li>
<li><a href="#超上級者向け解説">超上級者向け解説</a></li>
<li><a href="#constexpr-ifでは解決できない問題">constexpr ifでは解決できない問題</a></li>
<li><a href="#constexpr-ifで解決できる問題">constexpr ifで解決できる問題</a></li>
</ul></li>
<li><a href="#初期化文付き条件文">初期化文付き条件文</a></li>
<li><a href="#クラステンプレートのコンストラクターからの実引数推定">クラステンプレートのコンストラクターからの実引数推定</a><ul>
<li><a href="#推定ガイド">推定ガイド</a></li>
</ul></li>
<li><a href="#autoによる非型テンプレートパラメーターの宣言">autoによる非型テンプレートパラメーターの宣言</a></li>
<li><a href="#using属性名前空間">using属性名前空間</a></li>
<li><a href="#非標準属性の無視">非標準属性の無視</a></li>
<li><a href="#構造化束縛">構造化束縛</a><ul>
<li><a href="#超上級者向け解説-1">超上級者向け解説</a></li>
<li><a href="#構造化束縛宣言の仕様">構造化束縛宣言の仕様</a></li>
<li><a href="#初期化子の型が配列の場合">初期化子の型が配列の場合</a></li>
<li><a href="#初期化子の型が配列ではなくstdtuple_sizeeが完全形の名前である場合">初期化子の型が配列ではなく、std::tuple_size&lt;E&gt;が完全形の名前である場合</a></li>
<li><a href="#上記以外の場合">上記以外の場合</a></li>
</ul></li>
<li><a href="#inline変数">inline変数</a><ul>
<li><a href="#inlineの歴史的な意味">inlineの歴史的な意味</a></li>
<li><a href="#現代のinlineの意味">現代のinlineの意味</a></li>
<li><a href="#inline変数の意味">inline変数の意味</a></li>
</ul></li>
<li><a href="#可変長using宣言">可変長using宣言</a></li>
<li><a href="#std.byte">std::byte : バイトを表現する型</a></li>
</ul></li>
<li><a href="#c17の型安全な値を格納するライブラリ">C++17の型安全な値を格納するライブラリ</a><ul>
<li><a href="#variant-型安全なunion">variant : 型安全なunion</a><ul>
<li><a href="#使い方">使い方</a></li>
<li><a href="#型非安全な古典的union">型非安全な古典的union</a></li>
<li><a href="#variantの宣言">variantの宣言</a></li>
<li><a href="#variantの初期化">variantの初期化</a><ul>
<li><a href="#デフォルト初期化">デフォルト初期化</a></li>
<li><a href="#コピー初期化">コピー初期化</a></li>
<li><a href="#variantのコンストラクターに値を渡した場合">variantのコンストラクターに値を渡した場合</a></li>
<li><a href="#in_place_typeによるemplace構築">in_place_typeによるemplace構築</a></li>
</ul></li>
<li><a href="#variantの破棄">variantの破棄</a></li>
<li><a href="#variantの代入">variantの代入</a></li>
<li><a href="#variantのemplace">variantのemplace</a></li>
<li><a href="#variantに値が入っているかどうかの確認">variantに値が入っているかどうかの確認</a><ul>
<li><a href="#valueless_by_exceptionメンバー関数">valueless_by_exceptionメンバー関数</a></li>
<li><a href="#indexメンバー関数">indexメンバー関数</a></li>
</ul></li>
<li><a href="#swap">swap</a></li>
<li><a href="#variant_sizet-variantが保持できる型の数を取得">variant_size&lt;T&gt; : variantが保持できる型の数を取得</a></li>
<li><a href="#variant_alternativei-t-インデックスから型を返す">variant_alternative&lt;I, T&gt; : インデックスから型を返す</a></li>
<li><a href="#holds_alternative-variantが指定した型の値を保持しているかどうかの確認">holds_alternative : variantが指定した型の値を保持しているかどうかの確認</a></li>
<li><a href="#getiv-インデックスから値の取得">get&lt;I&gt;(v) : インデックスから値の取得</a></li>
<li><a href="#gettv-型から値の取得">get&lt;T&gt;(v) : 型から値の取得</a></li>
<li><a href="#get_if-値を保持している場合に取得">get_if : 値を保持している場合に取得</a></li>
<li><a href="#variantの比較">variantの比較</a><ul>
<li><a href="#同一性の比較">同一性の比較</a></li>
<li><a href="#大小比較">大小比較</a></li>
</ul></li>
<li><a href="#visit-variantが保持している値を受け取る">visit : variantが保持している値を受け取る</a></li>
</ul></li>
<li><a href="#any-どんな型の値でも保持できるクラス">any : どんな型の値でも保持できるクラス</a><ul>
<li><a href="#使い方-1">使い方</a></li>
<li><a href="#anyの構築と破棄">anyの構築と破棄</a></li>
<li><a href="#in_place_typeコンストラクター">in_place_typeコンストラクター</a></li>
<li><a href="#anyへの代入">anyへの代入</a></li>
<li><a href="#anyのメンバー関数">anyのメンバー関数</a><ul>
<li><a href="#emplace">emplace</a></li>
<li><a href="#reset-値の破棄">reset : 値の破棄</a></li>
<li><a href="#swap-スワップ">swap : スワップ</a></li>
<li><a href="#has_value-値を保持しているかどうか調べる">has_value : 値を保持しているかどうか調べる</a></li>
<li><a href="#type-保持している型のtype_infoを得る">type : 保持している型のtype_infoを得る</a></li>
</ul></li>
<li><a href="#anyのフリー関数">anyのフリー関数</a><ul>
<li><a href="#make_anyt-t型のanyを作る">make_any&lt;T&gt; : T型のanyを作る</a></li>
<li><a href="#any_cast-保持している値の取り出し">any_cast : 保持している値の取り出し</a></li>
</ul></li>
</ul></li>
<li><a href="#optional-値を保有しているかしていないクラス">optional : 値を保有しているか、していないクラス</a><ul>
<li><a href="#使い方-2">使い方</a></li>
<li><a href="#optionalのテンプレート実引数">optionalのテンプレート実引数</a></li>
<li><a href="#optionalの構築">optionalの構築</a></li>
<li><a href="#optionalの代入">optionalの代入</a></li>
<li><a href="#optionalの破棄">optionalの破棄</a></li>
<li><a href="#swap-1">swap</a></li>
<li><a href="#has_value-値を保持しているかどうか確認する">has_value : 値を保持しているかどうか確認する</a></li>
<li><a href="#operator-bool-値を保持しているかどうか確認する">operator bool : 値を保持しているかどうか確認する</a></li>
<li><a href="#value-保持している値を取得">value : 保持している値を取得</a></li>
<li><a href="#value_or-値もしくはデフォルト値を返す">value_or : 値もしくはデフォルト値を返す</a></li>
<li><a href="#reset-保持している値を破棄する">reset : 保持している値を破棄する</a></li>
<li><a href="#optional同士の比較">optional同士の比較</a><ul>
<li><a href="#同一性の比較-1">同一性の比較</a></li>
<li><a href="#大小比較-1">大小比較</a></li>
</ul></li>
<li><a href="#optionalとstdnulloptとの比較">optionalとstd::nulloptとの比較</a></li>
<li><a href="#optionaltとtの比較">optional&lt;T&gt;とTの比較</a></li>
<li><a href="#make_optionalt-optionaltを返す">make_optional&lt;T&gt; : optional&lt;T&gt;を返す</a></li>
<li><a href="#make_optionalt-args-...-optionaltをin_place_type構築して返す">make_optional&lt;T, Args ... &gt; : optional&lt;T&gt;をin_place_type構築して返す</a></li>
</ul></li>
</ul></li>
<li><a href="#string_view-文字列ラッパー">string_view : 文字列ラッパー</a><ul>
<li><a href="#使い方-3">使い方</a></li>
<li><a href="#basic_string_view">basic_string_view</a></li>
<li><a href="#文字列の所有非所有">文字列の所有、非所有</a></li>
<li><a href="#string_viewの構築">string_viewの構築</a><ul>
<li><a href="#デフォルト構築">デフォルト構築</a></li>
<li><a href="#null終端された文字型の配列へのポインター">null終端された文字型の配列へのポインター</a></li>
<li><a href="#文字型へのポインターと文字数">文字型へのポインターと文字数</a></li>
</ul></li>
<li><a href="#文字列クラスからの変換関数">文字列クラスからの変換関数</a></li>
<li><a href="#string_viewの操作">string_viewの操作</a><ul>
<li><a href="#remove_prefixremove_suffix-先頭末尾の要素の削除">remove_prefix/remove_suffix : 先頭、末尾の要素の削除</a></li>
</ul></li>
<li><a href="#ユーザー定義リテラル">ユーザー定義リテラル</a></li>
</ul></li>
<li><a href="#メモリーリソース-動的ストレージ確保ライブラリ">メモリーリソース : 動的ストレージ確保ライブラリ</a><ul>
<li><a href="#メモリーリソース">メモリーリソース</a><ul>
<li><a href="#メモリーリソースの使い方">メモリーリソースの使い方</a></li>
<li><a href="#メモリーリソースの作り方">メモリーリソースの作り方</a></li>
</ul></li>
<li><a href="#polymorphic_allocator-動的ポリモーフィズムを実現するアロケーター">polymorphic_allocator : 動的ポリモーフィズムを実現するアロケーター</a><ul>
<li><a href="#コンストラクター">コンストラクター</a></li>
</ul></li>
<li><a href="#プログラム全体で使われるメモリーリソースの取得">プログラム全体で使われるメモリーリソースの取得</a><ul>
<li><a href="#new_delete_resource">new_delete_resource()</a></li>
<li><a href="#null_memory_resource">null_memory_resource()</a></li>
<li><a href="#デフォルトリソース">デフォルトリソース</a></li>
</ul></li>
<li><a href="#標準ライブラリのメモリーリソース">標準ライブラリのメモリーリソース</a></li>
<li><a href="#プールリソース">プールリソース</a><ul>
<li><a href="#アルゴリズム">アルゴリズム</a></li>
<li><a href="#synchronizedunsynchronized_pool_resource">synchronized/unsynchronized_pool_resource</a></li>
<li><a href="#pool_options">pool_options</a></li>
<li><a href="#プールリソースのコンストラクター">プールリソースのコンストラクター</a></li>
<li><a href="#プールリソースのメンバー関数">プールリソースのメンバー関数</a><ul>
<li><a href="#release">release()</a></li>
<li><a href="#upstream_resource">upstream_resource()</a></li>
<li><a href="#options">options()</a></li>
</ul></li>
</ul></li>
<li><a href="#モノトニックバッファーリソース">モノトニックバッファーリソース</a><ul>
<li><a href="#アルゴリズム-1">アルゴリズム</a></li>
<li><a href="#コンストラクター-1">コンストラクター</a></li>
<li><a href="#その他の操作">その他の操作</a><ul>
<li><a href="#release-1">release()</a></li>
<li><a href="#upstream_resource-1">upstream_resource()</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#並列アルゴリズム">並列アルゴリズム</a><ul>
<li><a href="#並列実行について">並列実行について</a></li>
<li><a href="#使い方-4">使い方</a></li>
<li><a href="#並列アルゴリズム詳細">並列アルゴリズム詳細</a><ul>
<li><a href="#並列アルゴリズム-1">並列アルゴリズム</a></li>
<li><a href="#ユーザー提供する関数オブジェクトの制約">ユーザー提供する関数オブジェクトの制約</a><ul>
<li><a href="#実引数で与えられたオブジェクトを直接間接に変更してはならない">実引数で与えられたオブジェクトを直接、間接に変更してはならない</a></li>
<li><a href="#実引数で与えられたオブジェクトの一意性に依存してはならない">実引数で与えられたオブジェクトの一意性に依存してはならない</a></li>
<li><a href="#データ競合と同期">データ競合と同期</a></li>
</ul></li>
<li><a href="#例外">例外</a></li>
<li><a href="#実行ポリシー">実行ポリシー</a><ul>
<li><a href="#is_execution_policy-traits">is_execution_policy traits</a></li>
<li><a href="#シーケンス実行ポリシー">シーケンス実行ポリシー</a></li>
<li><a href="#パラレル実行ポリシー">パラレル実行ポリシー</a></li>
<li><a href="#パラレル非シーケンス実行ポリシー">パラレル非シーケンス実行ポリシー</a></li>
<li><a href="#実行ポリシーオブジェクト">実行ポリシーオブジェクト</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数学の特殊関数群">数学の特殊関数群</a><ul>
<li><a href="#ラゲール多項式laguerre-polynomials">ラゲール多項式（Laguerre polynomials）</a></li>
<li><a href="#ラゲール陪多項式associated-laguerre-polynomials">ラゲール陪多項式（Associated Laguerre polynomials）</a></li>
<li><a href="#ルジャンドル多項式legendre-polynomials">ルジャンドル多項式（Legendre polynomials）</a></li>
<li><a href="#sf.cmath.assoc_legendre">ルジャンドル陪関数（Associated Legendre functions）</a></li>
<li><a href="#球面ルジャンドル陪関数spherical-associated-legendre-functions">球面ルジャンドル陪関数（Spherical associated Legendre functions）</a></li>
<li><a href="#エルミート多項式hermite-polynomials">エルミート多項式（Hermite polynomials）</a></li>
<li><a href="#ベータ関数beta-function">ベータ関数（Beta function）</a></li>
<li><a href="#第1種完全楕円積分complete-elliptic-integral-of-the-first-kind">第1種完全楕円積分（Complete elliptic integral of the first kind）</a></li>
<li><a href="#第2種完全楕円積分complete-elliptic-integral-of-the-second-kind">第2種完全楕円積分（Complete elliptic integral of the second kind）</a></li>
<li><a href="#第3種完全楕円積分complete-elliptic-integral-of-the-third-kind">第3種完全楕円積分（Complete elliptic integral of the third kind）</a></li>
<li><a href="#sf.cmath.ellint_1">第1種不完全楕円積分（Incomplete elliptic integral of the first kind）</a></li>
<li><a href="#sf.cmath.ellint_2">第2種不完全楕円積分（Incomplete elliptic integroal of the second kind）</a></li>
<li><a href="#sf.cmath.ellint_3">第3種不完全楕円積分（Incomplete elliptic integral of the third kind）</a></li>
<li><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数（Cylindrical Bessel functions of the first kind）</a></li>
<li><a href="#sf.cmath.cyl_neumann">ノイマン関数（Cylindrical Neumann functions）</a></li>
<li><a href="#sf.cmath.cyl_bessel_i">第1種変形ベッセル関数（Regular modified cylindrical Bessel functions）</a></li>
<li><a href="#第2種変形ベッセル関数irregular-modified-cylindrical-bessel-functions">第2種変形ベッセル関数（Irregular modified cylindrical Bessel functions）</a></li>
<li><a href="#第1種球ベッセル関数spherical-bessel-functions-of-the-first-kind">第1種球ベッセル関数（Spherical Bessel functions of the first kind）</a></li>
<li><a href="#球ノイマン関数spherical-neumann-functions">球ノイマン関数（Spherical Neumann functions）</a></li>
<li><a href="#指数積分exponential-integral">指数積分（Exponential integral）</a></li>
<li><a href="#リーマンゼータ関数riemann-zeta-function">リーマンゼータ関数（Riemann zeta function）</a></li>
</ul></li>
<li><a href="#その他の標準ライブラリ">その他の標準ライブラリ</a><ul>
<li><a href="#ハードウェア干渉サイズキャッシュライン">ハードウェア干渉サイズ（キャッシュライン）</a></li>
<li><a href="#stduncaught_exceptions">std::uncaught_exceptions</a></li>
<li><a href="#apply-tupleの要素を実引数に関数を呼び出す">apply : tupleの要素を実引数に関数を呼び出す</a></li>
<li><a href="#searcher-検索">Searcher : 検索</a><ul>
<li><a href="#default_searcher">default_searcher</a></li>
<li><a href="#boyer_moore_searcher">boyer_moore_searcher</a></li>
<li><a href="#boyer_moore_horspool_searcher">boyer_moore_horspool_searcher</a></li>
</ul></li>
<li><a href="#sample-乱択アルゴリズム">sample : 乱択アルゴリズム</a><ul>
<li><a href="#乱択アルゴリズム">乱択アルゴリズム</a></li>
<li><a href="#アルゴリズムs選択標本要素数がわかっている集合からの標本の選択">アルゴリズムS：選択標本、要素数がわかっている集合からの標本の選択</a></li>
<li><a href="#アルゴリズムr保管標本要素数がわからない集合からの標本の選択">アルゴリズムR：保管標本、要素数がわからない集合からの標本の選択</a></li>
<li><a href="#cのsample">C++のsample</a></li>
</ul></li>
<li><a href="#shared_ptrt-配列に対するshared_ptr">shared_ptr&lt;T[]&gt; : 配列に対するshared_ptr</a></li>
<li><a href="#as_const-const性の付与">as_const: const性の付与</a></li>
<li><a href="#make_from_tuple-tupleの要素を実引数にコンストラクターを呼び出す">make_from_tuple : tupleの要素を実引数にコンストラクターを呼び出す</a></li>
<li><a href="#invoke-指定した関数を指定した実引数で呼び出す">invoke : 指定した関数を指定した実引数で呼び出す</a></li>
<li><a href="#not_fn-戻り値の否定ラッパー">not_fn : 戻り値の否定ラッパー</a></li>
<li><a href="#メモリー管理アルゴリズム">メモリー管理アルゴリズム</a><ul>
<li><a href="#addressof">addressof</a></li>
<li><a href="#uninitialized_default_construct">uninitialized_default_construct</a></li>
<li><a href="#uninitialized_value_construct">uninitialized_value_construct</a></li>
<li><a href="#uninitialized_copy">uninitialized_copy</a></li>
<li><a href="#uninitialized_move">uninitialized_move</a></li>
<li><a href="#uninitialized_fill">uninitialized_fill</a></li>
<li><a href="#destory">destory</a></li>
</ul></li>
<li><a href="#shared_ptrweak_type">shared_ptr::weak_type</a></li>
<li><a href="#void_t">void_t</a></li>
<li><a href="#bool_constant">bool_constant</a></li>
<li><a href="#type_traits">type_traits</a><ul>
<li><a href="#変数テンプレート版traits">変数テンプレート版traits</a></li>
<li><a href="#論理演算traits">論理演算traits</a><ul>
<li><a href="#conjunction-論理積">conjunction : 論理積</a></li>
<li><a href="#disjunction-論理和">disjunction : 論理和</a></li>
</ul></li>
<li><a href="#negation-否定">negation : 否定</a></li>
<li><a href="#is_invocable-呼び出し可能か確認するtraits">is_invocable : 呼び出し可能か確認するtraits</a></li>
<li><a href="#has_unique_object_representations-同値の内部表現が同一か確認するtraits">has_unique_object_representations : 同値の内部表現が同一か確認するtraits</a></li>
<li><a href="#is_nothrow_swappable-無例外swap可能か確認するtraits">is_nothrow_swappable : 無例外swap可能か確認するtraits</a></li>
</ul></li>
<li><a href="#コンテナーで不完全型のサポート">コンテナーで不完全型のサポート</a></li>
<li><a href="#emplaceの戻り値">emplaceの戻り値</a></li>
<li><a href="#mapとunordered_mapの変更">mapとunordered_mapの変更</a><ul>
<li><a href="#try_emplace">try_emplace</a></li>
<li><a href="#insert_or_assign">insert_or_assign</a></li>
</ul></li>
<li><a href="#連想コンテナーへのsplice操作">連想コンテナーへのsplice操作</a><ul>
<li><a href="#merge">merge</a></li>
<li><a href="#ノードハンドル">ノードハンドル</a></li>
<li><a href="#extract-ノードハンドルの取得">extract : ノードハンドルの取得</a></li>
<li><a href="#insert-ノードハンドルから要素の追加">insert : ノードハンドルから要素の追加</a></li>
<li><a href="#ノードハンドルの利用例">ノードハンドルの利用例</a><ul>
<li><a href="#ストレージの再確保なしにコンテナーの一部の要素だけ別のコンテナーに移す">ストレージの再確保なしに、コンテナーの一部の要素だけ別のコンテナーに移す</a></li>
<li><a href="#コンテナーの寿命を超えて要素を存続させる">コンテナーの寿命を超えて要素を存続させる</a></li>
<li><a href="#mapのキーを変更する">mapのキーを変更する</a></li>
</ul></li>
</ul></li>
<li><a href="#コンテナーアクセス関数">コンテナーアクセス関数</a></li>
<li><a href="#clamp">clamp</a></li>
<li><a href="#次元hypot">3次元hypot</a></li>
<li><a href="#atomictis_always_lock_free">atomic&lt;T&gt;::is_always_lock_free</a></li>
<li><a href="#scoped_lock-可変長引数lock_guard">scoped_lock : 可変長引数lock_guard</a></li>
<li><a href="#stdbyte">std::byte</a></li>
<li><a href="#最大公約数gcdと最小公倍数lcm">最大公約数（gcd）と最小公倍数（lcm）</a><ul>
<li><a href="#gcd-最大公約数">gcd : 最大公約数</a></li>
<li><a href="#lcm-最小公倍数">lcm : 最小公倍数</a></li>
</ul></li>
</ul></li>
<li><a href="#ファイルシステム">ファイルシステム</a><ul>
<li><a href="#名前空間">名前空間</a></li>
<li><a href="#posix準拠">POSIX準拠</a></li>
<li><a href="#ファイルシステムの全体像">ファイルシステムの全体像</a></li>
<li><a href="#エラー処理">エラー処理</a><ul>
<li><a href="#例外-1">例外</a></li>
<li><a href="#非例外">非例外</a></li>
</ul></li>
<li><a href="#path-ファイルパス文字列クラス">path : ファイルパス文字列クラス</a><ul>
<li><a href="#ファイルパスの文字列">ファイルパスの文字列</a></li>
<li><a href="#ファイルパスの操作">ファイルパスの操作</a></li>
</ul></li>
<li><a href="#file_status">file_status</a></li>
<li><a href="#directory_entry">directory_entry</a></li>
<li><a href="#directory_iterator">directory_iterator</a><ul>
<li><a href="#エラー処理-1">エラー処理</a></li>
</ul></li>
<li><a href="#recursive_directory_iterator">recursive_directory_iterator</a><ul>
<li><a href="#オプション">オプション</a></li>
<li><a href="#depth-深さ取得">depth : 深さ取得</a></li>
<li><a href="#pop-現在のディレクトリーの列挙中止">pop : 現在のディレクトリーの列挙中止</a></li>
<li><a href="#recursion_pending-現在のディレクトリーの再帰をスキップ">recursion_pending : 現在のディレクトリーの再帰をスキップ</a></li>
</ul></li>
<li><a href="#ファイルシステム操作関数">ファイルシステム操作関数</a><ul>
<li><a href="#ファイルパス取得">ファイルパス取得</a><ul>
<li><a href="#current_path">current_path</a></li>
<li><a href="#temp_directory_path">temp_directory_path</a></li>
</ul></li>
<li><a href="#ファイルパス操作">ファイルパス操作</a><ul>
<li><a href="#absolute">absolute</a></li>
<li><a href="#canonical">canonical</a></li>
<li><a href="#weakly_canonical">weakly_canonical</a></li>
<li><a href="#relative">relative</a></li>
<li><a href="#proximate">proximate</a></li>
</ul></li>
<li><a href="#作成">作成</a><ul>
<li><a href="#create_directory">create_directory</a></li>
<li><a href="#create_directories">create_directories</a></li>
<li><a href="#create_directory_symlink">create_directory_symlink</a></li>
<li><a href="#create_symlink">create_symlink</a></li>
<li><a href="#create_hard_link">create_hard_link</a></li>
</ul></li>
<li><a href="#コピー">コピー</a><ul>
<li><a href="#copy_file">copy_file</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#copy_symlink">copy_symlink</a></li>
</ul></li>
<li><a href="#削除">削除</a><ul>
<li><a href="#remove">remove</a></li>
<li><a href="#remove_all">remove_all</a></li>
</ul></li>
<li><a href="#変更">変更</a><ul>
<li><a href="#permissions">permissions</a></li>
<li><a href="#rename">rename</a></li>
<li><a href="#resize_file">resize_file</a></li>
</ul></li>
<li><a href="#情報取得">情報取得</a><ul>
<li><a href="#ファイルタイプの判定">ファイルタイプの判定</a></li>
<li><a href="#status">status</a></li>
<li><a href="#status_known">status_known</a></li>
<li><a href="#symlink_status">symlink_status</a></li>
<li><a href="#equivalent">equivalent</a></li>
<li><a href="#exists">exists</a></li>
<li><a href="#file_size">file_size</a></li>
<li><a href="#hard_link_count">hard_link_count</a></li>
<li><a href="#last_write_time">last_write_time</a></li>
<li><a href="#read_symlink">read_symlink</a></li>
<li><a href="#space">space</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="はじめに">はじめに</h1>
<p>本書は2017年に規格制定されたプログラミング言語C++の国際規格、ISO/IEC 14882:2017の新機能をほぼすべて解説している。</p>
<p>新しいC++17は不具合を修正し、プログラマーの日々のコーディングを楽にする新機能がいくつも追加された。その結果、C++の特徴であるパフォーマンスや静的型付けは損なうことなく、近年の動的な型の弱い言語に匹敵するほどの柔軟な記述を可能にしている。</p>
<p>人によっては、新機能を学ぶのは労多くして益少なしと考えるかもしれぬが、C++の新機能は現実の問題を解決するための便利な道具として追加されるもので、仮に機能を使わないとしても問題はなくならないため、便利な道具なく問題に対処しなければならぬ。また、C++の機能は一般的なプログラマーにとって自然だと感じるように設計されているため、利用は難しくない。もしC++が難しいと感じるのであれば、それはC++が解決すべき現実の問題が難しいのだ。なんとなれば、我々は理想とは程遠い歪なアーキテクチャのコンピューターを扱う時代に生きている。CPUの性能上昇は停滞し、メモリはCPUに比べて遥かに遅く、しかもそのアクセスは定数時間ではない。キャッシュに収まる局所性を持つデータへの操作は無料同然で、キャッシュサイズの単位はすでにMBで数えられている。手のひらに乗る超低電力CPUでさえマルチコアが一般的になり、並列処理、非同期処理は全プログラマーが考慮せねばならぬ問題になった。</p>
<p>そのような時代にあたっては、かつては最良であった手法はその価値を失い、あるいは逆に悪い手法と成り下がる。同時に昔は現実的ではなかった手法が今ではかえってまともな方法になることさえある。このため、現在活発に使われている生きている言語は、常に時代に合わない機能を廃止し、必要な機能を追加する必要がある。C++の発展はここで留まることなく、今後もC++が使われ続ける限り、修正と機能追加が行われていくだろう。</p>
<p>本書の執筆はGithub上で公開して行われた。</p>
<p><a href="https://github.com/EzoeRyou/cpp17book" class="uri">https://github.com/EzoeRyou/cpp17book</a></p>
<p>本書のライセンスはGPLv3だ。</p>
<p>本書の執筆では株式会社ドワンゴとGitHub上でPull Requestを送ってくれた多くの貢献者の協力によって、誤りを正し、より良い記述を実現できた。この場を借りて謝意を表したい。</p>
<p>本書に誤りを見つけたならば、Pull Requestを送る先は<a href="https://github.com/EzoeRyou/cpp17book" class="uri">https://github.com/EzoeRyou/cpp17book</a>だ。</p>
<p>江添亮</p>
<h1 id="序">序</h1>
<h2 id="cの規格">C++の規格</h2>
<p>プログラミング言語C++はISOの傘下で国際規格ISO/IEC 14882として制定されている。この規格は数年おきに改定されている。一般にC++の規格を参照するときは、規格が制定した西暦の下二桁を取って、C++98（1998年発行）とかC++11（2011年発行）と呼ばれている。現在発行されているC++の規格は以下のとおり。</p>
<h3 id="c98">C++98</h3>
<p>C++98は1998年に制定された最初のC++の規格である。本来ならば1994年か1995年には制定させる予定が大幅にずれて、1998年となった。</p>
<h3 id="c03">C++03</h3>
<p>C++03はC++98の文面の曖昧な点を修正したマイナーアップデートとして2003年に制定された。新機能の追加はほとんどない。</p>
<h3 id="c11">C++11</h3>
<p>C++11は制定途中のドラフト段階では元C++0xと呼ばれていた。これは、200x年までに規格が制定される予定だったからだ。予定は大幅に遅れ、ようやく規格が制定されたときにはすでに2011年の年末になっていた。C++11ではとても多くの新機能が追加された。</p>
<h3 id="c14">C++14</h3>
<p>C++14は2014年に制定された。C++11の文面の誤りを修正した他、少し新機能が追加された。本書で解説する。</p>
<h3 id="c17">C++17</h3>
<p>C++17は2017年に制定されることが予定されている最新のC++規格で、本書で解説する。</p>
<h2 id="cの将来の規格">C++の将来の規格</h2>
<h3 id="c20">C++20</h3>
<p>C++20は2020年に制定されることが予定されている次のC++規格だ。この規格では、モジュール、コンセプト、レンジ、ネットワークに注力することが予定されている。</p>
<h2 id="コア言語とライブラリ">コア言語とライブラリ</h2>
<p>C++の標準規格は、大きく分けて、Cプリプロセッサーとコア言語とライブラリからなる。</p>
<p>Cプリプロセッサーとは、C++がC言語から受け継いだ機能だ。ソースファイルをトークン列単位で分割して、トークン列の置換ができる。</p>
<p>コア言語とは、ソースファイルに書かれたトークン列の文法とその意味のことだ。</p>
<p>ライブラリとは、コア言語機能を使って実装されたもので、標準に提供されているものだ。標準ライブラリには、純粋にコア言語の機能のみで実装できるものと、それ以外の実装依存の方法やコンパイラーマジックが必要なものとがある。</p>
<h1 id="sd-6-cのための機能テスト推奨">SD-6 C++のための機能テスト推奨</h1>
<p>C++17には機能テストのためのCプリプロセッサー機能が追加された。</p>
<h2 id="機能テストマクロ">機能テストマクロ</h2>
<p>機能テストというのは、C++の実装（C++コンパイラー）が特定の機能をサポートしているかどうかをコンパイル時に判断できる機能だ。本来、C++17の規格に準拠したC++実装は、C++17の機能をすべてサポートしているべきだ。しかし、残念ながら現実のC++コンパイラーの開発はそのようには行われていない。C++17に対応途中のC++コンパイラーは将来的にはすべての機能を実装することを目標としつつも、現時点では一部の機能しか実装していないという状態になる。</p>
<p>たとえば、C++11で追加された<code>rvalue</code>リファレンスという機能に現実のC++コンパイラーが対応しているかどうかをコンパイル時に判定するコードは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef __USE_RVALUE_REFERENCES</span>
  <span class="pp">#if (</span><span class="ot">__GNUC__</span><span class="pp"> &gt; 4 || </span><span class="ot">__GNUC__</span><span class="pp"> == 4 &amp;&amp; </span><span class="ot">__GNUC_MINOR__</span><span class="pp"> &gt;= 3) || \</span>
<span class="pp">      _MSC_VER &gt;= 1600</span>
    <span class="pp">#if __EDG_VERSION__ &gt; 0</span>
      <span class="pp">#define __USE_RVALUE_REFERENCES (__EDG_VERSION__ &gt;= 410)</span>
    <span class="pp">#else</span>
      <span class="pp">#define __USE_RVALUE_REFERENCES 1</span>
    <span class="pp">#endif</span>
  <span class="pp">#elif __clang__</span>
    <span class="pp">#define __USE_RVALUE_REFERENCES __has_feature(cxx_rvalue_references)</span>
  <span class="pp">#else</span>
    <span class="pp">#define __USE_RVALUE_REFERENCES 0</span>
  <span class="pp">#endif</span>
<span class="pp">#endif</span></code></pre></div>
<p>このそびえ立つクソのようなコードは現実に書かれている。このコードはGCCとMSVCとEDGとClangという現実に使われている主要な4つのC++コンパイラーに対応した<code>rvalue</code>リファレンスが実装されているかどうかを判定する機能テストコードだ。</p>
<p>この複雑なプリプロセッサーを解釈した結果、<code>__USE_RVALUE_REFERENCES</code>というプリプロセッサーマクロの値が、もしC++コンパイラーが<code>rvalue</code>リファレンスをサポートしているならば1、そうでなければ0となる。後は、このプリプロセッサーマクロで<code>#if</code>ガードしたコードを書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 文字列を処理する関数</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string <span class="at">const</span> &amp; str ) ;

<span class="pp">#if __USE_RVALUE_REFERENCES == 1</span>
<span class="co">// 文字列をムーブして処理してよい実装の関数</span>
<span class="co">// C++コンパイラーがrvalueリファレンスを実装していない場合はコンパイルされない</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string &amp;&amp; str ) ;
<span class="pp">#endif</span></code></pre></div>
<p>C++17では、上のようなそびえ立つクソのようなコードを書かなくてもすむように、標準の機能テストマクロが用意された。C++実装が特定の機能をサポートしている場合、対応する機能テストマクロが定義される。機能テストマクロの値は、その機能がC++標準に採択された年と月を合わせた6桁の整数で表現される。</p>
<p>たとえば<code>rvalue</code>リファレンスの場合、機能テストマクロの名前は<code>__cpp_rvalue_references</code>となっている。<code>rvalue</code>リファレンスは2006年10月に採択されたので、機能テストマクロの値は200610という値になっている。将来<code>rvalue</code>リファレンスの機能が変更されたときは機能テストマクロの値も変更される。この値を調べることによって使っているC++コンパイラーはいつの時代のC++標準の機能をサポートしているか調べることもできる。</p>
<p>この機能テストマクロを使うと、上のコードの判定は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 文字列を処理する関数</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string <span class="at">const</span> &amp; str ) ;

<span class="pp">#ifdef __cpp_rvalue_references</span>
<span class="co">// 文字列をムーブして処理してよい実装の関数</span>
<span class="co">// C++コンパイラーがrvalueリファレンスを実装していない場合はコンパイルされない</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string &amp;&amp; str ) ;
<span class="pp">#endif</span></code></pre></div>
<p>機能テストマクロの値は通常は気にする必要がない。機能テストマクロが存在するかどうかで機能の有無を確認できるので、通常は<code>#ifdef</code>を使えばよい。</p>
<h2 id="has_include式-ヘッダーファイルの存在を判定する">__has_include式 : ヘッダーファイルの存在を判定する</h2>
<p><code>__has_include</code>式は、ヘッダーファイルが存在するかどうかを調べるための機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include( ヘッダー名 )</code></pre></div>
<p><code>__has_include</code>式はヘッダー名が存在する場合1に、存在しない場合0に置換される。</p>
<p>たとえば、C++17の標準ライブラリにはファイルシステムが入る。そのヘッダー名は<code>&lt;filesystem&gt;</code>だ。C++コンパイラーがファイルシステムライブラリをサポートしているかどうかを調べるには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if __has_include(&lt;filesystem&gt;) </span>
<span class="co">// ファイルシステムをサポートしている</span>
<span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span>
<span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem ;
<span class="pp">#else</span>
<span class="co">// 実験的な実装を使う</span>
<span class="pp">#include </span><span class="im">&lt;experimental/filesystem&gt;</span>
<span class="kw">namespace</span> fs = <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
<span class="pp">#endif</span></code></pre></div>
<p>C++実装が<code>__has_include</code>をサポートしているかどうかは、<code>__has_include</code>の存在をプリプロセッサーマクロのように<code>#ifdef</code>で調べることによって判定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef __has_include</span>
<span class="co">// __has_includeをサポートしている</span>
<span class="pp">#else</span>
<span class="co">// __has_includeをサポートしていない</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>__has_include</code>式は<code>#if</code>と<code>#elif</code>の中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    <span class="cf">if</span> ( __has_include(&lt;vector&gt;) )
    { }
}</code></pre></div>
<h2 id="has_cpp_attribute式">__has_cpp_attribute式</h2>
<p>C++実装が特定の属性トークンをサポートしているかどうかを調べるには、<code>__has_cpp_attribute</code>式が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_cpp_attribute( 属性トークン )</code></pre></div>
<p><code>__has_cpp_attribute</code>式は、属性トークンが存在する場合は属性トークンが標準規格に採択された年と月を表す数値に、存在しない場合は0に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[nodiscard]]がサポートされている場合は使う</span>
<span class="pp">#if __has_cpp_attribute(nodiscard)</span>
[[<span class="at">nodiscard</span>]]
<span class="pp">#endif</span>
<span class="dt">void</span> * allocate_memory( <span class="bu">std::</span>size_t size ) ;</code></pre></div>
<p><code>__has_include</code>式と同じく、<code>__has_cpp_attribute</code>式も<code>#if</code>か<code>#elif</code>の中でしか使えない。<code>#ifdef</code>で<code>__has_cpp_attribute</code>式の存在の有無を判定できる。</p>
<h1 id="c14のコア言語の新機能">C++14のコア言語の新機能</h1>
<p>C++14で追加された新機能は少ない。C++14はC++03と同じくマイナーアップデートという位置付けで積極的な新機能の追加は見送られたからだ。</p>
<h2 id="二進数リテラル">二進数リテラル</h2>
<p>二進数リテラルは整数リテラルを二進数で記述する機能だ。整数リテラルのプレフィクスに<code>0B</code>もしくは<code>0b</code>を書くと、二進数リテラルになる。整数を表現する文字は0と1しか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="bn">0b0</span> ; <span class="co">// 0</span>
    <span class="dt">int</span> x2 = <span class="bn">0b1</span> ; <span class="co">// 1</span>
    <span class="dt">int</span> x3 = <span class="bn">0b10</span> ; <span class="co">// 2</span>
    <span class="dt">int</span> x4 = <span class="bn">0b11001100</span> ; <span class="co">// 204</span>
}</code></pre></div>
<p>二進数リテラルは浮動小数点数リテラルには使えない。</p>
<p>機能テストマクロは<code>__cpp_binary_literals</code>, 値は201304。</p>
<h2 id="数値区切り文字">数値区切り文字</h2>
<p>数値区切り文字は、整数リテラルと浮動小数点数リテラルの数値をシングルクオート文字で区切ることができる機能だ。区切り桁は何桁でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="dv">123&#39;456&#39;789</span> ;
    <span class="dt">int</span> x2 = <span class="dv">1&#39;2&#39;3&#39;4&#39;5&#39;6&#39;7&#39;8&#39;9</span> ; 
    <span class="dt">int</span> x3 = <span class="dv">1&#39;2345&#39;6789</span> ;
    <span class="dt">int</span> x4 = <span class="dv">1&#39;23&#39;456&#39;789</span> ;

    <span class="dt">double</span> x5 = <span class="fl">3.14159</span><span class="st">&#39;26535&#39;</span><span class="dv">89793</span> ;
}</code></pre></div>
<p>大きな数値を扱うとき、ソースファイルに<code>100000000</code>と<code>1000000000</code>と書かれていた場合、どちらが大きいのか人間の目にはわかりにくい。人間が読んでわかりにくいコードは間違いの元だ。数値区切りを使うと、<code>100'000'000と1'000'000'000</code>のように書くことができる。これはわかりやすい。</p>
<p>他には、1バイト単位で見やすいように区切ることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">unsigned</span> <span class="dt">int</span> x1 = <span class="bn">0xde&#39;ad&#39;be&#39;ef</span> ;
    <span class="dt">unsigned</span> <span class="dt">int</span> x2 = <span class="bn">0b11011110&#39;10101101&#39;10111110&#39;11101111</span> ;
}</code></pre></div>
<p>数値区切りはソースファイルを人間が読みやすくするための機能で、数値に影響を与えない。</p>
<h2 id="deprecated属性">[[deprecated]]属性</h2>
<p><code>[[deprecated]]</code>属性は名前とエンティティが、まだ使えるものの利用は推奨されない状態であることを示すのに使える。<code>[[deprecated]]</code>属性が指定できる名前とエンティティは、クラス、<code>typedef</code>名、変数、非<code>static</code>データメンバー、関数、名前空間、<code>enum</code>, <code>enumerator</code>, テンプレートの特殊化だ。</p>
<p>それぞれ以下のように指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 変数</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">deprecated</span>]] <span class="dt">int</span> variable_name1 { } ;
<span class="dt">int</span> variable_name2 [[<span class="at">deprecated</span>]] { } ;

<span class="co">// typedef名</span>
[[<span class="at">deprecated</span>]] <span class="kw">typedef</span> <span class="dt">int</span> typedef_name1 ;
<span class="kw">typedef</span> <span class="dt">int</span> typedef_name2 [[<span class="at">deprecated</span>]] ;
<span class="kw">using</span> typedef_name3 [[<span class="at">deprecated</span>]] = <span class="dt">int</span> ;

<span class="co">// 関数</span>
<span class="co">// メンバー関数も同じ文法</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">deprecated</span>]] <span class="dt">void</span> function_name1() { }
<span class="dt">void</span> function_name2 [[<span class="at">deprecated</span>]] () { }


<span class="co">// クラス</span>
<span class="co">// unionも同じ</span>
<span class="kw">class</span> [[<span class="at">deprecated</span>]] clas<span class="va">s_name</span>
{
<span class="co">// 非staticデータメンバー</span>
[[<span class="at">deprecated</span>]] <span class="dt">int</span> non_static_data_member_name ;
} ;

<span class="co">// enum</span>
<span class="kw">enum</span> <span class="kw">class</span> [[<span class="at">deprecated</span>]] enu<span class="va">m_name</span>
{
<span class="co">// enumerator</span>
enumerator_name [[<span class="at">deprecated</span>]] = <span class="dv">42</span>
} ;


<span class="co">// 名前空間</span>
<span class="kw">namespace</span> [[<span class="at">deprecated</span>]] namespace_name { <span class="dt">int</span> x ; }

<span class="co">// テンプレートの特殊化</span>

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> template_name { } ;

<span class="kw">template</span> &lt; &gt;
<span class="kw">class</span> [[<span class="at">deprecated</span>]] template_name&lt;<span class="dt">void</span>&gt; { } ;</code></pre></div>
<p><code>[[deprecated]]</code>属性が指定された名前やエンティティを使うと、C++コンパイラーは警告メッセージを出す。</p>
<p><code>[[deprecated]]</code>属性には、文字列を付け加えることができる。これはC++実装によっては警告メッセージに含まれるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">deprecated</span>(<span class="st">&quot;Use of f() is deprecated. Use f(int option) instead.&quot;</span>)]]
<span class="dt">void</span> f() ;

<span class="dt">void</span> f( <span class="dt">int</span> option ) ;</code></pre></div>
<p>機能テストマクロは<code>__has_cpp_attribute(deprecated)</code>, 値は201309。</p>
<h2 id="通常の関数の戻り値の型推定">通常の関数の戻り値の型推定</h2>
<p>関数の戻り値の型として<code>auto</code>を指定すると、戻り値の型を<code>return</code>文から推定してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ()</span>
<span class="kw">auto</span> a(){ <span class="cf">return</span> <span class="dv">0</span> ; }
<span class="co">// double ()</span>
<span class="kw">auto</span> b(){ <span class="cf">return</span> <span class="fl">0.0</span> ; }

<span class="co">// T(T)</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">auto</span> c(T t){ <span class="cf">return</span> t ; }</code></pre></div>
<p><code>return</code>文の型が一致していないとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f()
{
    <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// エラー、一致していない</span>
    <span class="cf">return</span> <span class="fl">0.0</span> ; <span class="co">// エラー、一致していない</span>
}</code></pre></div>
<p>すでに型が決定できる<code>return</code>文が存在する場合、関数の戻り値の型を参照するコードも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a()
{
    &amp;a ; <span class="co">// エラー、aの戻り値の型が決定していない</span>
    <span class="cf">return</span> <span class="dv">0</span> ;
}

<span class="kw">auto</span> b()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
    &amp;b ; <span class="co">// OK、戻り値の型はint</span>
}</code></pre></div>
<p>関数<code>a</code>へのポインターを使うには関数<code>a</code>の型が決定していなければならないが、<code>return</code>文の前に型は決定できないので関数<code>a</code>はエラーになる。関数<code>b</code>は<code>return</code>文が現れた後なので戻り値の型が決定できる。</p>
<p>再帰関数も書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sum( <span class="dt">unsigned</span> <span class="dt">int</span> i )
{
    <span class="cf">if</span> ( i == <span class="dv">0</span> )
        <span class="cf">return</span> i ; <span class="co">// 戻り値の型はunsigned int</span>
    <span class="cf">else</span>
        <span class="cf">return</span> sum(i<span class="dv">-1</span>)+i ; <span class="co">// OK</span>
}</code></pre></div>
<p>このコードも、<code>return</code>文の順番を逆にすると戻り値の型が決定できずエラーとなるので注意。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sum( <span class="dt">unsigned</span> <span class="dt">int</span> i )
{
    <span class="cf">if</span> ( i != <span class="dv">0</span> )
        <span class="cf">return</span> sum(i<span class="dv">-1</span>)+i ; <span class="co">// エラー</span>
    <span class="cf">else</span>
        <span class="cf">return</span> i ;
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_return_type_deduction</code>, 値は201304。</p>
<h2 id="decltypeauto-厳格なauto">decltype(auto) : 厳格なauto</h2>
<p><strong>警告</strong>：この項目はC++規格の詳細な知識を解説しているため極めて難解になっている。平均的なC++プログラマーはこの知識を得てもよりよいコードが書けるようにはならない。この項目は読み飛ばすべきである。</p>
<p><code>decltype(auto)</code>は<code>auto</code>指定子の代わりに使える厳格な<code>auto</code>だ。利用にはC++の規格の厳格な理解が求められる。</p>
<p><code>auto</code>と<code>decltype(auto)</code>は型指定子と呼ばれる文法の一種で、プレイスホルダー型として使う。</p>
<p>わかりやすく言うと、具体的な型を式から決定する機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// aはint</span>
<span class="kw">auto</span> a = <span class="dv">0</span> ;
<span class="co">// bはint </span>
<span class="kw">auto</span> b() { <span class="cf">return</span> <span class="dv">0</span> ; } </code></pre></div>
<p>変数宣言にプレイスホルダー型を使う場合、型を決定するための式は初期化子と呼ばれる部分に書かれる式を使う。関数の戻り値の型推定にプレイスホルダー型を使う場合、<code>return</code>文の式を使う。</p>
<p><code>decltype(auto)</code>は<code>auto</code>の代わりに使うことができる。<code>decltype(auto)</code>も型を式から決定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// aはint</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="dv">0</span> ;
<span class="co">// bはint</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) b() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>一見すると<code>auto</code>と<code>decltype(auto)</code>は同じようだ。しかし、この2つは式から型を決定する方法が違う。どちらもC++の規格の極めて難しい規則に基づいて決定される。習得には熟練の魔法使いであることが要求される。</p>
<p><code>auto</code>が式から型を決定するには、<code>auto</code>キーワードをテンプレートパラメーター名で置き換えた関数テンプレートの仮引数に、式を実引数として渡してテンプレート実引数推定を行わせた場合に推定される型が使われる。</p>
<p>たとえば</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> x = <span class="dv">0</span> ;</code></pre></div>
<p>の場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T u ) ;</code></pre></div>
<p>のような関数テンプレートに対して、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f(<span class="dv">0</span>) ;</code></pre></div>
<p>と実引数を渡したときに<code>u</code>の型として推定される型と同じ型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i ;
<span class="kw">auto</span> <span class="at">const</span> * x = &amp;i ;</code></pre></div>
<p>の場合には、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="at">const</span> * u ) ;</code></pre></div>
<p>のような関数テンプレートに</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f(&amp;i) ;</code></pre></div>
<p>と実引数を渡したときに<code>u</code>の型として推定される型と同じ型になる。この場合は<code>int const *</code>になる。</p>
<p>ここまでが<code>auto</code>の説明だ。<code>decltype(auto)</code>の説明は簡単だ。</p>
<p><code>decltype(auto)</code>の型は、<code>auto</code>を式で置き換えた<code>decltype</code>の型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="dv">0</span> ;

<span class="co">// int</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) f() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>上のコードは、下のコードと同じ意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">decltype</span>(<span class="dv">0</span>) a = <span class="dv">0</span> ;
<span class="kw">decltype</span>(<span class="dv">0</span>) f() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>ここまでは簡単だ。そして、これ以降は黒魔術のようなC++の規格の知識が必要になってくる。</p>
<p><code>auto</code>と<code>decltype(auto)</code>は一見すると同じように見える。型を決定する方法として、<code>auto</code>は関数テンプレートの実引数推定を使い、<code>decltype(auto)</code>は<code>decltype</code>を使う。どちらも式を評価した結果の型になる。いったい何が違うというのか。</p>
<p>主な違いは、<code>auto</code>は関数呼び出しを使うということだ。関数呼び出しの際にはさまざまな暗黙の型変換が行われる。</p>
<p>たとえば、配列を関数に渡すと、暗黙の型変換の結果、配列の先頭要素へのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T u ) {}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> array[<span class="dv">5</span>] ;
    <span class="co">// Tはint *</span>
    f( array ) ;
}</code></pre></div>
<p>では<code>auto</code>と<code>decltype(auto)</code>を使うとどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> array[<span class="dv">5</span>] ;
<span class="co">// int *</span>
<span class="kw">auto</span> x1 = array ;
<span class="co">// エラー、配列は配列で初期化できない</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = array ;</code></pre></div>
<p>このコードは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> array[<span class="dv">5</span>] ;
<span class="co">// int *</span>
<span class="dt">int</span> * x1 = array ;
<span class="co">// エラー、配列は配列で初期化できない</span>
<span class="dt">int</span> x2[<span class="dv">5</span>] = array ;</code></pre></div>
<p><code>auto</code>の場合、型は<code>int *</code>となる。配列は配列の先頭要素へのポインターへと暗黙に変換できるので、結果のコードは正しい。</p>
<p><code>decltype(auto)</code>の場合、型は<code>int [5]</code>となる。配列は配列で初期化、代入ができないので、このコードはエラーになる。</p>
<p>関数型も暗黙の型変換により関数へのポインター型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() ;

<span class="co">// 型はvoid(*)()</span>
<span class="kw">auto</span> x1 = f ;
<span class="co">// エラー、関数型は変数にできない</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f ;</code></pre></div>
<p><code>auto</code>はトップレベルのリファレンス修飾子を消すが、<code>decltype(auto)</code>は保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp; f()
{
    <span class="at">static</span> <span class="dt">int</span> x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="co">// int</span>
    <span class="kw">auto</span> x1 = f() ;
    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f() ;
}</code></pre></div>
<p>リスト初期化は<code>auto</code>では<code>std::initializer_list</code>だが、<code>decltype(auto)</code>では式ではないためエラー。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::initializer_list&lt;int&gt;</span>
    <span class="kw">auto</span> x1 = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
    <span class="co">// エラー、decltype({1,2,3})はできない</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
}</code></pre></div>
<p><code>decltype(auto)</code>は単体で使わなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
<span class="kw">auto</span> <span class="at">const</span> x1 = <span class="dv">0</span> ; 
<span class="co">// エラー</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) <span class="at">const</span> x2 = <span class="dv">0</span> ;</code></pre></div>
<p>この他にも<code>auto</code>と<code>decltype(auto)</code>にはさまざまな違いがある。すべての違いを列挙するのは煩雑なので省略するが、<code>decltype(auto)</code>は式の型を直接使う。<code>auto</code>はたいていの場合は便利な型の変換が入る。</p>
<p><code>auto</code>は便利でたいていの場合はうまくいくが暗黙の型の変換が入るため、意図どおりの推定をしてくれないことがある。</p>
<p>たとえば、引数でリファレンスを受け取り、戻り値でそのリファレンスを返す関数を書くとする。以下のように書くのは間違いだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ( int &amp; )</span>
<span class="kw">auto</span> f( <span class="dt">int</span> &amp; ref )
{ <span class="cf">return</span> ref ; }</code></pre></div>
<p>なぜならば、戻り値の型は式の型から変化して<code>int</code>になってしまうからだ。ここで<code>decltype(auto)</code>を使うと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int &amp; ( int &amp; )</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) f( <span class="dt">int</span> &amp; ref )
{ <span class="cf">return</span> ref ; }</code></pre></div>
<p>式の型をそのまま使ってくれる。</p>
<p>ラムダ式に<code>delctype(auto)</code>を使う場合は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]() -&gt; <span class="kw">decltype</span>(<span class="kw">auto</span>) { <span class="cf">return</span> <span class="dv">0</span> ; } ;</code></pre></div>
<p><code>decltype(auto)</code>は主に関数の戻り値の型推定で式の型をそのまま推定してくれるようにするために追加された機能だ。その利用にはC++の型システムの深い理解が必要になる。</p>
<p>機能テストマクロは<code>__cpp_decltype_auto</code>, 値は201304。</p>
<h2 id="ジェネリックラムダ">ジェネリックラムダ</h2>
<p>ジェネリックラムダはラムダ式の引数の型を書かなくてもすむようにする機能だ。</p>
<p>通常のラムダ式は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    []( <span class="dt">int</span> i, <span class="dt">double</span> d, <span class="bu">std::</span>string s ) { } ;
}</code></pre></div>
<p>ラムダ式の引数には型が必要だ。しかし、クロージャーオブジェクトの<code>operator ()</code>に渡す型はコンパイル時にわかる。コンパイル時にわかるということはわざわざ人間が指定する必要はない。ジェネリックラムダを使えば、引数の型を書くべき場所に<code>auto</code>キーワードを書くだけで型を推定してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    []( <span class="kw">auto</span> i, <span class="kw">auto</span> d, <span class="kw">auto</span> s ) { } ;
}</code></pre></div>
<p>ジェネリックラムダ式の結果のクロージャー型には呼び出しごとに違う型を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ; } ;

    f( <span class="dv">123</span> ) ; <span class="co">// int</span>
    f( <span class="fl">12.3</span> ) ; <span class="co">// double</span>
    f( <span class="st">&quot;hello&quot;</span> ) ; <span class="co">// char const *</span>
}</code></pre></div>
<p>仕組みは簡単で、以下のようなメンバーテンプレートの<code>operator ()</code>を持ったクロージャーオブジェクトが生成されているだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> closure_object
{
    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
    <span class="kw">auto</span> <span class="kw">operator</span> () ( T x )
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
} ;</code></pre></div>
<p>機能テストマクロは<code>__cpp_generic_lambdas</code>, 値は201304。</p>
<h2 id="初期化ラムダキャプチャー">初期化ラムダキャプチャー</h2>
<p>初期化ラムダキャプチャーはラムダキャプチャーする変数の名前と式を書くことができる機能だ。</p>
<p>ラムダ式は書かれた場所から見えるスコープの変数をキャプチャーする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> x ; } ;
    f() ;
}</code></pre></div>
<p>初期化ラムダキャプチャーはラムダキャプチャーに初期化子を書くことができる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [ x = x, y = x, &amp;ref = x, x2 = x * <span class="dv">2</span> ]
    {<span class="co">// キャプチャーされた変数を使う</span>
        x ;
        y ;
        ref ;
        x2 ;
    } ;
}</code></pre></div>
<p>初期化ラムダキャプチャーは、&quot;識別子 <code>= expr</code>&quot; という文法でラムダ導入子<code>[]</code>の中に書く。するとあたかも&quot;<code>auto</code> 識別子 <code>= expr ;</code>&quot;と書いたかのように変数が作られる。これによりキャプチャーする変数の名前を変えたり、まったく新しい変数を宣言することができる。</p>
<p>初期化ラムダキャプチャーの識別子の前に<code>&amp;</code>を付けると、リファレンスキャプチャー扱いになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [ &amp;ref = x ]()
    {
        ref = <span class="dv">1</span> ;
    }() ;

    <span class="co">// xは1</span>
}</code></pre></div>
<p>初期化ラムダキャプチャーが追加された理由には変数の名前を変えたりまったく新しい変数を導入したいという目的の他に、非<code>static</code>データメンバーをコピーキャプチャーするという目的がある。</p>
<p>以下のコードには問題があるが、わかるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data = <span class="dv">42</span> ;

    <span class="kw">auto</span> get_closure_object()
    {
        <span class="cf">return</span> [=]{ <span class="cf">return</span> data ; } ;
    }
} ;


<span class="dt">int</span> main()
{
    <span class="bu">std::</span>function&lt; <span class="dt">int</span>() &gt; f ;

    {
        X x ;
        f = x.get_closure_object() ;
    }

    <span class="bu">std::</span>cout &lt;&lt; f() &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p><code>X::get_closure_object</code>は<code>X::data</code>を返すクロージャーオブジェクトを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [=]{ <span class="cf">return</span> data ; } ;
}</code></pre></div>
<p>これを見ると、コピーキャプチャーである<code>[=]</code>を使っているので、<code>data</code>はクロージャーオブジェクト内にコピーされているように思える。しかし、ラムダ式は非<code>static</code>データメンバーをキャプチャーしてはいない。ラムダ式がキャプチャーしているのは<code>this</code>ポインターだ。上のコードと下のコードは同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [<span class="kw">this</span>]{ <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
}</code></pre></div>
<p>さて、<code>main</code>関数をもう一度見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// クロージャーオブジェクトを代入するための変数</span>
    <span class="bu">std::</span>function&lt; <span class="dt">int</span>() &gt; f ;

    {
        X x ; <span class="co">// xが構築される</span>
        f = x.get_closure_object() ;
        <span class="co">// xが破棄される</span>
    }

    <span class="co">// すでにxは破棄された</span>
    <span class="co">// return &amp;x-&gt;dataで破棄されたxを参照する</span>
    <span class="bu">std::</span>cout &lt;&lt; f() &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>なんと、すでに破棄されたオブジェクトへのリファレンスを参照してしまっている。これは未定義の動作だ。</p>
<p>初期化ラムダキャプチャーを使えば、非<code>static</code>データメンバーもコピーキャプチャーできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [data=data]{ <span class="cf">return</span> data ; } ;
}</code></pre></div>
<p>なお、ムーブキャプチャーは存在しない。ムーブというのは特殊なコピーなので初期化ラムダキャプチャーがあれば実現できるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f()
{
    <span class="bu">std::</span>string str ;
    <span class="bu">std::</span>cin &gt;&gt; str ;
    <span class="co">// ムーブ</span>
    <span class="cf">return</span> [str = <span class="bu">std::</span>move(str)]{ <span class="cf">return</span> str ; } ;
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_init_captures</code>, 値は201304。</p>
<h2 id="変数テンプレート">変数テンプレート</h2>
<p>変数テンプレートとは変数宣言をテンプレート宣言にできる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T variable { } ;

<span class="dt">int</span> main()
{
    variable&lt;<span class="dt">int</span>&gt; = <span class="dv">42</span> ;
    variable&lt;<span class="dt">double</span>&gt; = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>これだけではわからないだろうから、順を追って説明する。</p>
<p>C++ではクラスを宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X
{
    <span class="dt">int</span> member ;
} ;</code></pre></div>
<p>C++ではクラスをテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> X
{
<span class="kw">public</span> :
    T member ;
} ;

<span class="dt">int</span> main()
{
    X&lt;<span class="dt">int</span>&gt; i ;
    i.member = <span class="dv">42</span> ; <span class="co">// int</span>

    X&lt;<span class="dt">double</span>&gt; d ;
    d.member = <span class="fl">1.0</span> ; <span class="co">// double</span>
}</code></pre></div>
<p>C++では関数を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x )
{ <span class="cf">return</span> x ; }</code></pre></div>
<p>C++では関数をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T x )
{ <span class="cf">return</span> x ; }

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> i = f( <span class="dv">42</span> ) ; <span class="co">// int</span>
    <span class="kw">auto</span> d = f( <span class="fl">1.0</span> ) ; <span class="co">// double</span>
}</code></pre></div>
<p>C++11では<code>typedef</code>名を宣言するためにエイリアス宣言ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> ;</code></pre></div>
<p>C++11ではエイリアス宣言をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">using</span> type = T ;

<span class="dt">int</span> main()
{
    type&lt;<span class="dt">int</span>&gt; i = <span class="dv">42</span> ; <span class="co">// int</span>
    type&lt;<span class="dt">double</span>&gt; d = <span class="fl">1.0</span> ; <span class="co">// double</span>
}</code></pre></div>
<p>そろそろパターンが見えてきたのではないだろうか。C++では一部の宣言はテンプレート宣言できるということだ。このパターンを踏まえて以下を考えてみよう。</p>
<p>C++では変数を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> variable{} ;</code></pre></div>
<p>C++14では変数宣言をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T variable { } ;

<span class="dt">int</span> main()
{
    variable&lt;<span class="dt">int</span>&gt; = <span class="dv">42</span> ;
    variable&lt;<span class="dt">double</span>&gt; = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>変数テンプレートは名前どおり変数宣言をテンプレート宣言できる機能だ。変数テンプレートはテンプレート宣言なので、名前空間スコープとクラススコープの中にしか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// これはグローバル名前空間スコープという特別な名前空間スコープ</span>

<span class="kw">namespace</span> ns {
<span class="co">// 名前空間スコープ</span>
}

<span class="kw">class</span>
{
<span class="co">// クラススコープ</span>
} ;</code></pre></div>
<p>変数テンプレートの使い道は主に2つある。</p>
<h3 id="意味は同じだが型が違う定数">意味は同じだが型が違う定数</h3>
<p>プログラムでマジックナンバーを変数化しておくのは良い作法であるとされている。たとえば円周率を<code>3.14...</code>などと書くよりも<code>pi</code>という変数名で扱ったほうがわかりやすい。変数化すると、円周率の値が後で変わったときにプログラムを変更するのも楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">double</span> pi = <span class="fl">3.1415926535</span> ;</code></pre></div>
<p>しかし、円周率を表現する型が複数ある場合どうすればいいのか。よくあるのは名前を分ける方法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">float</span> pi_f = <span class="fl">3.1415</span> ;
<span class="kw">constexpr</span> <span class="dt">double</span> pi_d = <span class="fl">3.1415926535</span> ;
<span class="kw">constexpr</span> <span class="dt">int</span> pi_i = <span class="dv">3</span> ;
<span class="co">// 任意の精度の実数を表現できるクラスとする</span>
<span class="at">const</span> Real pi_r(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;</code></pre></div>
<p>しかしこれは、使う側で型によって名前を変えなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 円の面積を計算する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="co">// Tの型によって使うべき名前が変わる</span>
    <span class="cf">return</span> r * r * ??? ;
}</code></pre></div>
<p>関数テンプレートを使うという手がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> T pi()
{
    <span class="cf">return</span> <span class="kw">static_cast</span>&lt;T&gt;(<span class="fl">3.1415926535</span>) ;
}

<span class="kw">template</span> &lt; &gt;
Real pi()
{
    <span class="cf">return</span> Real(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;
}


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="cf">return</span> r * r * pi&lt;T&gt;() ;
}</code></pre></div>
<p>しかし、この場合引数は何もないのに関数呼び出しのための<code>()</code>が必要だ。</p>
<p>変数テンプレートを使うと以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> T pi = <span class="kw">static_cast</span>&lt;T&gt;(<span class="fl">3.1415926535</span>) ;

<span class="kw">template</span> &lt; &gt;
Real pi&lt;Real&gt;(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="cf">return</span> r * r * pi&lt;T&gt; ;
}</code></pre></div>
<h3 id="traitsのラッパー">traitsのラッパー</h3>
<p>値を返す<code>traits</code>で値を得るには<code>::value</code>と書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>is_pointer&lt;<span class="dt">int</span>&gt;::value ;
<span class="bu">std::</span>is_same&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt;::value ;</code></pre></div>
<p>C++14では<code>std::integral_constant</code>に<code>constexpr operator bool</code>が追加されたので、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>is_pointer&lt;<span class="dt">int</span>&gt;{} ;
<span class="bu">std::</span>is_same&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt;{} ;</code></pre></div>
<p>しかしまだ面倒だ。変数テンプレートを使うと<code>traits</code>の記述が楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_pointer_v = <span class="bu">std::</span>is_pointer&lt;T&gt;::value ;
<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> U &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v = <span class="bu">std::</span>is_same&lt;T, U&gt;::value ;

is_pointer_v&lt;<span class="dt">int</span>&gt; ;
is_same_v&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; ;</code></pre></div>
<p>C++の標準ライブラリでは従来の<code>traits</code>ライブラリを変数テンプレートでラップした<code>_v</code>版を用意している。</p>
<p>機能テストマクロは<code>__cpp_variable_templates</code>, 値は201304。</p>
<h2 id="constexpr関数の制限緩和">constexpr関数の制限緩和</h2>
<p>C++11で追加された<code>constexpr</code>関数はとても制限が強い。<code>constexpr</code>関数の本体には実質<code>return</code>文1つしか書けない。</p>
<p>C++14では、ほとんど何でも書けるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f( <span class="dt">int</span> x )
{
    <span class="co">// 変数を宣言できる</span>
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="co">// 繰り返し文を書ける</span>
    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt; x ; ++i )
    {
        <span class="co">// 変数を変更できる</span>
        sum += i ;
    }

    <span class="cf">return</span> sum ;
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_constexpr</code>, 値は201304。</p>
<p>C++11の<code>constexpr</code>関数に対応しているがC++14の<code>constexpr</code>関数に対応していないC++実装では、<code>__cpp_constexpr</code>マクロの値は200704になる。</p>
<h2 id="メンバー初期化子とアグリゲート初期化の組み合わせ">メンバー初期化子とアグリゲート初期化の組み合わせ</h2>
<p>C++14ではメンバー初期化子とアグリゲート初期化が組み合わせられるようになった。</p>
<p>メンバー初期化子とはクラスの非<code>static</code>データメンバーを<code>=</code>で初期化できるC++11の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// メンバー初期化子</span>
    <span class="dt">int</span> data = <span class="dv">123</span> ;
} ;</code></pre></div>
<p>アグリゲート初期化とはアグリゲートの条件を満たす型をリスト初期化で初期化できるC++11の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x, y, z ;
} ;

S s = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="co">// s.x == 1, s.y == 2, s.z == 3</span></code></pre></div>
<p>C++11ではメンバー初期化子を持つクラスはアグリゲート型の条件を満たさないのでアグリゲート初期化ができない。</p>
<p>C++14では、この制限が緩和された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x, y=<span class="dv">1</span>, z ;
} ;

S s1 = { <span class="dv">1</span> } ;
<span class="co">// s1.x == 1, s1.y == 1, s1.z == 0</span>

S s2{ <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="co">// s2.x == 1, s2.y == 2, s2.z == 3</span></code></pre></div>
<p>アグリゲート初期化で、メンバー初期化子を持つ非<code>static</code>データメンバーに対応する値がある場合はアグリゲート初期化が優先される。省略された場合はメンバー初期化子で初期化される。アグリゲート初期化でもメンバー初期化子でも明示的に初期化されていない非<code>static</code>データメンバーは空の初期化リストで初期化された場合と同じになる。</p>
<p>機能テストマクロは<code>__cpp_aggregate_nsdmi</code>, 値は201304。</p>
<h2 id="サイズ付き解放関数">サイズ付き解放関数</h2>
<p>C++14では<code>operator delete</code>のオーバーロードに、解放すべきストレージのサイズを取得できるオーバーロードが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>    ( <span class="dt">void</span> *, <span class="bu">std::</span>size_t ) <span class="kw">noexcept</span> ;
<span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>[]  ( <span class="dt">void</span> *, <span class="bu">std::</span>size_t ) <span class="kw">noexcept</span> ;</code></pre></div>
<p>第二引数は<code>std::size_t</code>型で、第一引数で指定されたポインターが指す解放すべきストレージのサイズが与えられる。</p>
<p>たとえば以下のように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * <span class="kw">operator</span> <span class="kw">new</span> ( <span class="bu">std::</span>size_t size )
{
    <span class="dt">void</span> * ptr =  <span class="bu">std::</span>malloc( size ) ;

    <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )
        <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc() ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;allocated storage of size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    <span class="cf">return</span> ptr ;
}

<span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span> ( <span class="dt">void</span> * ptr, <span class="bu">std::</span>size_t size ) <span class="kw">noexcept</span>
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;deallocated storage of size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    <span class="bu">std::</span>free( ptr ) ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> u1 = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="kw">auto</span> u2 = <span class="bu">std::</span>make_unique&lt;<span class="dt">double</span>&gt;(<span class="fl">0.0</span>) ;
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_sized_deallocation</code>, 値は201309。</p>
<h1 id="c17のコア言語の新機能">C++17のコア言語の新機能</h1>
<p>C++14の新機能のおさらいが終わったところで、いよいよC++17のコア言語の新機能を解説していく。</p>
<p>C++17のコア言語の新機能には、C++11ほどの大きなものはない。</p>
<h2 id="トライグラフの廃止">トライグラフの廃止</h2>
<p>C++17ではトライグラフが廃止された。</p>
<p>トライグラフを知らない読者はこの変更を気にする必要はない。トライグラフを知っている読者はなおさら気にする必要はない。</p>
<h2 id="進数浮動小数点数リテラル">16進数浮動小数点数リテラル</h2>
<p>C++17では浮動小数点数リテラルに16進数を使うことができるようになった。</p>
<p>16進数浮動小数点数リテラルは、プレフィクス<code>0x</code>に続いて仮数部を16進数（<code>0123456789abcdefABCDEF</code>）で書き、<code>p</code>もしくは<code>P</code>に続けて指数部を10進数で書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d1 = <span class="er">0x1p0</span> ; <span class="co">// 1</span>
<span class="dt">double</span> d2 = <span class="bn">0x1</span><span class="fl">.0</span>p0 ; <span class="co">// 1</span>
<span class="dt">double</span> d3 = <span class="er">0x10p0</span> ; <span class="co">// 16</span>
<span class="dt">double</span> d4 = <span class="er">0xabcp0</span> ; <span class="co">// 2748</span></code></pre></div>
<p>指数部は<code>e</code>ではなく<code>p</code>か<code>P</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d1 = <span class="er">0x1p0</span> ;
<span class="dt">double</span> d2 = <span class="er">0x1P0</span> ;</code></pre></div>
<p>16進数浮動小数点数リテラルでは、指数部を省略できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="bn">0x1</span> ; <span class="co">// 整数リテラル</span>
<span class="bn">0x1</span><span class="fl">.0</span> ; <span class="co">// エラー、指数部がない</span></code></pre></div>
<p>指数部は10進数で記述する。16進数浮動小数点数リテラルは仮数部に2の指数部乗を掛けた値になる。つまり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">0xNpM</span></code></pre></div>
<p>という浮動小数点数リテラルの値は</p>
<p><span class="math inline">\(N \times 2^M\)</span></p>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">0x1p0</span> ; <span class="co">// 1</span>
<span class="er">0x1p1</span> ; <span class="co">// 2</span>
<span class="er">0x1p2</span> ; <span class="co">// 4</span>
<span class="er">0x10p0</span> ; <span class="co">// 16</span>
<span class="er">0x10p1</span> ; <span class="co">// 32</span>
<span class="er">0x1p</span><span class="dv">-1</span> ; <span class="co">// 0.5</span>
<span class="er">0x1p</span><span class="dv">-2</span> ; <span class="co">// 0.25</span></code></pre></div>
<p>16進数浮動小数点数リテラルには浮動小数点数サフィックスを記述できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a = <span class="er">0x1p0f</span> ; <span class="co">// float</span>
<span class="kw">auto</span> b = <span class="er">0x1p0l</span> ; <span class="co">// long double</span></code></pre></div>
<p>16進数浮動小数点数リテラルは、浮動小数点数が表現方法の詳細を知っている環境（たとえばIEEE--754）で、正確な浮動小数点数の表現が記述できるようになる。</p>
<p>機能テストマクロは<code>__cpp_hex_float</code>, 値は201603。</p>
<h2 id="utf-8文字リテラル">UTF-8文字リテラル</h2>
<p>C++17ではUTF-8文字リテラルが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = u8<span class="st">&#39;a&#39;</span> ;</code></pre></div>
<p>UTF-8文字リテラルは文字リテラルにプレフィクス<code>u8</code>を付ける。UTF-8文字リテラルはUTF-8のコード単位1つで表現できる文字を扱うことができる。UCSの規格としては、C0制御文字と基本ラテン文字Unicodeブロックが該当する。UTF-8文字リテラルに書かれた文字が複数のUTF-8コード単位を必要とする場合はエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="co">// U+3042はUTF-8は0xE3, 0x81, 0x82という3つのコード単位で表現する必要が</span>
<span class="co">// あるため</span>
u8<span class="st">&#39;あ&#39;</span> ;</code></pre></div>
<p>機能テストマクロはない。</p>
<h2 id="関数型としての例外指定">関数型としての例外指定</h2>
<p>C++17では例外指定が関数型に組み込まれた。</p>
<p>例外指定とは<code>noexcept</code>のことだ。<code>noexcept</code>と<code>noexcept(true)</code>が指定された関数は例外を外に投げない。</p>
<p>C++14ではこの例外指定は型システムに入っていなかった。そのため、無例外指定の付いた関数へのポインター型は型システムで無例外を保証することができなかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// C++14のコード</span>
<span class="dt">void</span> f()
{
    <span class="cf">throw</span> <span class="dv">0</span> ; 
}

<span class="dt">int</span> main()
{
    <span class="co">// 無例外指定の付いたポインター</span>
    <span class="dt">void</span> (*p)() <span class="kw">noexcept</span> = &amp;f ;

    <span class="co">// 無例外指定があるにもかかわらず例外を投げる</span>
    p() ;
}</code></pre></div>
<p>C++17では例外指定が型システムに組み込まれた。例外指定のある関数型を例外指定のない関数へのポインター型に変換することはできる。逆はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 型はvoid()</span>
<span class="dt">void</span> f() { }
<span class="co">// 型はvoid() noexcept</span>
<span class="dt">void</span> g() <span class="kw">noexcept</span> { }

<span class="co">// OK</span>
<span class="co">// p1, &amp;fは例外指定のない関数へのポインター型</span>
<span class="dt">void</span> (*p1)() = &amp;f ;
<span class="co">// OK</span>
<span class="co">// 例外指定のある関数へのポインター型&amp;gを例外指定のない関数へのポインター型p2</span>
<span class="co">// に変換できる</span>
<span class="dt">void</span> (*p2)() = &amp;g ; <span class="co">// OK</span>

<span class="co">// エラー</span>
<span class="co">// 例外指定のない関数へのポインター型&amp;fは例外指定のある関数へのポインター型p3</span>
<span class="co">// に変換できない</span>
<span class="dt">void</span> (*p3)() <span class="kw">noexcept</span> = &amp;f ;

<span class="co">// OK</span>
<span class="co">// p4, &amp;gは例外指定のある関数へのポインター型</span>
<span class="dt">void</span> (*p4)() <span class="kw">noexcept</span> = &amp;g ;</code></pre></div>
<p>機能テストマクロは<code>__cpp_noexcept_function_type</code>, 値は201510。</p>
<h2 id="fold式">fold式</h2>
<p>C++17には<code>fold</code>式が入った。<code>fold</code>は元は数学の概念で畳み込みとも呼ばれている。</p>
<p>C++における<code>fold</code>式とはパラメーターパックの中身に二項演算子を適用するための式だ。</p>
<p>今、可変長テンプレートを使って受け取った値をすべて加算した合計を返す関数<code>sum</code>を書きたいとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( T x, Types ... args ) ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>) ; <span class="co">// 45</span>
}</code></pre></div>
<p>このような関数テンプレート<code>sum</code>は以下のように実装することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">auto</span> sum( T x )
{
    <span class="cf">return</span> x ;
}

<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( T x, Types ... args )
{
    <span class="cf">return</span> x + sum( args... )  ;
}</code></pre></div>
<p><code>sum(x, args)</code>は1番目の引数を<code>x</code>で、残りをパラメーターパック<code>args</code>で受け取る。そして、<code>x + sum( args ... )</code>を返す。すると、<code>sum( args ... )</code>はまた<code>sum(x, args)</code>に渡されて、1番目の引数、つまり最初から見て2番目の引数が<code>x</code>に入り、また<code>sum</code>が呼ばれる。このような再帰的な処理を繰り返していく。</p>
<p>そして、引数が1つだけになると、可変長テンプレートではない<code>sum</code>が呼ばれる。これは重要だ。なぜならば可変長テンプレートは0個の引数を取ることができるので、そのまま可変長テンプレート版の<code>sum</code>が呼ばれてしまうと、次の<code>sum</code>の呼び出しができずにエラーとなる。これを回避するために、また再帰の終了条件のために、引数が1つの<code>sum</code>のオーバーロード関数を書いておく。</p>
<p>可変長テンプレートでは任意個の引数に対応するために、このような再帰的なコードが必須になる。</p>
<p>しかし、ここで実現したいこととは<span class="math inline">\(N\)</span>個あるパラメーターパック<code>args</code>の中身に対して、仮に<span class="math inline">\(N\)</span>番目を<code>args#N</code>とする表記を使うと、<code>args#0</code> + <code>args#1</code> + ... + <code>args#N-1</code>のような展開をしたいだけだ。C++17の<code>fold</code>式はパラメーターパックに対して二項演算子を適用する展開を行う機能だ。</p>
<p><code>fold</code>式を使うと<code>sum</code>は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( Types ... args )
{
    <span class="cf">return</span> ( ... + args )  ;
}</code></pre></div>
<p><code>( ... + args )</code>は、<code>args#0</code> + <code>args#1</code> + ... + <code>args#N-1</code>のように展開される。</p>
<p><code>fold</code>式には、単項<code>fold</code>式と二項<code>fold</code>式がある。そして、演算子の結合順序に合わせて左<code>fold</code>と右<code>fold</code>がある。</p>
<p><code>fold</code>式は必ず括弧で囲まなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( Types ... args )
{
    <span class="co">// fold式</span>
    ( ... + args )  ;
    <span class="co">// エラー、括弧がない</span>
    ... + args ;
}</code></pre></div>
<p>単項<code>fold</code>式の文法は以下のいずれかになる。</p>
<pre><code>単項右fold
( cast-expression fold-operator ... )
単項左fold
( ... fold-operator cast-expression )</code></pre>
<p><strong>例</strong>：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> f( Types ... args )
{
    <span class="co">// 単項左fold</span>
    ( ... + args )  ;
    <span class="co">// 単項右fold</span>
    ( args + ... ) ;
}</code></pre></div>
<p><code>cast-expression</code>には未展開のパラメーターパックが入っていなければならない。</p>
<p><strong>例</strong>：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T x ) { <span class="cf">return</span> x ; }

<span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> g( Types ... args )
{
    <span class="co">// f(args#0) + f(args#1) + ... + f(args#N-1)</span>
    <span class="cf">return</span> ( ... + f(args) )  ;
}</code></pre></div>
<p>これは<code>f(args)</code>というパターンが展開される。</p>
<p><code>fold-operator</code>には以下のいずれかの二項演算子を使うことができる。</p>
<pre><code>+   -   *   /   %   ^   &amp;   |   &lt;&lt;  &gt;&gt;
+=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;= &gt;&gt;=
==  !=  &lt;   &gt;   &lt;=  &gt;=  &amp;&amp;  ||  ,   .*  -&gt;*</code></pre>
<p><code>fold</code>式には左<code>fold</code>と右<code>fold</code>がある。</p>
<p>左<code>fold</code>式の<code>( ... op pack )</code>では、展開結果は<code>((( pack#0 op pack#1 ) op pack#2 ) ... op pack#N-1 )</code>となる。右<code>fold</code>式の<code>( pack op ... )</code>では、展開結果は<code>( pack#0 op ( pack#1 op ( pack#2 op ( ... op pack#N-1 ))))</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> sum( Types ... args )
{
    <span class="co">// 左fold</span>
    <span class="co">// ((((1+2)+3)+4)+5)</span>
    <span class="kw">auto</span> left = ( ... + args ) ;
    <span class="co">// 右fold</span>
    <span class="co">// (1+(2+(3+(4+5))))</span>
    <span class="kw">auto</span> right = ( args + ... ) ;
}

<span class="dt">int</span> main()
{
    sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) ;
}</code></pre></div>
<p>浮動小数点数のような交換法則を満たさない型に<code>fold</code>式を適用する際には注意が必要だ。</p>
<p>二項<code>fold</code>式の文法は以下のいずれかになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">( cast-expression fold-<span class="kw">operator</span> ... fold-<span class="kw">operator</span> cast-expression )</code></pre></div>
<p>左右の<code>cast-expression</code>のどちらか片方だけに未展開のパラメーターパックが入っていなければならない。2つの<code>fold-operator</code>は同じ演算子でなければならない。</p>
<p><code>( e1 op1 ... op2 e2 )</code>という二項<code>fold</code>式があったとき、<code>e1</code>にパラメーターパックがある場合は二項右<code>fold</code>式、<code>e2</code>にパラメーターパックがある場合は二項左<code>fold</code>式になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> sum( Types ... args )
{
    <span class="co">// 左fold</span>
    <span class="co">// (((((0+1)+2)+3)+4)+5)</span>
    <span class="kw">auto</span> left = ( <span class="dv">0</span> + ... + args ) ;
    <span class="co">// 右fold</span>
    <span class="co">// (0+(1+(2+(3+(4+5)))))</span>
    <span class="kw">auto</span> right = ( args + ... + <span class="dv">0</span> ) ;
}

<span class="dt">int</span> main()
{
    sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) ;
}</code></pre></div>
<p><code>fold</code>式はパラメーターパックのそれぞれに二項演算子を適用したいときにわざわざ複雑な再帰的テンプレートを書かずにすむ方法を提供してくれる。</p>
<p>機能テストマクロは<code>__cpp_fold_expressions</code>, 値は201603。</p>
<h2 id="ラムダ式でthisのコピーキャプチャー">ラムダ式で*thisのコピーキャプチャー</h2>
<p>C++17ではラムダ式で<code>*this</code>をコピーキャプチャーできるようになった。<code>*this</code>をコピーキャプチャーするには、ラムダキャプチャーに<code>*this</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">42</span> ;
   <span class="kw">auto</span> get()
   {
       <span class="cf">return</span> [*<span class="kw">this</span>]() { <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
   }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>function &lt; <span class="dt">int</span> () &gt; f ;
    {
        X x ;
        f = x.get() ;
    }<span class="co">// xの寿命はここまで</span>
    
    <span class="co">// コピーされているので問題ない</span>
    <span class="dt">int</span> data = f() ;
}</code></pre></div>
<p>コピーキャプチャーする<code>*this</code>はラムダ式が書かれた場所の<code>*this</code>だ。</p>
<p>また、以下のようなコードで挙動の違いを見るとわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">0</span> ;
   <span class="dt">void</span> f()
   {
        <span class="co">// thisはポインターのキャプチャー</span>
        <span class="co">// dataはthisポインターをたどる</span>
        [<span class="kw">this</span>]{ data = <span class="dv">1</span> ; }() ;

        <span class="co">// this-&gt;dataは1</span>

        <span class="co">// エラー、*thisはコピーされている</span>
        <span class="co">// クロージャーオブジェクトのコピーキャプチャーされた変数は</span>
        <span class="co">// デフォルトで変更できない</span>
        [*<span class="kw">this</span>]{ data = <span class="dv">2</span> ; } () ;

        <span class="co">// OK、mutableを使っている</span>

        [*<span class="kw">this</span>]() <span class="at">mutable</span> { data = <span class="dv">2</span> ; } () ;

        <span class="co">// this-&gt;dataは1</span>
        <span class="co">// 変更されたのはコピーされたクロージャーオブジェクト内の*this        </span>
   }
} ;</code></pre></div>
<p>最初のラムダ式で生成されるクロージャーオブジェクトは以下のようなものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X * this_ptr ;

<span class="kw">public</span> :
    closure_object( X * this_ptr )
        : this_ptr(this_ptr) { }

    <span class="dt">void</span> <span class="kw">operator</span> () () <span class="at">const</span>
    {
        this_ptr-&gt;data = <span class="dv">1</span> ;
    }
} ;</code></pre></div>
<p>2番目のラムダ式では以下のようなクロージャーオブジェクトが生成される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X this_obj ;
    X <span class="at">const</span> * this_ptr = &amp;this_obj ;

<span class="kw">public</span> :
    closure_object( X <span class="at">const</span> &amp; this_obj )
        : this_obj(this_obj) { }

    <span class="dt">void</span> <span class="kw">operator</span> () () <span class="at">const</span>
    {
        this_ptr-&gt;data = <span class="dv">2</span> ;
    }
} ;</code></pre></div>
<p>これはC++の文法に従っていないのでやや苦しいコード例だが、コピーキャプチャーされた値を変更しようとしているためエラーとなる。</p>
<p>3番目のラムダ式では以下のようなクロージャーオブジェクトが生成される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X this_obj ;
    X * this_ptr = &amp;this_obj ;

<span class="kw">public</span> :
    closure_object( X <span class="at">const</span> &amp; this_obj )
        : this_obj(this_obj) { }

    <span class="dt">void</span> <span class="kw">operator</span> () ()
    {
        this_ptr-&gt;data = <span class="dv">2</span> ;
    }
} ;</code></pre></div>
<p>ラムダ式に<code>mutable</code>が付いているのでコピーキャプチャーされた値も変更できる。</p>
<p><code>*this</code>をコピーキャプチャーした場合、<code>this</code>キーワードはコピーされたオブジェクトへのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">42</span> ;
   <span class="dt">void</span> f()
   {
        <span class="co">// thisはこのメンバー関数fを呼び出したオブジェクトへのアドレス</span>
        <span class="bu">std::</span>printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">this</span>) ;

        <span class="co">// thisはコピーされた別のオブジェクトへのアドレス</span>
        [*<span class="kw">this</span>](){  <span class="bu">std::</span>printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">this</span>) ;  }() ;
   }
} ;

<span class="dt">int</span> main()
{
    X x ;
    x.f() ;
}</code></pre></div>
<p>この場合、出力される2つのポインターの値は異なる。</p>
<p>ラムダ式での<code>*this</code>のコピーキャプチャーは名前どおり<code>*this</code>のコピーキャプチャーを提供する提案だ。同等の機能は初期化キャプチャーでも可能だが、表記が冗長で間違いの元だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data ;

    <span class="kw">auto</span> f()
    {
        <span class="cf">return</span> [ tmp = *<span class="kw">this</span> ] { <span class="cf">return</span> tmp.data ; } ;
    }
} ;</code></pre></div>
<p>機能テストマクロは<code>__cpp_capture_star_this</code>, 値は201603。</p>
<h2 id="constexprラムダ式">constexprラムダ式</h2>
<p>C++17ではラムダ式が<code>constexpr</code>になった。より正確に説明すると、ラムダ式のクロージャーオブジェクトの<code>operator ()</code>は条件を満たす場合<code>constexpr</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []{ <span class="cf">return</span> <span class="dv">42</span> ; } ;

    <span class="kw">constexpr</span> <span class="dt">int</span> value = f() ; <span class="co">// OK</span>
}</code></pre></div>
<p><code>constexpr</code>の条件を満たすラムダ式はコンパイル時定数を必要とする場所で使うことができる。たとえば<code>constexpr</code>変数や配列の添字や<code>static_assert</code>などだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []{ <span class="cf">return</span> <span class="dv">42</span> ; } ;

    <span class="dt">int</span> a[f()] ;
    <span class="kw">static_assert</span>( f() == <span class="dv">42</span> ) ;
    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, f()&gt; b ;
}</code></pre></div>
<p><code>constexpr</code>の条件を満たすのであれば、キャプチャーもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">0</span> ; <span class="co">// 実行時の値</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> b = <span class="dv">0</span> ; <span class="co">// コンパイル時定数 </span>

    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> a ; } ;
    <span class="kw">auto</span> g = [=]{ <span class="cf">return</span> b ; } ;

    <span class="co">// エラー、constexprの条件を満たさない</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> c = f() ;

    <span class="co">// OK、constexprの条件を満たす</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> d = g() ;
}</code></pre></div>
<p>以下の内容は上級者向けの解説であり、通常の読者は理解する必要がない。</p>
<p><code>constexpr</code>ラムダ式はSFINAEの文脈で使うことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T,
    <span class="dt">bool</span> b = []{
        T t ;
        t.func() ;
        <span class="cf">return</span> <span class="kw">true</span> ;
    }() ; &gt;
<span class="dt">void</span> f()
{
    T t ;
    t.func() ;
}</code></pre></div>
<p>なぜならば、これを許してしまうとテンプレート仮引数に対して任意の式や文がテンプレートのSubstitutionに失敗するかどうかをチェックできてしまうからだ。</p>
<p>上級者向けの解説終わり。</p>
<p>機能テストマクロは<code>__cpp_constexpr</code>, 値は201603。</p>
<p><code>__cpp_constexpr</code>マクロの値は、C++11の時点で200704、C++14の時点で201304だ。</p>
<h2 id="文字列なしstatic_assert">文字列なしstatic_assert</h2>
<p>C++17では<code>static_assert</code>に文字列リテラルを取らないものが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>( <span class="kw">true</span> ) ;</code></pre></div>
<p>C++11で追加された<code>static_assert</code>には、文字列リテラルが必須だった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>( <span class="kw">true</span>, <span class="st">&quot;this shall not be asserted.&quot;</span> ) ;</code></pre></div>
<p>特に文字列を指定する必要がない場合もあるので、文字列リテラルを取らない<code>static_assert</code>が追加された。</p>
<p>機能テストマクロは<code>__cpp_static_assert</code>, 値は201411。</p>
<p>C++11の時点で<code>__cpp_static_assert</code>の値は200410。</p>
<h2 id="ネストされた名前空間定義">ネストされた名前空間定義</h2>
<p>C++17ではネストされた名前空間の定義を楽に書ける。</p>
<p>ネストされた名前空間とは、<code>A::B::C</code>のように名前空間の中に名前空間が入っている名前空間のことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A {
    <span class="kw">namespace</span> B {
        <span class="kw">namespace</span> C {
        <span class="co">// ...</span>
        }
    }
} </code></pre></div>
<p>C++17では、上記のコードと同じことを以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
<span class="co">// ...</span>
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_nested_namespace_definitions</code>, 値は201411。</p>
<h2 id="fallthrough属性">[[fallthrough]]属性</h2>
<p><code>[[fallthrough]]</code>属性は<code>switch</code>文の中の<code>case</code>ラベルを突き抜けるというヒントを出すのに使える。</p>
<p><code>switch</code>文では対応する<code>case</code>ラベルに処理が移る。通常、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> x )
{
    <span class="cf">switch</span> ( x )
    {
    <span class="cf">case</span> <span class="dv">0</span> :
        <span class="co">// 処理0</span>
        <span class="cf">break</span> ;
    <span class="cf">case</span> <span class="dv">1</span> :
        <span class="co">// 処理1</span>
        <span class="cf">break</span> ;
    <span class="cf">case</span> <span class="dv">2</span> :
        <span class="co">// 処理2</span>
        <span class="cf">break</span> ;
    <span class="cf">default</span> :
        <span class="co">// xがいずれでもない場合の処理</span>
        <span class="cf">break</span> ;
    }
}</code></pre></div>
<p>この例を以下のように書くと</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">case</span> <span class="dv">1</span> :
    <span class="co">// 処理1</span>
<span class="cf">case</span> <span class="dv">2</span> :
    <span class="co">// 処理2</span>
    <span class="cf">break</span> ;</code></pre></div>
<p><code>x</code>が1のときは処理1を実行した後に、処理2も実行される。<code>switch</code>文を書くときはこのような誤りを書いてしまうことがある。そのため、賢いC++コンパイラーは<code>switch</code>文の<code>case</code>ラベルで<code>break</code>文や<code>return</code>文などで処理が終わらず、次の<code>case</code>ラベルや<code>default</code>ラベルに処理に突き抜けるコードを発見すると、警告メッセージを出す。</p>
<p>しかし、プログラマーの意図がまさに突き抜けて処理してほしい場合、警告メッセージは誤った警告となってしまう。そのような警告メッセージを抑制するため、またコード中に処理が突き抜けるという意図をわかりやすく記述するために、<code>[[fallthrough]]</code>属性が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">case</span> <span class="dv">1</span> :
    <span class="co">// 処理1</span>
    [[<span class="at">fallthrough</span>]]
<span class="cf">case</span> <span class="dv">2</span> :
    <span class="co">// 処理2</span>
    <span class="cf">break</span> ;</code></pre></div>
<p><code>[[fallthrough]]</code>属性を書くと、C++コンパイラーは処理がその先に突き抜けることがわかるので、誤った警告メッセージを抑制できる。また、他人がコードを読むときに意図が明らかになる。</p>
<p>機能テストマクロは<code>__has_cpp_attribute(fallthrough)</code>, 値は201603。</p>
<h2 id="nodiscard属性">[[nodiscard]]属性</h2>
<p><code>[[nodiscard]]</code>属性は関数の戻り値が無視されてほしくないときに使うことができる。<code>[[nodiscard]]</code>属性が付与された関数の戻り値を無視すると警告メッセージが表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">nodiscard</span>]] <span class="dt">int</span> f()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
}

<span class="dt">void</span> g( <span class="dt">int</span> ) { }

<span class="dt">int</span> main()
{
    <span class="co">// エラー、戻り値が無視されている</span>
    f() ;

    <span class="co">// OK、戻り値は無視されていない</span>
    <span class="dt">int</span> result = f() ;
    g( f ) ;
    f() + <span class="dv">1</span> ;
    (<span class="dt">void</span>) f() ;
}</code></pre></div>
<p>戻り値を無視する、というのは万能ではない。上の例でも、意味的には戻り値は無視されていると言えるが、コンパイラーはこの場合に戻り値が無視されているとは考えない。</p>
<p><code>[[nodiscard]]</code>の目的は、戻り値を無視してほしくない関数をユーザーが利用したときの初歩的な間違いを防ぐためにある。<code>void</code>型にキャストするような意図的な戻り値の無視まで防ぐようには作られていない。</p>
<p><code>[[nodiscard]]</code>属性を使うべき関数は、戻り値を無視してほしくない関数だ。どのような関数が戻り値を無視してほしくないかというと大きく2つある。</p>
<p>戻り値をエラーなどのユーザーが確認しなければならない情報の通知に使う関数。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">struct</span> error_code
{
    no_error, some_operations_failed,  seriou<span class="va">s_error</span>
} ;

<span class="co">// 失敗するかもしれない処理</span>
error_code do_something_that_may_fail()
{
    <span class="co">// 処理</span>

    <span class="cf">if</span> ( is_error_condition() )
        <span class="cf">return</span> error_code::serious_error ;

    <span class="co">// 処理</span>

    <span class="cf">return</span> error_code::no_error ;
}

<span class="co">// エラーがいっさい発生しなかったときの処理</span>
<span class="dt">int</span> do_something_on_no_error() ;

<span class="dt">int</span> main()
{
    <span class="co">// エラーを確認していない</span>
    do_something_that_may_fail() ;

    <span class="co">// エラーがない前提で次の処理をしようとする</span>
    do_something_on_no_error() ;
}</code></pre></div>
<p>関数に<code>[[nodiscard]]</code>属性を付与しておけば、このようなユーザー側の初歩的なエラー確認の欠如に警告メッセージを出せる。</p>
<p><code>[[nodiscard]]</code>属性は、クラスと<code>enum</code>にも付与することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> [[<span class="at">nodiscard</span>]] X { } ;
<span class="kw">enum</span> <span class="kw">class</span> [[<span class="at">nodiscard</span>]] Y { } ;</code></pre></div>
<p><code>[[nodiscard]]</code>が付与されたクラスか<code>enum</code>が戻り値の型である関数は<code>[[nodiscard]]</code>が付与された扱いとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> [[<span class="at">nodiscard</span>]] X { } ;

X f() { <span class="cf">return</span> X{} ; } 

<span class="dt">int</span> main()
{
    <span class="co">// 警告、戻り値が無視されている</span>
    f() ;
}</code></pre></div>
<p>機能テストマクロは<code>__has_cpp_attribute(nodiscard)</code>, 値は201603。</p>
<h2 id="maybe_unused属性">[[maybe_unused]]属性</h2>
<p><code>[[maybe_unused]]</code>属性は名前やエンティティが意図的に使われないことを示すのに使える。</p>
<p>現実のC++のコードでは、宣言されているのにソースコードだけを考慮するとどこからも使われていないように見える名前やエンティティが存在する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_something( <span class="dt">int</span> *, <span class="dt">int</span> * ) ;

<span class="dt">void</span> f()
{
    <span class="dt">int</span> x[<span class="dv">5</span>] ;
    <span class="dt">char</span> reserved[<span class="dv">1024</span>] = { } ;
    <span class="dt">int</span> y[<span class="dv">5</span>] ;

    do_something( x, y ) ;
}</code></pre></div>
<p>ここでは<code>reserved</code>という名前はどこからも使われていない。一見すると不必要な名前に見える。優秀なC++コンパイラーはこのようなどこからも使われていない名前に対して「どこからも使われていない」という警告メッセージを出す。</p>
<p>しかし、コンパイラーから見えているソースコードがプログラムのすべてではない。さまざまな理由で<code>reserved</code>のような一見使われていない変数が必要になる。</p>
<p>たとえば、<code>reserved</code>はスタック破壊を検出するための領域かもしれない。プログラムはC++以外の言語で書かれたコードとリンクしていて、そこで使われるのかもしれない。あるいはOSや外部デバイスが読み書きするメモリーとして確保しているのかもしれない。</p>
<p>どのような理由にせよ、名前やエンティティが一見使われていないように見えるが存在が必要であるという意味を表すのに、<code>[[maybe_unused]]</code>属性を使うことができる。これにより、C++コンパイラーの「未使用の名前」という警告メッセージを抑制できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">maybe_unused</span>]] <span class="dt">char</span> reserved[<span class="dv">1024</span>] ;</code></pre></div>
<p><code>[[maybe_unused]]</code>属性を適用できる名前とエンティティの宣言は、クラス、<code>typedef</code>名、変数、非<code>static</code>データメンバー、関数、<code>enum</code>, <code>enumerator</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// クラス</span>
<span class="kw">class</span> [[<span class="at">maybe_unused</span>]] clas<span class="va">s_name</span>
{
<span class="co">// 非staticデータメンバー</span>
    [[<span class="at">maybe_unused</span>]] <span class="dt">int</span> non_static_data_member ;

} ;

<span class="co">// typedef名</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="kw">typedef</span> <span class="dt">int</span> typedef_name1 ;
<span class="kw">typedef</span> <span class="dt">int</span> typedef_name2 [[<span class="at">maybe_unused</span>]] ;

<span class="co">// エイリアス宣言によるtypedef名</span>
<span class="kw">using</span> typedef_name3 [[<span class="at">maybe_unused</span>]] = <span class="dt">int</span> ;

<span class="co">// 変数</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="dt">int</span> variable_name1{};
<span class="dt">int</span> variable_name2 [[<span class="at">maybe_unused</span>]] { } ;

<span class="co">// 関数</span>
<span class="co">// メンバー関数も同じ文法</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="dt">void</span> function_name1() { }
<span class="dt">void</span> function_name2 [[<span class="at">maybe_unused</span>]] () { }

<span class="kw">enum</span> [[<span class="at">maybe_unused</span>]] enu<span class="va">m_name</span>
{
<span class="co">// enumerator</span>
    enumerator_name [[<span class="at">maybe_unused</span>]] = <span class="dv">0</span>
} ;</code></pre></div>
<p>機能テストマクロは<code>__has_cpp_attribute(maybe_unused)</code>, 値は201603</p>
<h2 id="演算子のオペランドの評価順序の固定">演算子のオペランドの評価順序の固定</h2>
<p>C++17では演算子のオペランドの評価順序が固定された。</p>
<p>以下の式は、<code>a</code>, <code>b</code>の順番に評価されることが規格上保証される。<code>@=</code>の<code>@</code>には文法上許される任意の演算子が入る（<code>+=</code>, <code>-=</code>など）。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a.b
a-&gt;b
a-&gt;*b
a(b1,b2,b3)
b = a
b <span class="er">@</span>= a
a[b]
a &lt;&lt; b
a &gt;&gt; b</code></pre></div>
<p>つまり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>* f() ;
<span class="dt">int</span> g() ;

<span class="dt">int</span> main()
{
   f()[g()] ; 
}</code></pre></div>
<p>と書いた場合、関数<code>f</code>がまず先に呼び出されて、次に関数<code>g</code>が呼び出されることが保証される。</p>
<p>関数呼び出しの実引数のオペランド<code>b1</code>, <code>b2</code>, <code>b3</code>の評価順序は未規定のままだ。</p>
<p>これにより、既存の未定義の動作となっていたコードの挙動が定まる。</p>
<h2 id="constexpr-if文-コンパイル時条件分岐">constexpr if文 : コンパイル時条件分岐</h2>
<p><code>constexpr if</code>文はコンパイル時の条件分岐ができる機能だ。</p>
<p><code>constexpr if</code>文は、通常の<code>if</code>文を<code>if constexpr</code>で置き換える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// if文</span>
<span class="cf">if</span> ( expression )
    statement ;

<span class="co">// constexpr if文</span>
<span class="cf">if</span> <span class="kw">constexpr</span> ( expression )
    statement ;</code></pre></div>
<p><code>constexpr if</code>文という名前だが、実際に記述するときは<code>if constexpr</code>だ。</p>
<p>コンパイル時の条件分岐とは何を意味するのか。以下は<code>constexpr if</code>が<strong>行わないもの</strong>の一覧だ。</p>
<ul>
<li>最適化</li>
<li>非テンプレートコードにおける挙動の変化</li>
</ul>
<p>コンパイル時の条件分岐の機能を理解するには、まずC++の既存の条件分岐について理解する必要がある。</p>
<h3 id="実行時の条件分岐">実行時の条件分岐</h3>
<p>通常の実行時の条件分岐は、実行時の値を取り、実行時に条件分岐を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( runtime_value )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ;
}</code></pre></div>
<p>この場合、<code>runtime_value</code>が<code>true</code>の場合は関数<code>do_true_thing</code>が呼ばれ、<code>false</code>の場合は関数<code>do_false_thing</code>が呼ばれる。</p>
<p>実行時の条件分岐の条件には、コンパイル時定数を指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="kw">true</span> )
    do_true_thing() ;
<span class="cf">else</span>
    do_false_thing() ;</code></pre></div>
<p>この場合、賢いコンパイラーは以下のように処理を最適化するかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">do_true_thing() ;</code></pre></div>
<p>なぜならば、条件は常に<code>true</code>だからだ。このような最適化は実行時の条件分岐でもコンパイル時に行える。コンパイル時の条件分岐はこのような最適化が目的ではない。</p>
<p>もう一度コード例に戻ろう。今度は完全なコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( <span class="kw">true</span> )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>このコードはエラーになる。その理由は、<code>do_false_thing</code>という名前が宣言されていないからだ。C++コンパイラーは、コンパイル時にコードを以下の形に変形することで最適化することはできるが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_true_thing() ;

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    do_true_thing() ;
}</code></pre></div>
<p>最適化の結果失われたものも、依然としてコンパイル時にコードとして検証はされる。コードとして検証されるということは、コードとして誤りがあればエラーとなる。名前<code>do_false_thing</code>は宣言されていないのでエラーとなる。</p>
<h3 id="プリプロセス時の条件分岐">プリプロセス時の条件分岐</h3>
<p>C++がC言語から受け継いだCプリプロセッサーには、プリプロセス時の条件分岐の機能がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{

<span class="pp">#if true</span>
    do_true_thing() ;
<span class="pp">#else</span>
<span class="co">    do_false_thing() ;</span>
<span class="pp">#endif</span>
}</code></pre></div>
<p>このコードは、プリプロセスの結果、以下のように変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_true_thing() ;

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    do_true_thing() ;
}</code></pre></div>
<p>この結果、プリプロセス時の条件分岐では、選択されない分岐はコンパイルされないので、コンパイルエラーになるコードも書くことができる。</p>
<p>プリプロセス時の条件分岐は、条件が整数とか<code>bool</code>型のリテラルか、リテラルに比較演算子を適用した結果ではうまくいく。しかし、プリプロセス時とはコンパイル時ではないので、コンパイル時計算はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f()
{
    <span class="cf">return</span> <span class="dv">1</span> ;
}

<span class="dt">void</span> do_true_thing() ;

<span class="dt">int</span> main()
{
<span class="co">// エラー</span>
<span class="co">// 名前fはプリプロセッサーマクロではない</span>
<span class="pp">#if f()</span>
    do_true_thing() ;
<span class="pp">#else</span>
    do_false_thing() ;
<span class="pp">#endif</span>
}</code></pre></div>
<h3 id="コンパイル時の条件分岐">コンパイル時の条件分岐</h3>
<p>コンパイル時の条件分岐とは、分岐の条件にコンパイル時計算の結果を使い、かつ、選択されない分岐にコンパイルエラーが含まれていても、使われないのでコンパイルエラーにはならない条件分岐のことだ。</p>
<p>たとえば、<code>std::distance</code>という標準ライブラリを実装してみよう。<code>std::distance(first, last)</code>は、イテレーター<code>first</code>と<code>last</code>の距離を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="cf">return</span> last - first ;
}</code></pre></div>
<p>残念ながら、この実装は<code>Iterator</code>がランダムアクセスイテレーターの場合にしか動かない。入力イテレーターに対応させるには、イテレーターを1つずつインクリメントして<code>last</code>と等しいかどうか比較する実装が必要になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

    <span class="cf">while</span> ( first != last )
    {
        ++n ;
        ++first ;
    }

    <span class="cf">return</span> n ;
}</code></pre></div>
<p>残念ながら、この実装は<code>Iterator</code>にランダムアクセスイテレーターを渡したときに効率が悪い。</p>
<p>ここで必要な実装は、<code>Iterator</code>がランダムアクセスイテレーターならば<code>last - first</code>を使い、そうでなければ地道にインクリメントする遅い実装を使うことだ。<code>Iterator</code>がランダムアクセスイテレーターかどうかは、以下のコードを使えば、<code>is_random_access_iterator&lt;iterator&gt;</code>で確認できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_random_access_iterator =
    <span class="bu">std::</span>is_same_v&lt;
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; 
            <span class="bu">std::</span>decay_t&lt;Iterator&gt; 
        &gt;::iterator_category,
        <span class="bu">std::</span>random_access_iterator_tag &gt; ;</code></pre></div>
<p>すると、<code>distance</code>は以下のように書けるのではないか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ランダムアクセスイテレーターかどうかを判定するコード</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_random_access_iterator =
    <span class="bu">std::</span>is_same_v&lt;
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; 
            <span class="bu">std::</span>decay_t&lt;Iterator&gt;
        &gt;::iterator_category,
        <span class="bu">std::</span>random_access_iterator_tag &gt; ;

<span class="co">// distance</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="co">// ランダムアクセスイテレーターかどうか確認する</span>
    <span class="cf">if</span> ( is_random_access_iterator&lt;Iterator&gt; )
    {<span class="co">// ランダムアクセスイテレーターなので速い方法を使う</span>
        <span class="cf">return</span> last - first ;
    }
    <span class="cf">else</span>
    { <span class="co">// ランダムアクセスイテレーターではないので遅い方法を使う</span>
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

        <span class="cf">while</span> ( first != last )
        {
            ++n ;
            ++first ;
        }

        <span class="cf">return</span> n ;
    }
}</code></pre></div>
<p>残念ながら、このコードは動かない。ランダムアクセスイテレーターではないイテレーターを渡すと、<code>last - first</code>というコードがコンパイルされるので、コンパイルエラーになる。コンパイラーは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( is_random_access_iterator&lt;Iterator&gt; )</code></pre></div>
<p>という部分について、<code>is_random_access_iterator&lt;Iterator&gt;</code>の値はコンパイル時に計算できるので、最終的なコード生成の結果としては、<code>if (true)</code>か<code>if (false)</code>になると判断できる。したがってコンパイラーは選択されない分岐のコード生成を行わないことはできる。しかしコンパイルはするので、コンパイルエラーになる。</p>
<p><code>constexpr if</code>を使うと、選択されない部分の分岐はコンパイルエラーであってもコンパイルエラーとはならなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// distance</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="co">// ランダムアクセスイテレーターかどうか確認する</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( is_random_access_iterator&lt;Iterator&gt; )
    {<span class="co">// ランダムアクセスイテレーターなので速い方法を使う</span>
        <span class="cf">return</span> last - first ;
    }
    <span class="cf">else</span>
    { <span class="co">// ランダムアクセスイテレーターではないので遅い方法を使う</span>
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

        <span class="cf">while</span> ( first != last )
        {
            ++n ;
            ++first ;
        }

        <span class="cf">return</span> n ;
    }
}</code></pre></div>
<h3 id="超上級者向け解説">超上級者向け解説</h3>
<p><code>constexpr if</code>は、実はコンパイル時条件分岐ではない。テンプレートの実体化時に、選択されないブランチのテンプレートの実体化の抑制を行う機能だ。</p>
<p><code>constexpr if</code>によって選択されない文は<code>discarded statement</code>となる。<code>discarded statement</code>はテンプレートの実体化の際に実体化されなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> get() { <span class="cf">return</span> <span class="dv">0</span> ; } 
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">int</span> f(T x)
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt; <span class="bu">std::</span>decay_t&lt;T&gt;, X &gt; )
        <span class="cf">return</span> x.get() ;
    <span class="cf">else</span>
        <span class="cf">return</span> x ;

}

<span class="dt">int</span> main()
{
    X x ;
    f( x ) ; <span class="co">// return x.get() </span>
    f( <span class="dv">0</span> ) ; <span class="co">// return x</span>
}</code></pre></div>
<p><code>f(x)</code>では、<code>return x</code>が<code>discarded statement</code>となるため実体化されない。<code>X</code>は<code>int</code>型に暗黙に変換できないが問題がなくなる。<code>f(0)</code>では<code>return x.get()</code>が<code>discarded statement</code>となるため実体化されない。<code>int</code>型にはメンバー関数<code>get</code>はないが問題はなくなる。</p>
<p><code>discarded statement</code>は実体化されないだけで、もちろんテンプレートのエンティティの一部だ。<code>discarded statement</code>がテンプレートのコードとして文法的、意味的に正しくない場合は、もちろんコンパイルエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T x )
{
    <span class="co">// エラー、名前gは宣言されていない</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">false</span> )
        g() ; 

    <span class="co">// エラー、文法違反</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">false</span> )
        !<span class="er">#$</span>%^&amp;*()_+ ;
}</code></pre></div>
<p>何度も説明しているように、<code>constexpr if</code>はテンプレートの実体化を条件付きで抑制するだけだ。条件付きコンパイルではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; )
    {
        <span class="co">// 常にコンパイルエラー</span>
        <span class="kw">static_assert</span>( <span class="kw">false</span> ) ;
    }
}</code></pre></div>
<p>このコードは常にコンパイルエラーになる。なぜならば、<code>static_assert( false )</code>はテンプレートに依存しておらず、テンプレートの宣言を解釈するときに、依存名ではないから、そのまま解釈される。</p>
<p>このようなことをしたければ、最初から<code>static_assert</code>のオペランドに式を書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="kw">static_assert</span>( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; ) ;

    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; )
    {
    }
}</code></pre></div>
<p>もし、どうしても<code>constexpr</code>文の条件に合うときにだけ<code>static_assert</code>が使いたい場合もある。これは、<code>constexpr if</code>をネストしたりしていて、その内容を全部<code>static_assert</code>に書くのが冗長な場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( E1 )
        <span class="cf">if</span> <span class="kw">constexpr</span> ( E2 )
            <span class="cf">if</span> <span class="kw">constexpr</span> ( E3 )
            {
                <span class="co">// E1 &amp;&amp; E2 &amp;&amp; E3のときにコンパイルエラーにしたい</span>
                <span class="co">// 実際には常にコンパイルエラー</span>
                <span class="kw">static_assert</span>( <span class="kw">false</span> ) ;
            }
}</code></pre></div>
<p>現実には、<code>E1</code>, <code>E2</code>, <code>E3</code>は複雑な式なので、<code>static_assert( E1 &amp;&amp; E2 &amp;&amp; E3 )</code>と書くのは冗長だ。同じ内容を二度書くのは間違いの元だ。</p>
<p>このような場合、<code>static_assert</code>のオペランドをテンプレート引数に依存するようにすると、<code>constexpr if</code>の条件に合うときにだけ発動する<code>static_assert</code>が書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>  &lt; <span class="kw">typename</span> ... &gt;
<span class="dt">bool</span> false_v = <span class="kw">false</span> ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( E1 )
        <span class="cf">if</span> <span class="kw">constexpr</span> ( E2 )
            <span class="cf">if</span> <span class="kw">constexpr</span> ( E3 )
            {
                <span class="kw">static_assert</span>( false_v&lt;T&gt; ) ;
            }
}</code></pre></div>
<p>このように<code>false_v</code>を使うことで、<code>static_assert</code>をテンプレート引数<code>T</code>に依存させる。その結果、<code>static_assert</code>の発動をテンプレートの実体化まで遅延させることができる。</p>
<p><code>constexpr if</code>は非テンプレートコードでも書くことができるが、その場合は普通の<code>if</code>文と同じだ。</p>
<h3 id="constexpr-ifでは解決できない問題">constexpr ifでは解決できない問題</h3>
<p><code>constexpr if</code>は条件付きコンパイルではなく、条件付きテンプレート実体化の抑制なので、最初の問題の解決には使えない。たとえば以下のコードはエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">true</span> )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>理由は、名前<code>do_false_thing</code>は非依存名なのでテンプレートの宣言時に解決されるからだ。</p>
<h3 id="constexpr-ifで解決できる問題">constexpr ifで解決できる問題</h3>
<p><code>constexpr if</code>は依存名が関わる場合で、テンプレートの実体化がエラーになる場合に、実体化を抑制させることができる。</p>
<p>たとえば、特定の型に対して特別な操作をしたい場合</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> get_value() ;
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f(T t)
{
    
    <span class="dt">int</span> value{} ;

    <span class="co">// Tの型がXならば特別な処理を行いたい</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same&lt;T, X&gt;{} )
    {
        value = t.get_value() ;
    }
    <span class="cf">else</span>
    {
        value = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(t) ;
    }
}</code></pre></div>
<p>もし<code>constexpr if</code>がなければ、<code>T</code>の型が<code>X</code>ではないときも<code>t.get_value()</code>という式が実体化され、エラーとなる。</p>
<p>再帰的なテンプレートの特殊化をやめさせたいとき</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// factorial&lt;N&gt;はNの階乗を返す</span>
<span class="kw">template</span> &lt; <span class="bu">std::</span>size_t I  &gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t factorial()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( I == <span class="dv">1</span> )
    { <span class="cf">return</span> <span class="dv">1</span> ; }
    <span class="cf">else</span>
    { <span class="cf">return</span> I * factorial&lt;I<span class="dv">-1</span>&gt;() ; }
}</code></pre></div>
<p>もし<code>constexpr if</code>がなければ、<code>factorial&lt;N-1&gt;</code>が永遠に実体化されコンパイル時ループが停止しない。</p>
<p>機能テストマクロは<code>__cpp_if_constexpr</code>, 値は201606。</p>
<h2 id="初期化文付き条件文">初期化文付き条件文</h2>
<p>C++17では、条件文に初期化文を記述できるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="dt">int</span> x = <span class="dv">1</span> ; x )
     <span class="co">/*...*/</span> ;

<span class="cf">switch</span>( <span class="dt">int</span> x = <span class="dv">1</span> ; x )
{
    <span class="cf">case</span> <span class="dv">1</span> :
        <span class="co">/*... */</span>;
}</code></pre></div>
<p>これは、以下のコードと同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="cf">if</span> ( x ) ;
}

{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="cf">switch</span>( x )
    {
        <span class="cf">case</span> <span class="dv">1</span> : ;
    }
}</code></pre></div>
<p>なぜこのような機能が追加されたかというと、変数を宣言し、<code>if</code>文の条件に変数を使い、<code>if</code>文を実行後は変数を使用しない、というパターンは現実のコードで頻出するからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc(<span class="dv">10</span>) ;
<span class="cf">if</span> ( ptr != <span class="kw">nullptr</span> )
{
    <span class="co">// 処理</span>
    <span class="bu">std::</span>free(ptr) ;
}
<span class="co">// これ以降ptrは使わない</span>

FILE * file = <span class="bu">std::</span>fopen(<span class="st">&quot;text.txt&quot;</span>, <span class="st">&quot;r&quot;</span>) ;
<span class="cf">if</span> ( file != <span class="kw">nullptr</span> )
{
    <span class="co">// 処理</span>
    <span class="bu">std::</span>fclose( file ) ;
}
<span class="co">// これ以降fileは使わない</span>

<span class="kw">auto</span> int_ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
<span class="cf">if</span> ( ptr )
{
    <span class="co">// 処理</span>
}
<span class="co">// これ以降int_ptrは使わない</span></code></pre></div>
<p>上記のコードには問題がある。これ以降変数は使わないが、変数自体は使えるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
<span class="cf">if</span> ( ptr )
{
    <span class="co">// 処理</span>
}
<span class="co">// これ以降ptrは使わない</span>

<span class="co">// でも使える</span>
<span class="dt">int</span> value = *ptr ;</code></pre></div>
<p>変数を使えないようにするには、ブロックスコープで囲むことで、変数をスコープから外してやればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="kw">auto</span> int_ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
    <span class="cf">if</span> ( ptr )
    {
        <span class="co">// 処理</span>
    }
    <span class="co">// ptrは破棄される</span>
}
<span class="co">// これ以降ptrは使わないし使えない</span></code></pre></div>
<p>このようなパターンは頻出するので、初期化文付きの条件文が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ; ptr )
{
    <span class="co">// 処理</span>
}</code></pre></div>
<h2 id="クラステンプレートのコンストラクターからの実引数推定">クラステンプレートのコンストラクターからの実引数推定</h2>
<p>C++17ではクラステンプレートのコンストラクターの実引数からテンプレート実引数の推定が行えるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> X
{
    X( T t ) { }
} ;

<span class="dt">int</span> main()
{
    X x1(<span class="dv">0</span>) ; <span class="co">// X&lt;int&gt;</span>
    X x2(<span class="fl">0.0</span>) ; <span class="co">// X&lt;double&gt;</span>
    X x3(<span class="st">&quot;hello&quot;</span>) ; <span class="co">// X&lt;char const *&gt;</span>
}</code></pre></div>
<p>これは関数テンプレートが実引数からテンプレート実引数の推定が行えるのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T t ) { }

<span class="dt">int</span> main()
{
    f( <span class="dv">0</span> ) ; <span class="co">// f&lt;int&gt;</span>
    f( <span class="fl">0.0</span> ) ; <span class="co">// f&lt;double&gt;</span>
    f( <span class="st">&quot;hello&quot;</span> ) ; <span class="co">// f&lt;char const *&gt;</span>
}</code></pre></div>
<h3 id="推定ガイド">推定ガイド</h3>
<p>クラステンプレートのコンストラクターからの実引数は便利だが、クラスのコンストラクターはクラステンプレートのテンプレートパラメーターに一致しない場合もある。そのような場合はそのままでは実引数推定ができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// コンテナー風のクラス</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> Container
{
    <span class="bu">std::</span>vector&lt;T&gt; c ;
<span class="kw">public</span> :
    <span class="co">// 初期化にイテレーターのペアを取る</span>
    <span class="co">// IteratorはTではない</span>
    <span class="co">// Tは推定できない</span>
    <span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
    Container( Iterator first, Iterator last )
        : c( first, last )
    { }
} ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="co">// エラー</span>
    <span class="co">// Tを推定できない</span>
    Container c( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a) ) ;
}</code></pre></div>
<p>このため、C++17には推定ガイドという機能が提供されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">テンプレート名( 引数リスト ) -&gt; テンプレートid ;</code></pre></div>
<p>これを使うと、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
Container( Iterator, Iterator )
-&gt; Container&lt; <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; Iterator &gt;::<span class="dt">value_type</span> &gt; ;</code></pre></div>
<p>C++コンパイラーはこの推定ガイドを使って、<code>Container&lt;T&gt;::Container(Iterator, Iterator)</code>からは、<code>T</code>を<code>std::iterator_traits&lt;Iterator&gt;::value_type</code>として推定すればいいのだと判断できる。</p>
<p>たとえば、初期化リストに対応するには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> Container
{
    <span class="bu">std::</span>vector&lt;T&gt; c ;
<span class="kw">public</span> :

    Container( <span class="bu">std::</span>initializer_list&lt;T&gt; init )
        : c( init )
    { }
} ;


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
Container( <span class="bu">std::</span>initializer_list&lt;T&gt; ) -&gt; Container&lt;T&gt; ;


<span class="dt">int</span> main()
{
    Container c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
}</code></pre></div>
<p>C++コンパイラーはこの推定ガイドから、<code>Container&lt;T&gt;::Container( std::initializer_list&lt;T&gt; )</code>の場合は<code>T</code>を<code>T</code>として推定すればよいことがわかる。</p>
<p>機能テストマクロは<code>__cpp_deduction_guides</code>, 値は201606。</p>
<h2 id="autoによる非型テンプレートパラメーターの宣言">autoによる非型テンプレートパラメーターの宣言</h2>
<p>C++17では非型テンプレートパラメーターの宣言に<code>auto</code>を使うことができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">auto</span> x &gt;
<span class="kw">struct</span> X { } ;

<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    X&lt;<span class="dv">0</span>&gt; x1 ;
    X&lt;<span class="dv">0l</span>&gt; x2 ;
    X&lt;&amp;f&gt; x3 ;
}</code></pre></div>
<p>これはC++14までであれば、以下のように書かなければならなかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, T x &gt;
<span class="kw">struct</span> X { } ;

<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    X&lt;<span class="dt">int</span>, <span class="dv">0</span>&gt; x1 ;
    X&lt;<span class="dt">long</span>, <span class="dv">0l</span>&gt; x2 ;
    X&lt;<span class="dt">void</span>(*)(), &amp;f&gt; x3 ;
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_template_auto</code>, 値は201606。</p>
<h2 id="using属性名前空間">using属性名前空間</h2>
<p>C++17では、属性名前空間に<code>using</code>ディレクティブのような記述ができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// [[extention::foo, extention::bar]]と同じ</span>
[[ <span class="at">using</span> <span class="at">extention</span> <span class="at">:</span> <span class="at">foo</span>, <span class="at">bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>属性トークンには、属性名前空間を付けることができる。これにより、独自拡張の属性トークンの名前の衝突を避けることができる。</p>
<p>たとえば、あるC++コンパイラーには独自拡張として<code>foo</code>, <code>bar</code>という属性トークンがあり、別のC++コンパイラーも同じく独自拡張として<code>foo</code>, <code>bar</code>という属性トークンを持っているが、それぞれ意味が違っている場合、コードの意味も違ってしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[ <span class="at">foo</span>, <span class="at">bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>このため、C++には属性名前空間という文法が用意されている。注意深いC++コンパイラーは独自拡張の属性トークンには属性名前空間を設定していることだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[ <span class="at">extention::foo</span>, <span class="at">extention::bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>問題は、これをいちいち記述するのは面倒だということだ。</p>
<p>C++17では、<code>using</code>属性名前空間という機能により、<code>using</code>ディレクティブのような名前空間の省略が可能になった。文法は<code>using</code>ディレクティブと似ていて、属性の中で<code>using name : ...</code>と書くことで、コロンに続く属性トークンに、属性名前空間<code>name</code>を付けたものと同じ効果が得られる。</p>
<h2 id="非標準属性の無視">非標準属性の無視</h2>
<p>C++17では、非標準の属性トークンは無視される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK、無視される</span>
[[ <span class="at">wefapiaofeaofjaopfij</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>属性はC++コンパイラーによる独自拡張をC++の規格に準拠する形で穏便に追加するための機能だ。その属性のためにコンパイルエラーになった場合、けっきょくCプリプロセッサーを使うか、わずらわしさから独自の文法が使われてしまう。そのためこの機能は必須だ。</p>
<h2 id="構造化束縛">構造化束縛</h2>
<p>C++17で追加された構造化束縛は多値を分解して受け取るための変数宣言の文法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
    <span class="kw">auto</span> [b,c,d] = a ;

    <span class="co">// b == 1</span>
    <span class="co">// c == 2</span>
    <span class="co">// d == 3</span>
}</code></pre></div>
<p>C++では、さまざまな方法で多値を扱うことができる。たとえば配列、クラス、<code>tuple</code>, <code>pair</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="kw">struct</span> B
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> b ;
    <span class="bu">std::</span>string c ;
} ;

B b{ <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

<span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; c { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

<span class="bu">std::</span>pair&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; d{ <span class="dv">1</span>, <span class="dv">2</span> } ;</code></pre></div>
<p>C++の関数は配列以外の多値を返すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}</code></pre></div>
<p>多値を受け取るには、これまでは多値を固まりとして受け取るか、ライブラリで分解して受け取るしかなかった。</p>
<p>多値を固まりで受け取るには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> result = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(result) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(result) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(result) &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>多値をライブラリで受け取るには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> b ;
    <span class="bu">std::</span>string c ;

    <span class="bu">std::</span>tie( a, b, c ) = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>構造化束縛を使うと、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> [a, b, c] = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>変数の型はそれぞれ対応する多値の型になる。この場合、<code>a</code>, <code>b</code>, <code>c</code>はそれぞれ<code>int</code>, <code>double</code>, <code>std::string</code>型になる。</p>
<p><code>tuple</code>だけではなく、<code>pair</code>も使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; p( <span class="dv">1</span>, <span class="dv">2</span> ) ;

    <span class="kw">auto</span> [a,b] = p ;

    <span class="co">// aはint型、値は1</span>
    <span class="co">// bはint型、値は2</span>
}</code></pre></div>
<p>構造化束縛は<code>if</code>文と<code>switch</code>文、<code>for</code>文でも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="cf">if</span> ( <span class="kw">auto</span>[a,b,c] = expr ; a )
    { }
    <span class="cf">switch</span>( <span class="kw">auto</span>[a,b,c] = expr ; a )
    { }
    <span class="cf">for</span> ( <span class="kw">auto</span>[a,b,c] = expr ; <span class="kw">false</span> ; ) 
    { }
}</code></pre></div>
<p>構造化束縛は<code>range-based for</code>文にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="bu">std::</span>string, <span class="bu">std::</span>string &gt; translation_table
    {
        {<span class="st">&quot;dog&quot;</span>, <span class="st">&quot;犬&quot;</span>},
        {<span class="st">&quot;cat&quot;</span>, <span class="st">&quot;猫&quot;</span>},
        {<span class="st">&quot;answer&quot;</span>, <span class="st">&quot;42&quot;</span>} 
    } ;
    
    <span class="cf">for</span> ( <span class="kw">auto</span> [key, value] : translation_table )
    {
        <span class="bu">std::</span>cout&lt;&lt;
            <span class="st">&quot;key=&quot;</span>&lt;&lt; key &lt;&lt;
            <span class="st">&quot;, value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<p>これは、<code>map</code>の要素型<code>std::pair&lt;const std::string, std::string&gt;</code>を構造化束縛<code>[key, value]</code>で受けている。</p>
<p>構造化束縛は配列にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> values[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b,c] = values ;
}</code></pre></div>
<p>構造化束縛はクラスにも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Values
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string c ;
} ;

<span class="dt">int</span> main()
{
    Values values{ <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

    <span class="kw">auto</span> [a,b,c] = values ;
}</code></pre></div>
<p>構造化束縛でクラスを使う場合は、非<code>static</code>データメンバーはすべて1つのクラスの<code>public</code>なメンバーでなければならない。</p>
<p>構造化束縛は<code>constexpr</code>にはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">constexpr</span> <span class="dt">int</span> expr[] = { <span class="dv">1</span>,<span class="dv">2</span> } ;

    <span class="co">// エラー</span>
    <span class="kw">constexpr</span> <span class="kw">auto</span> [a,b] = expr ;
}</code></pre></div>
<h3 id="超上級者向け解説-1">超上級者向け解説</h3>
<p>構造化束縛は、変数の宣言のうち、<strong>構造化束縛宣言（structured binding declaration）</strong>に分類される文法で記述する。構造化束縛宣言となる宣言は、単純宣言（simple-declaration）と<code>for-range</code>宣言（for-range-declaration）のうち、<code>[</code>識別子リスト<code>]</code>があるものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">単純宣言:
    属性 <span class="kw">auto</span> CV修飾子(省略可) リファレンス修飾子(省略可)
    [ 識別子リスト ] 初期化子 ;

<span class="cf">for</span>-range宣言:
    属性 <span class="kw">auto</span> CV修飾子(省略可) リファレンス修飾子(省略可)
    [ 識別子リスト ] ;

識別子リスト:
    コンマで区切られた識別子

初期化子:
    = 式
    { 式 }
    ( 式 )</code></pre></div>
<p>以下は単純宣言のコード例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> e1[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">struct</span> { <span class="dt">int</span> a,b,c ; } e2{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> e3 = <span class="bu">std::</span>make_tuple(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) ;
    
    <span class="co">// &quot;= 式&quot;の例</span>
    <span class="kw">auto</span> [a,b,c] = e1 ;
    <span class="kw">auto</span> [d,e,f] = e2 ;
    <span class="kw">auto</span> [g,h,i] = e3 ;
    
    <span class="co">// &quot;{式}&quot;, &quot;(式)&quot;の例</span>
    <span class="kw">auto</span> [j,k,l]{e1} ;
    <span class="kw">auto</span> [m,n,o](e1) ;

    <span class="co">// CV修飾子とリファレンス修飾子を使う例</span>
    <span class="kw">auto</span> <span class="at">const</span> &amp; [p,q,r] = e1 ;
}</code></pre></div>
<p>以下は<code>for-range</code>宣言の例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; pairs[] = { {<span class="dv">1</span>,<span class="dv">2</span>}, {<span class="dv">3</span>,<span class="dv">4</span>}, {<span class="dv">5</span>,<span class="dv">6</span>} } ;
    
    <span class="cf">for</span> ( <span class="kw">auto</span> [a, b] : pairs )
    {
        <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h3 id="構造化束縛宣言の仕様">構造化束縛宣言の仕様</h3>
<p>構造化束縛の構造化束縛宣言は以下のように解釈される。</p>
<p>構造化束縛宣言によって宣言される変数の数は、初期化子の多値の数と一致していなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 2個の値を持つ</span>
    <span class="dt">int</span> expr[] = {<span class="dv">1</span>,<span class="dv">2</span>} ;

    <span class="co">// エラー、変数が少なすぎる</span>
    <span class="kw">auto</span>[a] = expr ; 
    <span class="co">// エラー、変数が多すぎる</span>
    <span class="kw">auto</span>[b,c,d] = expr ;
}</code></pre></div>
<p>構造化束縛宣言で宣言されるそれぞれの変数名について、記述されたとおりの属性、CV修飾子、リファレンス修飾子の変数が宣言される。</p>
<h3 id="初期化子の型が配列の場合">初期化子の型が配列の場合</h3>
<p>初期化子が配列の場合、それぞれの変数はそれぞれの配列の要素で初期化される。</p>
<p>リファレンス修飾子がない場合、それぞれの変数はコピー初期化される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b,c] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> a = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> b = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> c = expr[<span class="dv">2</span>] ;
}</code></pre></div>
<p>リファレンス修飾子がある場合、変数はリファレンスとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> &amp; [a,b,c] = expr ;
    <span class="kw">auto</span> &amp;&amp; [d,e,f] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> &amp; a = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> &amp; b = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp; c = expr[<span class="dv">2</span>] ;

    <span class="dt">int</span> &amp;&amp; d = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> &amp;&amp; e = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp;&amp; f = expr[<span class="dv">2</span>] ;
}</code></pre></div>
<p>もし、変数の型が配列の場合、配列の要素はそれぞれ対応する配列の要素で初期化される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,<span class="dv">2</span>}} ;
    <span class="kw">auto</span> [a,b] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,<span class="dv">2</span>}} ;

    <span class="dt">int</span> a[<span class="dv">2</span>] = { expr[<span class="dv">0</span>][<span class="dv">0</span>], expr[<span class="dv">0</span>][<span class="dv">1</span>] } ;
    <span class="dt">int</span> b[<span class="dv">2</span>] = { expr[<span class="dv">1</span>][<span class="dv">0</span>], expr[<span class="dv">1</span>][<span class="dv">1</span>] } ;    
}</code></pre></div>
<h3 id="初期化子の型が配列ではなくstdtuple_sizeeが完全形の名前である場合">初期化子の型が配列ではなく、std::tuple_size&lt;E&gt;が完全形の名前である場合</h3>
<p>構造化束縛宣言の初期化子の型<code>E</code>が配列ではない場合で、<code>std::tuple_size&lt;E&gt;</code>が完全形の名前である場合、 構造化束縛宣言の初期化子の型を<code>E</code>, その値を<code>e</code>とする。構造化束縛宣言で宣言される1つ目の変数を0, 2つ目の変数を1, ..., とインクリメントされていくインデックスを<code>i</code>とする。</p>
<p><code>std::tuple_size&lt;E&gt;::value</code>は整数のコンパイル時定数式で、その値は初期化子の値の数でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::tuple&lt; int, int, int &gt;</span>
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> [a,b,c] = e ;

    <span class="co">// std::tuple_size&lt;decltype(e)&gt;::sizeは3</span>
}</code></pre></div>
<p>それぞれの値を取得するために、非修飾名<code>get</code>が型<code>E</code>のクラススコープから探される。<code>get</code>が見つかった場合、それぞれの変数の初期化子は<code>e.get&lt;i&gt;()</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> [a,b,c] = e ;</code></pre></div>
<p>という構造化束縛宣言は、以下の意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">type a = e.get&lt;<span class="dv">0</span>&gt;() ;
type b = e.get&lt;<span class="dv">1</span>&gt;() ;
type c = e.get&lt;<span class="dv">2</span>&gt;() ;</code></pre></div>
<p>そのような<code>get</code>の宣言が見つからない場合、初期化子は<code>get&lt;i&gt;(e)</code>となる。この場合、<code>get</code>は連想名前空間から探される。通常の非修飾名前検索は行われない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ただし通常の非修飾名前検索は行われない</span>
type a = get&lt;<span class="dv">0</span>&gt;(e) ;
type b = get&lt;<span class="dv">1</span>&gt;(e) ;
type c = get&lt;<span class="dv">2</span>&gt;(e) ;</code></pre></div>
<p>構造化束縛宣言で宣言される変数の型は以下のように決定される。</p>
<p>変数の型<code>type</code>は&quot;<code>std::tuple_element&lt;i, E&gt;::type</code>&quot;となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type a = get&lt;<span class="dv">0</span>&gt;(e) ;
<span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type b = get&lt;<span class="dv">1</span>&gt;(e) ;
<span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type c = get&lt;<span class="dv">2</span>&gt;(e) ;</code></pre></div>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> [a,b,c] = e ;
}</code></pre></div>
<p>以下とほぼ同等の意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    
    <span class="kw">using</span> E = <span class="kw">decltype</span>(e) ;

    <span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type &amp; a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(e) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type &amp; b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(e) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type &amp; c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(e) ;
}</code></pre></div>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> &amp;&amp; [a,b,c] = <span class="bu">std::</span>move(e) ;
}</code></pre></div>
<p>以下のような意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    
    <span class="kw">using</span> E = <span class="kw">decltype</span>(e) ;

    <span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type &amp;&amp; a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(<span class="bu">std::</span>move(e)) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type &amp;&amp; b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(<span class="bu">std::</span>move(e)) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type &amp;&amp; c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(<span class="bu">std::</span>move(e)) ;
}</code></pre></div>
<h3 id="上記以外の場合">上記以外の場合</h3>
<p>上記以外の場合、構造化束縛宣言の初期化子の型<code>E</code>はクラス型で、すべての非<code>static</code>データメンバーは<code>public</code>の直接のメンバーであるか、あるいは単一の曖昧ではない<code>public</code>基本クラスのメンバーである必要がある。<code>E</code>に匿名<code>union</code>メンバーがあってはならない。</p>
<p>以下は型<code>E</code>として適切なクラスの例である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A
{
    <span class="dt">int</span> a, b, c ;
} ;

<span class="kw">struct</span> B : A { } ;</code></pre></div>
<p>以下は型<code>E</code>として不適切なクラスの例である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// public以外の非staticデータメンバーがある</span>
<span class="kw">struct</span> A
{
<span class="kw">public</span> :
    <span class="dt">int</span> a ;
<span class="kw">private</span> :
    <span class="dt">int</span> b ;
} ;



<span class="kw">struct</span> B
{
    <span class="dt">int</span> a ;
} ;
<span class="co">// クラスにも基本クラスにも非staticデータメンバーがある</span>
<span class="kw">struct</span> C : B
{
    <span class="dt">int</span> b ;
} ;

<span class="co">// 匿名unionメンバーがある</span>
<span class="kw">struct</span> D
{
    <span class="kw">union</span>
    {
        <span class="dt">int</span> i ;
        <span class="dt">double</span> d ;
    }
} ;</code></pre></div>
<p>型<code>E</code>の非<code>static</code>データメンバーは宣言された順番で多値として認識される。</p>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">struct</span> { <span class="dt">int</span> x, y, z ; } e{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> [a,b,c] = e ;
}</code></pre></div>
<p>以下のコードと意味的に等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">struct</span> { <span class="dt">int</span> x, y, z ; } e{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> a = e.x ;
    <span class="dt">int</span> b = e.y ;
    <span class="dt">int</span> c = e.z ;
}</code></pre></div>
<p>構造化束縛はビットフィールドに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x : <span class="dv">2</span> ;
    <span class="dt">int</span> y : <span class="dv">4</span> ;
} ;

<span class="dt">int</span> main()
{
    S e{<span class="dv">1</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b] = e ;
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_structured_bindings</code>, 値は201606。</p>
<h2 id="inline変数">inline変数</h2>
<p>C++17では変数に<code>inline</code>キーワードを指定できるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">int</span> variable ;</code></pre></div>
<p>このような変数を<code>inline</code>変数と呼ぶ。その意味は<code>inline</code>関数と同じだ。</p>
<h3 id="inlineの歴史的な意味">inlineの歴史的な意味</h3>
<p>今は昔、本書執筆から30年以上は昔に、<code>inline</code>キーワードがC++に追加された。</p>
<p><code>inline</code>の現在の意味は誤解されている。</p>
<p><code>inline</code>関数の意味は、「関数を強制的にインライン展開させるための機能」<strong>ではない</strong>。</p>
<p>大事なことなのでもう一度書くが、<code>inline</code>関数の意味は、「関数を強制的にインライン展開させるための機能」<strong>ではない</strong>。</p>
<p>確かに、かつて<code>inline</code>関数の意味は、関数を強制的にインライン展開させるための機能だった。</p>
<p>関数のインライン展開とは、たとえば以下のようなコードがあったとき、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> min( <span class="dt">int</span> a, <span class="dt">int</span> b )
{ <span class="cf">return</span> a &lt; b ? a : b ; }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;
    <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b ;

    <span class="co">// aとbのうち小さい方を選ぶ</span>
    <span class="dt">int</span> value = min( a, b ) ;
}</code></pre></div>
<p>この関数<code>min</code>は十分に小さく、関数呼び出しのコストは無視できないオーバーヘッドになるため、以下のような最適化が考えられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;
    <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b ;

    <span class="dt">int</span> value = a &lt; b ? a : b ;
}</code></pre></div>
<p>このように関数の中身を展開することを、関数のインライン展開という。</p>
<p>人間が関数のインライン展開を手で行うのは面倒だ。それにコードが読みにくい。&quot;<code>min(a,b)</code>&quot;と&quot;<code>a&lt;b?a:b</code>&quot;のどちらが読みやすいだろうか。</p>
<p>幸い、C++コンパイラーはインライン展開を自動的に行えるので人間が苦労する必要はない。</p>
<p>インライン展開は万能の最適化ではない。インライン展開をすると逆に遅くなる場合もある。</p>
<p>たとえば、ある関数をコンパイルした結果のコードサイズが1Kバイトあったとして、その関数を呼んでいる箇所がプログラム中に1000件ある場合、プログラム全体のサイズは1Mバイト増える。コードサイズが増えるということは、CPUのキャッシュを圧迫する。</p>
<p>たとえば、ある関数の実行時間が関数呼び出しの実行時間に比べて桁違いに長いとき、関数呼び出しのコストを削減するのは意味がない。</p>
<p>したがって関数のインライン展開という最適化を適用すべきかどうかを決定するには、関数のコードサイズが十分に小さいとき、関数の実行時間が十分に短いとき、タイトなループの中など、さまざまな条件を考慮しなければならない。</p>
<p>昔のコンパイラー技術が未熟だった時代のC++コンパイラーは関数をインライン展開するべきかどうかの判断ができなかった。そのため<code>inline</code>キーワードが追加された。インライン展開してほしい関数を<code>inline</code>関数にすることで、コンパイラーはその関数がインライン展開するべき関数だと認識する。</p>
<h3 id="現代のinlineの意味">現代のinlineの意味</h3>
<p>現代では、コンパイラー技術の発展によりC++コンパイラーは十分に賢くなったので、関数をインライン展開させる目的で<code>inline</code>キーワードを使う必要はない。実際、現代のC++コンパイラーでは<code>inline</code>キーワードはインライン展開を強制しない。関数をインライン展開すべきかどうかはコンパイラーが判断できる。</p>
<p><code>inline</code>キーワードにはインライン展開以外に、もう1つの意味がある。ODR（One Definition Rule、定義は1つの原則）の回避だ。</p>
<p>C++では、定義はプログラム中に1つしか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() ; <span class="co">// OK、宣言</span>
<span class="dt">void</span> f() ; <span class="co">// OK、再宣言</span>

<span class="dt">void</span> f() { } <span class="co">// OK、定義</span>

<span class="dt">void</span> f() { } <span class="co">// エラー、再定義</span></code></pre></div>
<p>通常は、関数を使う場合には宣言だけを書いて使う。定義はどこか1つの翻訳単位に書いておけばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// f.h</span>

<span class="dt">void</span> f() ;

<span class="co">// f.cpp</span>

<span class="dt">void</span> f() { }

<span class="co">// main.cpp</span>

<span class="pp">#include </span><span class="im">&quot;f.h&quot;</span>

<span class="dt">int</span> main()
{
    f() ;
}</code></pre></div>
<p>しかし、関数のインライン展開をするには、コンパイラーの実装上の都合で、関数の定義が同じ翻訳単位になければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> f() ;

<span class="dt">int</span> main()
{
    <span class="co">// エラー、定義がない</span>
    f() ; 
}</code></pre></div>
<p>しかし、翻訳単位ごとに定義すると、定義が重複してODRに違反する。</p>
<p>C++ではこの問題を解決するために、<code>inline</code>関数は定義が同一であれば、複数の翻訳単位で定義されてもよいことにしている。つまりODRに違反しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a.cpp</span>

<span class="kw">inline</span> <span class="dt">void</span> f() { }

<span class="dt">void</span> a()
{
    f() ;
}

<span class="co">// b.cpp</span>

<span class="co">// OK、inline関数</span>
<span class="kw">inline</span> <span class="dt">void</span> f() { }

<span class="dt">void</span> b()
{
    f() ;
}</code></pre></div>
<p>これは例のために同一の<code>inline</code>関数を直接記述しているが、<code>inline</code>関数は定義を同一性を保証させるため、通常はヘッダーファイルに書いて<code>#include</code>して使う。</p>
<h3 id="inline変数の意味">inline変数の意味</h3>
<p><code>inline</code>変数は、ODRに違反せず変数の定義の重複を認める。同じ名前の<code>inline</code>変数は同じ変数を指す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">void</span> a() { ++data ; }

<span class="co">// b.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">void</span> b() { ++data ; }

<span class="co">// main.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">int</span> main()
{
    a() ;
    b() ;

    data ; <span class="co">// 2</span>
}</code></pre></div>
<p>この例で関数<code>a</code>, <code>b</code>の中の変数<code>data</code>は同じ変数を指している。変数<code>data</code>は<code>static</code>ストレージ上に構築された変数なのでプログラムの開始時にゼロで初期化される。2回インクリメントされるので値は2となる。</p>
<p>これにより、クラスの非<code>static</code>データメンバーの定義を書かなくてすむようになる。</p>
<p>C++17以前のC++では、以下のように書かなければならなかったが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>

<span class="kw">struct</span> S
{
    <span class="at">static</span> <span class="dt">int</span> data ;
} ;

<span class="co">// S.cpp</span>

<span class="dt">int</span> S::data ;</code></pre></div>
<p>C++17では、以下のように書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>

<span class="kw">struct</span> S
{
    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> data ;
} ;</code></pre></div>
<p><code>S.cpp</code>に変数<code>S::data</code>の定義を書く必要はない。</p>
<p>機能テストマクロは<code>__cpp_inline_variables</code>, 値は201606。</p>
<h2 id="可変長using宣言">可変長using宣言</h2>
<p>この機能は超上級者向けだ。</p>
<p>C++17では<code>using</code>宣言をコンマで区切ることができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x, y ;

<span class="dt">int</span> main()
{
    <span class="kw">using</span> ::x, ::y ;
}</code></pre></div>
<p>これは、C++14で</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> ::x ;
<span class="kw">using</span> ::y ;</code></pre></div>
<p>と書くのと等しい。</p>
<p>C++17では、<code>using</code>宣言でパック展開ができるようになった。この機能に正式な名前は付いていないが、可変長<code>using</code>宣言（Variadic using declaration）と呼ぶのがわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">struct</span> S : Types ...
{
    <span class="kw">using</span> Types::<span class="kw">operator</span>() ... ;
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">long</span> ) { }
} ;


<span class="kw">struct</span> A
{
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">int</span> ) { }
} ;

<span class="kw">struct</span> B
{
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">double</span> ) { }
} ;

<span class="dt">int</span> main()
{
    S&lt;A, B&gt; s ;
    s(<span class="dv">0</span>) ; <span class="co">// A::operator()</span>
    s(<span class="dv">0L</span>) ; <span class="co">// S::operator()</span>
    s(<span class="fl">0.0</span>) ; <span class="co">// B::operator()</span>
}</code></pre></div>
<p>機能テストマクロは<code>__cpp_variadic_using</code>, 値は201611。</p>
<h2 id="std.byte">std::byte : バイトを表現する型</h2>
<p>C++17では、バイトを表現する型が入った。ライブラリでもあるのだがコア言語で特別な型として扱われている。</p>
<p>バイトとはC++のメモリーモデルにおけるストレージの単位で、C++においてユニークなアドレスが付与される最小単位だ。C++の規格はいまだに1バイトが具体的に何ビットであるのかを規定していない。これは過去にバイトのサイズが8ビットではないアーキテクチャーが存在したためだ。</p>
<p>バイトのビット数は<code>&lt;climits&gt;</code>で定義されているプリプロセッサーマクロ、<code>CHAR_BIT</code>で知ることができる。</p>
<p>C++17では、1バイトはUTF-8の8ビットの1コード単位をすべて表現できると規定している。</p>
<p><code>std::byte</code>型は、生のバイト列を表すための型として使うことができる。生の1バイトを表すには<code>unsigned char</code>型が慣習的に使われてきたが、<code>std::byte</code>型は生の1バイトを表現する型として、新たにC++17で追加された。複数バイトが連続するストレージは、<code>unsigned char</code>の配列型、もしくは<code>std::byte</code>の配列型として表現できる。</p>
<p><code>std::byte</code>型は、<code>&lt;cstddef&gt;</code>で以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std
{
    <span class="kw">enum</span> <span class="kw">class</span> byte : <span class="dt">unsigned</span> <span class="dt">char</span> { } ;
}</code></pre></div>
<p><code>std::byte</code>はライブラリとして<code>scoped enum</code>型で定義されている。これにより、他の整数型からの暗黙の型変換が行えない。</p>
<p>値<code>0x12</code>の<code>std::byte</code>型の変数は以下のように定義できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{<span class="bn">0x12</span>} ;
}</code></pre></div>
<p><code>std::byte</code>型の値がほしい場合は、以下のように書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{} ;

    b = <span class="bu">std::</span>byte( <span class="dv">1</span> ) ;
    b = <span class="bu">std::</span>byte{ <span class="dv">1</span> } ;
    b = <span class="kw">static_cast</span>&lt; <span class="bu">std::</span>byte &gt;( <span class="dv">1</span> ) ;
    b = <span class="kw">static_cast</span>&lt; <span class="bu">std::</span>byte &gt;( <span class="bn">0b11110000</span> ) ;
}</code></pre></div>
<p><code>std::byte</code>型は他の数値型からは暗黙に型変換できない。これによりうっかりと型を取り違えてバイト型と他の型を演算してしまうことを防ぐことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、()による初期化はint型からの暗黙の変換が入る</span>
    <span class="bu">std::</span>byte b1(<span class="dv">1</span>) ;

    <span class="co">// エラー、=による初期化はint型からの暗黙の変換が入る</span>
    <span class="bu">std::</span>byte b2 = <span class="dv">1</span> ;

    <span class="bu">std::</span>byte b{} ;

    <span class="co">// エラー、operator =によるint型の代入は暗黙の変換が入る</span>
    b = <span class="dv">1</span> ;
    <span class="co">// エラー、operator =によるdouble型の代入は暗黙の変換が入る</span>
    b = <span class="fl">1.0</span> ;
}</code></pre></div>
<p><code>std::byte</code>型は<code>{}</code>によって初期化するが、縮小変換を禁止するルールにより、<code>std::byte</code>型が表現できる値の範囲でなければエラーとなる。</p>
<p>たとえば、今<code>std::byte</code>が8ビットで、最小値が0、最大値が255の環境だとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、表現できる値の範囲ではない</span>
    <span class="bu">std::</span>byte b1{<span class="dv">-1</span>} ;
    <span class="co">// エラー、表現できる値の範囲ではない</span>
    <span class="bu">std::</span>byte b2{<span class="dv">256</span>} ;
}</code></pre></div>
<p><code>std::byte</code>は内部のストレージをバイト単位でアクセスできるようにするため、規格上<code>char</code>と同じような配慮が行われている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">42</span> ;

    <span class="bu">std::</span>byte * rep = <span class="kw">reinterpret_cast</span>&lt; <span class="bu">std::</span>byte * &gt;(&amp;x) ;
}</code></pre></div>
<p><code>std::byte</code>は一部の演算子がオーバーロードされているので、通常の整数型のように使うことができる。ただし、バイトをビット列演算するのに使う一部の演算子だけだ。</p>
<p>具体的には、以下に示すシフト、ビットOR, ビット列AND, ビット列XOR, ビット列NOTだ。</p>
<pre><code>&lt;&lt;= &lt;&lt; 
&gt;&gt;= &gt;&gt;
|=  |
&amp;=  &amp;
^=  ^
~</code></pre>
<p>四則演算などの演算子はサポートしていない。</p>
<p><code>std::byteはstd::to_intenger&lt;IntType&gt;(std::byte)</code>により、<code>IntType</code>型の整数型に変換できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{<span class="dv">42</span>} ;

    <span class="co">// int型の値は42</span>
    <span class="kw">auto</span> i = <span class="bu">std::</span>to_integer&lt;<span class="dt">int</span>&gt;(b) ;
}</code></pre></div>
<h1 id="c17の型安全な値を格納するライブラリ">C++17の型安全な値を格納するライブラリ</h1>
<p>C++17では型安全に値を格納するライブラリとして、<code>variant</code>, <code>any</code>, <code>optional</code>が追加された。</p>
<h2 id="variant-型安全なunion">variant : 型安全なunion</h2>
<h3 id="使い方">使い方</h3>
<p>ヘッダーファイル<code>&lt;variant&gt;</code>で定義されている<code>variant</code>は、型安全な<code>union</code>として使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;variant&gt;</span>

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// int, double, std::stringのいずれかを格納するvariant</span>
    <span class="co">// コンストラクターは最初の型をデフォルト構築</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; x ;

    x = <span class="dv">0</span> ;         <span class="co">// intを代入</span>
    x = <span class="fl">0.0</span> ;       <span class="co">// doubleを代入</span>
    x = <span class="st">&quot;hello&quot;</span>s ;  <span class="co">// std::stringを代入</span>

    <span class="co">// intが入っているか確認</span>
    <span class="co">// falseを返す</span>
    <span class="dt">bool</span> has_int = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">int</span>&gt;( x ) ;
    <span class="co">// std::stringが入っているか確認</span>
    <span class="co">// trueを返す</span>
    <span class="dt">bool</span> has_string = <span class="bu">std::</span>holds_alternative&lt;<span class="bu">std::</span>string&gt; ( x ) ;

    <span class="co">// 入っている値を得る</span>
    <span class="co">// &quot;hello&quot;</span>
    <span class="bu">std::</span>string str = <span class="bu">std::</span>get&lt;<span class="bu">std::</span>string&gt;(x) ;
}</code></pre></div>
<h3 id="型非安全な古典的union">型非安全な古典的union</h3>
<p>C++が従来から持っている古典的な<code>union</code>は、複数の型のいずれか1つだけの値を格納する型だ。<code>union</code>のサイズはデータメンバーのいずれかの型を1つ表現できるだけのサイズとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">union</span> U
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;
} ;

<span class="kw">struct</span> S
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;
}</code></pre></div>
<p>この場合、<code>sizeof(U)</code>は</p>
<p><span class="math display">\[\texttt{sizeof(U)} = \max \{ \texttt{sizeof(int)}, \texttt{sizeof(double)}, \texttt{sizeof(std::string)} \} + \texttt{パディングなど}\]</span></p>
<p>になる。<code>sizeof(S)</code>は、</p>
<p><span class="math display">\[\texttt{sizeof(S)} = \texttt{sizeof(int)} + \texttt{sizeof(double)} + \texttt{sizeof(std::string)} + \texttt{パディングなど}\]</span></p>
<p>になる。</p>
<p><code>union</code>はメモリー効率がよい。<code>union</code>は<code>variant</code>と違い型非安全だ。どの型の値を保持しているかという情報は保持しないので、ユーザーが適切に管理しなければならない。</p>
<p>試しに、冒頭のコードを<code>union</code>で書くと、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">union</span> U
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;

    <span class="co">// コンストラクター</span>
    <span class="co">// int型をデフォルト初期化する</span>
    U() : i{} { }
    <span class="co">// デストラクター</span>
    <span class="co">// 何もしない。オブジェクトの破棄はユーザーの責任に任せる</span>
    ~U() { }
} ;

<span class="co">// デストラクター呼び出し</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> destruct ( T &amp; x )
{
    x.~T() ;
}

<span class="dt">int</span> main()
{
    U u ;

    <span class="co">// 基本型はそのまま代入できる</span>
    <span class="co">// 破棄も考えなくてよい</span>
    u.i = <span class="dv">0</span> ;
    u.d = <span class="fl">0.0</span> ;

    <span class="co">// 非トリビアルなコンストラクターを持つ型</span>
    <span class="co">// placement newが必要</span>
    <span class="kw">new</span>(&amp;u.s) <span class="bu">std::</span>string(<span class="st">&quot;hello&quot;</span>) ;

    <span class="co">// ユーザーはどの型を入れたか別に管理しておく必要がある</span>
    <span class="dt">bool</span> has_int = <span class="kw">false</span> ;
    <span class="dt">bool</span> has_string = <span class="kw">true</span> ;

    <span class="bu">std::</span>cout &lt;&lt; u.s &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

    <span class="co">// 非トリビアルなデストラクターを持つ型</span>
    <span class="co">// 破棄が必要</span>
    destruct( u.s ) ;
}</code></pre></div>
<p>このようなコードは書きたくない。<code>variant</code>を使えば、このような面倒で冗長なコードを書かずに、型安全に<code>union</code>と同等機能を実現できる。</p>
<h3 id="variantの宣言">variantの宣言</h3>
<p><code>variant</code>はテンプレート実引数で保持したい型を与える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>, <span class="dt">long</span> &gt; v1 ;
<span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v2 ;
<span class="bu">std::</span>variant&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;, <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; &gt; v3 ;</code></pre></div>
<h3 id="variantの初期化">variantの初期化</h3>
<h4 id="デフォルト初期化">デフォルト初期化</h4>
<p><code>variant</code>はデフォルト構築すると、最初に与えた型の値をデフォルト構築して保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v1 ;
<span class="co">// double</span>
<span class="bu">std::</span>variant&lt; <span class="dt">double</span>, <span class="dt">int</span> &gt; v2 ;</code></pre></div>
<p><code>variant</code>にデフォルト構築できない型を最初に与えると、<code>variant</code>もデフォルト構築できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// デフォルト構築できない型</span>
<span class="kw">struct</span> non_default_constructible
{
    non_default_constructible() = <span class="kw">delete</span> ;
} ;

<span class="co">// エラー</span>
<span class="co">// デフォルト構築できない</span>
<span class="bu">std::</span>variant&lt; non_default_constructible &gt; v ;</code></pre></div>
<p>デフォルト構築できない型だけを保持する<code>variant</code>をデフォルト構築するためには、最初の型をデフォルト構築可能な型にすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A { A() = <span class="kw">delete</span> ; } ;
<span class="kw">struct</span> B { B() = <span class="kw">delete</span> ; } ;
<span class="kw">struct</span> C { C() = <span class="kw">delete</span> ; } ;

<span class="kw">struct</span> Empty { } ;


<span class="dt">int</span> main()
{
    <span class="co">// OK、Emptyを保持</span>
    <span class="bu">std::</span>variant&lt; Empty, A, B, C &gt; v ;
}</code></pre></div>
<p>このような場合に、<code>Empty</code>のようなクラスをわざわざ独自に定義するのは面倒なので、標準ライブラリには<code>std::monostate</code>クラスが以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">struct</span> monostate { } ;
}</code></pre></div>
<p>したがって、上の例は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK、std::monostateを保持</span>
<span class="bu">std::</span>variant&lt; <span class="bu">std::</span>monostate, A, B, C &gt; v ;</code></pre></div>
<p><code>std::monostate</code>は<code>variant</code>の最初のテンプレート実引数として使うことで<code>variant</code>をデフォルト構築可能にするための型だ。それ以上の意味はない。</p>
<h4 id="コピー初期化">コピー初期化</h4>
<p><code>variant</code>に同じ型の<code>variant</code>を渡すと、コピー/ムーブする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// コピー</span>
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; b ( a ) ;
}</code></pre></div>
<h4 id="variantのコンストラクターに値を渡した場合">variantのコンストラクターに値を渡した場合</h4>
<p><code>variant</code>のコンストラクターに上記以外の値を渡した場合、<code>variant</code>のテンプレート実引数に指定した型の中から、オーバーロード解決により最適な型が選ばれ、その型の値に変換され、値を保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> val = <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; ;

<span class="dt">int</span> main()
{
    <span class="co">// int</span>
    val a(<span class="dv">42</span>) ;
    <span class="co">// double</span>
    val b( <span class="fl">0.0</span> ) ; 

    <span class="co">// std::string</span>
    <span class="co">// char const *型はstd::string型に変換される</span>
    val c(<span class="st">&quot;hello&quot;</span>) ;

    <span class="co">// int</span>
    <span class="co">// char型はIntegral promotionによりint型に優先的に変換される</span>
    val d( <span class="st">&#39;a&#39;</span> ) ;
}</code></pre></div>
<h4 id="in_place_typeによるemplace構築">in_place_typeによるemplace構築</h4>
<p><code>variant</code>のコンストラクターの第一引数に<code>std::in_place_type&lt;T&gt;</code>を渡すことにより、<code>T</code>型の要素を構築するために<code>T</code>型のコンストラクターに渡す実引数を指定できる。</p>
<p>ほとんどの型はコピーかムーブができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xを構築</span>
    X x( a, b, c ) ;
    <span class="co">// xをコピー</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( x ) ;
}</code></pre></div>
<p>しかし、もし型<code>X</code>がコピーもムーブもできない型だったとしたら、上記のコードは動かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xを構築</span>
    X x( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// エラー、Xはコピーできない</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( x ) ;
}</code></pre></div>
<p>このような場合、<code>variant</code>が内部で<code>X</code>を構築する際に、構築に必要なコンストラクターの実引数を渡して、<code>variant</code>に<code>X</code>を構築させる必要がある。そのために<code>std::in_place_type&lt;T&gt;</code>が使える。<code>T</code>に構築したい型を指定して第一引数とし、第二引数以降を<code>T</code>のコンストラクターに渡す値にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xの値を構築して保持</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
}</code></pre></div>
<h3 id="variantの破棄">variantの破棄</h3>
<p><code>variant</code>のデストラクターは、そのときに保持している値を適切に破棄してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; l ;
    <span class="bu">std::</span>deque&lt;<span class="dt">int</span>&gt; d ;
    <span class="bu">std::</span>variant&lt; 
        <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;, 
        <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt;,
        <span class="bu">std::</span>deque&lt;<span class="dt">int</span>&gt;
    &gt; val ;

    val = v ;
    val = l ;
    val = d ;

    <span class="co">// variantのデストラクターはdeque&lt;int&gt;を破棄する</span>
}</code></pre></div>
<p><code>variant</code>のユーザーは何もする必要がない。</p>
<h3 id="variantの代入">variantの代入</h3>
<p><code>variant</code>の代入はとても自然だ。<code>variant</code>を渡せばコピーするし、値を渡せばオーバーロード解決に従って適切な型の値を保持する。</p>
<h3 id="variantのemplace">variantのemplace</h3>
<p><code>variant</code>は<code>emplace</code>をサポートしている。<code>variant</code>の場合、構築すべき型を知らせる必要があるので、<code>emplace&lt;T&gt;</code>の<code>T</code>で構築すべき型を指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="bu">std::</span>monostate, X, <span class="bu">std::</span>string&gt; v ;

    <span class="co">// Xを構築</span>
    v.emplace&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// std::stringを構築</span>
    v.emplace&lt; <span class="bu">std::</span>string &gt;( <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<h3 id="variantに値が入っているかどうかの確認">variantに値が入っているかどうかの確認</h3>
<h4 id="valueless_by_exceptionメンバー関数">valueless_by_exceptionメンバー関数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">bool</span> valueless_by_exception() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p><code>valueless_by_exception</code>メンバー関数は、<code>variant</code>が値を保持している場合、<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; &amp; v )
{

    <span class="cf">if</span> ( v.valueless_by_exception() ) 
    { <span class="co">// true</span>
        <span class="co">// vは値を保持していない</span>
    }
    <span class="cf">else</span>
    { <span class="co">// false</span>
        <span class="co">// vは値を保持している</span>
    }
}</code></pre></div>
<p><code>variant</code>はどの値も保持しない状態になることがある。たとえば、<code>std::string</code>はコピーにあたって動的なメモリー確保を行うかもしれない。<code>variant</code>が<code>std::string</code>をコピーする際に、動的メモリー確保に失敗した場合、コピーは失敗する。なぜならば、<code>variant</code>は別の型の値を構築する前に、以前の値を破棄しなければならないからだ。<code>variant</code>は値を持たない状態になりうる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="bu">std::</span>string &gt; v ;
    <span class="cf">try</span> {
        <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;
        v = s ; <span class="co">// 動的メモリー確保が発生するかもしれない</span>
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_alloc e )
    {
        <span class="co">// 動的メモリー確保が失敗するかもしれない</span>
    }

    <span class="co">// 動的メモリー確保の失敗により</span>
    <span class="co">// trueになるかもしれない</span>
    <span class="dt">bool</span> b = v.valueless_by_exception() ;
}</code></pre></div>
<h4 id="indexメンバー関数">indexメンバー関数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> index() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p><code>index</code>メンバー関数は、<code>variant</code>に指定したテンプレート実引数のうち、現在<code>variant</code>が保持している値の型を0ベースのインデックスで返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v ;

    <span class="kw">auto</span> v0 = v.index() ; <span class="co">// 0</span>
    v = <span class="fl">0.0</span> ;
    <span class="kw">auto</span> v1 = v.index() ; <span class="co">// 1</span>
    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="kw">auto</span> v2 = v.index() ; <span class="co">// 2</span>
}</code></pre></div>
<p>もし<code>variant</code>が値を保持しない場合、つまり<code>valueless_by_exception()</code>が<code>true</code>を返す場合は、<code>std::variant_npos</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// variantが値を持っているかどうか確認する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types  &gt;
<span class="dt">void</span> has_value( <span class="bu">std::</span>variant&lt; Types ... &gt; &amp;&amp; v )
{
    <span class="cf">return</span> v.index() != <span class="bu">std::</span>variant_npos ;

    <span class="co">// これでもいい</span>
    <span class="co">// return v.valueless_by_exception() == false ;</span>
}</code></pre></div>
<p><code>std::variant_npos</code>の値は<span class="math inline">\(-1\)</span>だ。</p>
<h3 id="swap">swap</h3>
<p><code>variant</code>は<code>swap</code>に対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a, b ;

    a.swap(b) ;
    <span class="bu">std::</span>swap( a, b ) ;
}</code></pre></div>
<h3 id="variant_sizet-variantが保持できる型の数を取得">variant_size&lt;T&gt; : variantが保持できる型の数を取得</h3>
<p><code>std::variant_size&lt;T&gt;</code>は、<code>T</code>に<code>variant</code>型を渡すと、<code>variant</code>が保持できる型の数を返してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> t1 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>&gt; ;
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>&gt; ;
<span class="kw">using</span> t3 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="co">// 1</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t1_size = <span class="bu">std::</span>variant_size&lt;t1&gt;::size ;
<span class="co">// 2</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t2_size = <span class="bu">std::</span>variant_size&lt;t2&gt;::size ;
<span class="co">// 3</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t2_size = <span class="bu">std::</span>variant_size&lt;t3&gt;::size ;</code></pre></div>
<p><code>variant_sizeはintegral_constant</code>を基本クラスに持つクラスなので、デフォルト構築した結果をユーザー定義変換することでも値を取り出せる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="kw">constexpr</span> <span class="bu">std::</span>size_t size = <span class="bu">std::</span>variant_size&lt;type&gt;{} ;</code></pre></div>
<p><code>variant_size</code>を以下のようにラップした変数テンプレートも用意されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> variant_size_v = variant_size&lt;T&gt;::value;</code></pre></div>
<p>これを使えば、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="kw">constexpr</span> <span class="bu">std::</span>size_t size = <span class="bu">std::</span>variant_size_v&lt;type&gt; ;</code></pre></div>
<h3 id="variant_alternativei-t-インデックスから型を返す">variant_alternative&lt;I, T&gt; : インデックスから型を返す</h3>
<p><code>std::variant_alternative&lt;I, T&gt;</code>は<code>T</code>型の<code>variant</code>の保持できる型のうち、<code>I</code>番目の型をネストされた型名<code>type</code>で返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span> &gt; ;

<span class="co">// char</span>
<span class="kw">using</span> t0 = <span class="bu">std::</span>variant_alternative&lt; <span class="dv">0</span>, type &gt;::type ;
<span class="co">// short</span>
<span class="kw">using</span> t1 = <span class="bu">std::</span>variant_alternative&lt; <span class="dv">1</span>, type &gt;::type ;
<span class="co">// int</span>
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant_alternative&lt; <span class="dv">2</span>, type &gt;::type ;</code></pre></div>
<p><code>variant_alternative_t</code>というテンプレートエイリアスが以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="kw">class</span> T&gt;
    <span class="kw">using</span> <span class="dt">variant_alternative_t</span> 
        = <span class="kw">typename</span> variant_alternative&lt;I, T&gt;::type ;</code></pre></div>
<p>これを使えば、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span> &gt; ;

<span class="co">// char</span>
<span class="kw">using</span> t0 = <span class="bu">std::</span>variant_alternative_t&lt; <span class="dv">0</span>, type &gt; ;
<span class="co">// short</span>
<span class="kw">using</span> t1 = <span class="bu">std::</span>variant_alternative_t&lt; <span class="dv">1</span>, type &gt; ;
<span class="co">// int</span>
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant_alternative_t&lt; <span class="dv">2</span>, type &gt; ;</code></pre></div>
<h3 id="holds_alternative-variantが指定した型の値を保持しているかどうかの確認">holds_alternative : variantが指定した型の値を保持しているかどうかの確認</h3>
<p><code>holds_alternative&lt;T&gt;(v)</code>は、<code>variant v</code>が<code>T</code>型の値を保持しているかどうかを確認する。保持しているのであれば<code>true</code>を、そうでなければ<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を構築</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v ;

    <span class="co">// true</span>
    <span class="dt">bool</span> has_int = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">int</span>&gt;(v) ;
    <span class="co">// false</span>
    <span class="dt">bool</span> has_double = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">double</span>&gt;(v) ;
}</code></pre></div>
<p>型<code>T</code>は実引数に与えられた<code>variant</code>が保持できる型でなければならない。以下のようなコードはエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; v ;

    <span class="co">// エラー</span>
    <span class="bu">std::</span>holds_alternative&lt;<span class="dt">double</span>&gt;(v) ;
}</code></pre></div>
<h3 id="getiv-インデックスから値の取得">get&lt;I&gt;(v) : インデックスから値の取得</h3>
<p><code>get&lt;I&gt;(v)</code>は、<code>variant v</code>の型のインデックスから<code>I</code>番目の型の値を返す。インデックスは0ベースだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 0: int</span>
    <span class="co">// 1: double</span>
    <span class="co">// 2: std::string</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v(<span class="dv">42</span>) ;

    <span class="co">// int, 42</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(v) ;

    v = <span class="fl">3.14</span> ;
    <span class="co">// double, 3.14</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(v) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string, &quot;hello&quot;</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(v) ;
}</code></pre></div>
<p><code>I</code>がインデックスの範囲を超えているとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// インデックスは0, 1, 2まで</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v ;

    <span class="co">// エラー、範囲外</span>
    <span class="bu">std::</span>get&lt;<span class="dv">3</span>&gt;(v) ;
}</code></pre></div>
<p>もし、<code>variant</code>が値を保持していない場合、つまり<code>v.index() != I</code>の場合は、<code>std::bad_variant_access</code>が<code>throw</code>される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v( <span class="dv">42</span> ) ;

    <span class="cf">try</span> {
        <span class="co">// double型の値を要求</span>
        <span class="kw">auto</span> d = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(v) ;
    } <span class="cf">catch</span> ( <span class="bu">std::</span>bad_variant_access &amp; e )
    {
        <span class="co">// doubleは保持していなかった</span>
    }
}</code></pre></div>
<p><code>get</code>の実引数に渡す<code>variant</code>が<code>lvalue</code>の場合は、戻り値は<code>lvalue</code>リファレンス、<code>rvalue</code>の場合は戻り値は<code>rvalue</code>リファレンスになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; v ;

    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(v) ;
    <span class="co">// int &amp;&amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) b = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( <span class="bu">std::</span>move(v) ) ;
}</code></pre></div>
<p><code>get</code>の実引数に渡す<code>variant</code>がCV修飾されている場合、戻り値の型も実引数と同じくCV修飾される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">const</span> cv ;
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">volatile</span> vv ;
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">const</span> <span class="at">volatile</span> cvv ;

    <span class="co">// int const &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( cv ) ;
    <span class="co">// int volatile &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) b = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( vv ) ;
    <span class="co">// int const volatile &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) c = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( cvv ) ;
}</code></pre></div>
<h3 id="gettv-型から値の取得">get&lt;T&gt;(v) : 型から値の取得</h3>
<p><code>get&lt;T&gt;(v)</code>は、<code>variant v</code>の保有する型<code>T</code>の値を返す。型<code>T</code>の値を保持していない場合、<code>std::bad_variant_access</code>が<code>throw</code>される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// int</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get&lt;<span class="dt">int</span>&gt;( v ) ;

    v = <span class="fl">3.14</span> ;
    <span class="co">// double</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get&lt;<span class="dt">double</span>&gt;( v ) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get&lt;<span class="bu">std::</span>string&gt;( v ) ;
}</code></pre></div>
<p>その他はすべて<code>get&lt;I&gt;</code>と同じ。</p>
<h3 id="get_if-値を保持している場合に取得">get_if : 値を保持している場合に取得</h3>
<p><code>get_if&lt;I&gt;(vp)</code>と<code>get_if&lt;T&gt;(vp)</code>は、<code>variant</code>へのポインター<code>vp</code>を実引数に取り、<code>*vp</code>がインデックス<code>I</code>, もしくは型<code>T</code>の値を保持している場合、その値へのポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// int *</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">int</span>&gt;( &amp;v ) ; 

    v = <span class="fl">3.14</span> ;
    <span class="co">// double *</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get_if&lt;<span class="dv">1</span>&gt;( &amp;v ) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get_if&lt;<span class="dv">2</span>&gt;( &amp;v ) ;

}</code></pre></div>
<p>もし、<code>vp</code>が<code>nullptr</code>の場合、もしくは<code>*vp</code>が指定された値を保持していない場合は、<code>nullptr</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// nullptr</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">int</span>&gt;( <span class="kw">nullptr</span> ) ;

    <span class="co">// nullptr</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">double</span>&gt;( &amp;v ) ;
}</code></pre></div>
<h3 id="variantの比較">variantの比較</h3>
<p><code>variant</code>は比較演算子がオーバーロードされているため比較できる。<code>variant</code>同士の比較は、一般のプログラマーは自然だと思う結果になるように実装されている。</p>
<h4 id="同一性の比較">同一性の比較</h4>
<p><code>variant</code>の同一性の比較のためには、<code>variant</code>のテンプレート実引数に与える型は自分自身と比較可能でなければならない。</p>
<p>つまり、<code>variant v</code>, <code>w</code>に対して、式<code>get&lt;i&gt;(v) == get&lt;i&gt;(w)</code>がすべての<code>i</code>に対して妥当でなければならない。</p>
<p><code>variant v</code>, <code>w</code>の同一性の比較は、<code>v == w</code>の場合、以下のように行われる。</p>
<ol style="list-style-type: decimal">
<li><code>v.index() != w.index()</code>ならば、<code>false</code></li>
<li>それ以外の場合、<code>v.value_less_by_exception()</code>ならば、<code>true</code></li>
<li>それ以外の場合、<code>get&lt;i&gt;(v) == get&lt;i&gt;(w)</code>。ただし<code>i</code>は<code>v.index()</code></li>
</ol>
<p>2つの<code>variant</code>が別の型を保持している場合は等しくない。ともに値なしの状態であれば等しい。それ以外は保持している値同士が比較される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; a(<span class="dv">0</span>), b(<span class="dv">0</span>) ;

    <span class="co">// true</span>
    <span class="co">// 同じ型の同じ値を保持している</span>
    a == b ;

    a = <span class="fl">1.0</span> ;

    <span class="co">// false</span>
    <span class="co">// 型が違う</span>
    a == b ;
}</code></pre></div>
<p>たとえば<code>operator ==</code>は以下のような実装になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Types&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> 
<span class="kw">operator</span> == (<span class="at">const</span> variant&lt;Types...&gt;&amp; v, <span class="at">const</span> variant&lt;Types...&gt;&amp; w)
{
    <span class="cf">if</span> ( v.index() != w.index() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>visit( 
            []( <span class="kw">auto</span> &amp;&amp; a, <span class="kw">auto</span> &amp;&amp; b ){ <span class="cf">return</span> a == b ; },
            v, w ) ;
}</code></pre></div>
<p><code>operator !=</code>はこの逆だと考えてよい。</p>
<h4 id="大小比較">大小比較</h4>
<p><code>variant</code>の大小の比較のためには、<code>variant</code>のテンプレート実引数に与える型は自分自身と比較可能でなければならない。</p>
<p>つまり、<code>operator &lt;</code>の場合、<code>variant v</code>, <code>w</code>に対して、式<code>get&lt;i&gt;(v) &lt; get&lt;i&gt;(w)</code>がすべての<code>i</code>に対して妥当でなければならない。</p>
<p><code>variant v</code>, <code>w</code>の大小比較は、<code>v &lt; w</code>の場合、以下のように行われる。</p>
<ol style="list-style-type: decimal">
<li><code>w.valueless_by_exception()</code>ならば、<code>false</code></li>
<li>それ以外の場合、<code>v.valueless_by_exception()</code>ならば、<code>true</code></li>
<li>それ以外の場合、<code>v.index() &lt; w.index()</code>ならば、<code>true</code></li>
<li>それ以外の場合、<code>v.index() &gt; w.index()</code>ならば、<code>false</code></li>
<li>それ以外の場合、<code>get&lt;i&gt;(v) &lt; get&lt;i&gt;(w)</code>。ただし<code>i</code>は<code>v.index()</code></li>
</ol>
<p>値なしの<code>variant</code>は最も小さいとみなされる。インデックスの小さいほうが小さいとみなされる。どちらも同じ型の値があるのであれば、値同士の比較となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; a(<span class="dv">0</span>), b(<span class="dv">0</span>) ;

    <span class="co">// false</span>
    <span class="co">// 同じ型の同じ値を比較</span>
    a &lt; b ;

    a = <span class="fl">1.0</span> ;

    <span class="co">// false</span>
    <span class="co">// インデックスによる比較</span>
    a &lt; b ;
    <span class="co">// true</span>
    <span class="co">// インデックスによる比較</span>
    b &lt; a ;
}</code></pre></div>
<p><code>operator &lt;</code>は以下のような実装になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Types&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> 
<span class="kw">operator</span>&lt;(<span class="at">const</span> variant&lt;Types...&gt;&amp; v, <span class="at">const</span> variant&lt;Types...&gt;&amp; w)
{
    <span class="cf">if</span> ( w.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.index() &lt; w.index() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.index() &gt; w.index() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>visit( 
            []( <span class="kw">auto</span> &amp;&amp; a, <span class="kw">auto</span> &amp;&amp; b ){ <span class="cf">return</span> a &lt; b ; },
            v, w ) ;
}</code></pre></div>
<p>残りの大小比較も同じ方法で比較される。</p>
<h3 id="visit-variantが保持している値を受け取る">visit : variantが保持している値を受け取る</h3>
<p><code>std::visit</code>は、<code>variant</code>の保持している型を実引数に関数オブジェクトを呼んでくれるライブラリだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> val = <span class="bu">std::</span>variant&lt;<span class="dt">int</span>, <span class="dt">double</span>&gt; ;

    val v(<span class="dv">42</span>) ;
    val w(<span class="fl">3.14</span>) ;

    <span class="kw">auto</span> visitor =  []( <span class="kw">auto</span> a, <span class="kw">auto</span> b ) 
                    { <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ; } ;

    <span class="co">// visitor( 42, 3.14 )が呼ばれる</span>
    <span class="bu">std::</span>visit( visitor, v, w ) ;
    <span class="co">// visitor( 3.14, 42 ) が呼ばれる</span>
    <span class="bu">std::</span>visit( visitor, w, v ) ;
}</code></pre></div>
<p>このように、<code>variant</code>にどの型の値が保持されていても扱うことができる。</p>
<p><code>std::visit</code>は以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">class</span> Visitor, <span class="kw">class</span>... Variants &gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> visit( Visitor&amp;&amp; vis, Variants&amp;&amp;... vars ) ;</code></pre></div>
<p>第一引数に関数オブジェクトを渡し、第二引数以降に<code>variant</code>を渡す。すると、<code>vis( get&lt;i&gt;(vars)... )</code>のように呼ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a(<span class="dv">1</span>), b(<span class="dv">2</span>), c(<span class="dv">3</span>) ;

    <span class="co">// ( 1 ) </span>
    <span class="bu">std::</span>visit( []( <span class="kw">auto</span> x ) {}, a ) ;

    <span class="co">// ( 1, 2, 3 )</span>
    <span class="bu">std::</span>visit( []( <span class="kw">auto</span> x, <span class="kw">auto</span> y, <span class="kw">auto</span> z ) {}, a, b, c ) ;
}</code></pre></div>
<h2 id="any-どんな型の値でも保持できるクラス">any : どんな型の値でも保持できるクラス</h2>
<h3 id="使い方-1">使い方</h3>
<p>ヘッダーファイル<code>&lt;any&gt;</code>で定義されている<code>std::any</code>は、ほとんどどんな型の値でも保持できるクラスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;any&gt;</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    a = <span class="dv">0</span> ; <span class="co">// int</span>
    a = <span class="fl">1.0</span> ; <span class="co">// double</span>
    a = <span class="st">&quot;hello&quot;</span> ; <span class="co">// char const *</span>

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    a = v ; <span class="co">// std::vector&lt;int&gt;</span>

    <span class="co">// 保持しているstd::vector&lt;int&gt;のコピー</span>
    <span class="kw">auto</span> value = <span class="bu">std::</span>any_cast&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &gt;( a ) ;
}</code></pre></div>
<p><code>any</code>が保持できない型は、コピー構築できない型だ。</p>
<h3 id="anyの構築と破棄">anyの構築と破棄</h3>
<p>クラス<code>any</code>はテンプレートではない。そのため宣言は単純だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>any a ;
    <span class="co">// int型の値を保持する</span>
    <span class="bu">std::</span>any b( <span class="dv">0</span> ) ;
    <span class="co">// double型の値を保持する</span>
    <span class="bu">std::</span>any c( <span class="fl">0.0</span> ) ;
}</code></pre></div>
<p><code>any</code>が保持する型を事前に指定する必要はない。</p>
<p>クラス<code>any</code>を破棄すると、そのとき保持していた値が適切に破棄される。</p>
<h3 id="in_place_typeコンストラクター">in_place_typeコンストラクター</h3>
<p><code>any</code>のコンストラクターで<code>emplace</code>をするために<code>in_place_type</code>が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// 型XをX(1, 2)で構築した結果の値を保持する</span>
    <span class="bu">std::</span>any a( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h3 id="anyへの代入">anyへの代入</h3>
<p><code>any</code>への代入も普通のプログラマーの期待どおりの動きをする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;
    <span class="bu">std::</span>any b ;

    <span class="co">// aはint型の値42を保持する</span>
    a = <span class="dv">42</span> ;
    <span class="co">// bはint型の値42を保持する</span>
    b = a ;
    
}</code></pre></div>
<h3 id="anyのメンバー関数">anyのメンバー関数</h3>
<h4 id="emplace">emplace</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span>... Args&gt;
<span class="dt">decay_t</span>&lt;T&gt;&amp; emplace(Args&amp;&amp;... args);</code></pre></div>
<p><code>any</code>は<code>emplace</code>メンバー関数をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// 型XをX(1, 2)で構築した結果の値を保持する</span>
    a.emplace&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h4 id="reset-値の破棄">reset : 値の破棄</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reset() <span class="kw">noexcept</span> ; </code></pre></div>
<p><code>any</code>の<code>reset</code>メンバー関数は、<code>any</code>の保持してある値を破棄する。<code>reset</code>を呼び出した後の<code>any</code>は値を保持しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// aは値を保持しない</span>
    <span class="bu">std::</span>any a ;
    <span class="co">// aはint型の値を保持する</span>
    a = <span class="dv">0</span> ;

    <span class="co">// aは値を保持しない</span>
    a.reset() ;
}</code></pre></div>
<h4 id="swap-スワップ">swap : スワップ</h4>
<p><code>any</code>は<code>swap</code>メンバー関数をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">0</span>) ;
    <span class="bu">std::</span>any b(<span class="fl">0.0</span>) ;

    <span class="co">// aはint型の値を保持</span>
    <span class="co">// bはdouble型の値を保持</span>

    a.swap(b) ;

    <span class="co">// aはdouble型の値を保持</span>
    <span class="co">// bはint型の値を保持</span>
}</code></pre></div>
<h4 id="has_value-値を保持しているかどうか調べる">has_value : 値を保持しているかどうか調べる</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> has_value() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p><code>any</code>の<code>has_value</code>メンバー関数は<code>any</code>が値を保持しているかどうかを調べる。値を保持しているならば<code>true</code>を、保持していないならば<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    a = <span class="dv">0</span> ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = a.has_value() ;

    a.reset() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b3 = a.has_value() ;
}</code></pre></div>
<h4 id="type-保持している型のtype_infoを得る">type : 保持している型のtype_infoを得る</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> type_info&amp; type() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p><code>type</code>メンバー関数は、保持している型<code>T</code>の<code>typeid(T)</code>を返す。値を保持していない場合、<code>typeid(void)</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// typeid(void)</span>
    <span class="kw">auto</span> &amp; t1 = a.type() ;

    a = <span class="dv">0</span> ;
    <span class="co">// typeid(int)</span>
    <span class="kw">auto</span> &amp; t2 = a.type() ;

    a = <span class="fl">0.0</span> ;
    <span class="co">// typeid(double)</span>
    <span class="kw">auto</span> &amp; t3 = a.type() ;
}</code></pre></div>
<h3 id="anyのフリー関数">anyのフリー関数</h3>
<h4 id="make_anyt-t型のanyを作る">make_any&lt;T&gt; : T型のanyを作る</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span>... Args&gt;
any make_any(Args&amp;&amp; ...args);

<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U, <span class="kw">class</span>... Args&gt;
any make_any(initializer_list&lt;U&gt; il, Args&amp;&amp; ...args);</code></pre></div>
<p><code>make_any&lt;T&gt;( args... )</code>は<code>T</code>型をコンストラクター実引数<code>args...</code>で構築した値を保持する<code>any</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持するany</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>make_any&lt;<span class="dt">int</span>&gt;( <span class="dv">0</span> ) ;
    <span class="co">// double型の値を保持するany</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>make_any&lt;<span class="dt">double</span>&gt;( <span class="fl">0.0</span> ) ;

    <span class="co">// X型の値を保持するany</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>make_any&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h4 id="any_cast-保持している値の取り出し">any_cast : 保持している値の取り出し</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(<span class="at">const</span> any&amp; operand);
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(any&amp; operand);
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(any&amp;&amp; operand);</code></pre></div>
<p><code>any_cast&lt;T&gt;(operand)</code>は<code>operand</code>が保持している値を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">0</span>) ;

    <span class="dt">int</span> value = <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;(a) ;
}</code></pre></div>
<p><code>any_cast&lt;T&gt;</code>で指定した<code>T</code>型が、<code>any</code>が保持している型ではない場合、<code>std::bad_any_cast</code>が<code>throw</code>される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">try</span> {
        <span class="bu">std::</span>any a ;
        <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;(a) ;
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_any_cast e )
    {
        <span class="co">// 型を保持していなかった</span>
    }

}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="at">const</span> T* any_cast(<span class="at">const</span> any* operand) <span class="kw">noexcept</span>;
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
T* any_cast(any* operand) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>any_cast&lt;T&gt;</code>に<code>any</code>へのポインターを渡すと、<code>T</code>へのポインター型が返される。<code>any</code>が<code>T</code>型を保持している場合は<code>T</code>型を参照するポインターが返る。保持していない場合は、<code>nullptr</code>が返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">42</span>) ;

    <span class="co">// int型の値を参照するポインター</span>
    <span class="dt">int</span> * p1 = <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;( &amp;a ) ;

    <span class="co">// nullptr</span>
    <span class="dt">double</span> * p2 = <span class="bu">std::</span>any_cast&lt;<span class="dt">double</span>&gt;( &amp;a ) ;
}</code></pre></div>
<h2 id="optional-値を保有しているかしていないクラス">optional : 値を保有しているか、していないクラス</h2>
<h3 id="使い方-2">使い方</h3>
<p>ヘッダーファイル<code>&lt;optional&gt;</code>で定義されている<code>optional&lt;T&gt;</code>は、<code>T</code>型の値を保有しているか、保有していないライブラリだ。</p>
<p>条件次第で値が用意できない場合が存在する。たとえば割り算の結果の値を返す関数を考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> divide( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
    <span class="cf">if</span> ( b == <span class="dv">0</span> )
    {
        <span class="co">// エラー処理</span>
    }
    <span class="cf">else</span>
        <span class="cf">return</span> a / b ;
}</code></pre></div>
<p>ゼロで除算はできないので、<code>b</code>の値が0の場合、この関数は値を用意することができない。問題は、<code>int</code>型のすべての値は通常の除算結果として使われるので、エラーであることを示す特別な値を返すこともできない。</p>
<p>このような場合にエラーや値を通知する方法として、過去にさまざまな方法が考案された。たとえば、ポインターやリファレンスを実引数として受け取る方法、グローバル変数を使う方法、例外だ。</p>
<p><code>optional</code>はこのような値が用意できない場合に使える共通の方法を提供する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; divide( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
    <span class="cf">if</span> ( b == <span class="dv">0</span> )
        <span class="cf">return</span> {} ;
    <span class="cf">else</span>
        <span class="cf">return</span> { a / b } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> result = divide( <span class="dv">10</span>, <span class="dv">2</span> ) ;
    <span class="co">// 値の取得</span>
    <span class="kw">auto</span> value = result.value() ;

    <span class="co">// ゼロ除算</span>
    <span class="kw">auto</span> fail = divide( <span class="dv">10</span>, <span class="dv">0</span> ) ;

    <span class="co">// false、値を保持していない</span>
    <span class="dt">bool</span> has_value = fail.has_value() ;

    <span class="co">// throw bad_optional_access</span>
    <span class="kw">auto</span> get_value_anyway = fail.value() ;
}</code></pre></div>
<h3 id="optionalのテンプレート実引数">optionalのテンプレート実引数</h3>
<p><code>optional&lt;T&gt;</code>は<code>T</code>型の値を保持するか、もしくは保持しない状態を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持するかしないoptional</span>
    <span class="kw">using</span> a = <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; ;
    <span class="co">// double型の値を保持するかしないoptional</span>
    <span class="kw">using</span> b = <span class="bu">std::</span>optional&lt;<span class="dt">double</span>&gt; ;
}</code></pre></div>
<h3 id="optionalの構築">optionalの構築</h3>
<p><code>optional</code>をデフォルト構築すると、値を保持しない<code>optional</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a ;
}</code></pre></div>
<p>コンストラクターの実引数に<code>std::nullopt</code>を渡すと、値を保持しない<code>optional</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="bu">std::</span>nullopt ) ;
}</code></pre></div>
<p><code>optional&lt;T&gt;</code>のコンストラクターの実引数に<code>T</code>型に変換できる型を渡すと、<code>T</code>型の値に型変換して保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">42</span>) ;

    <span class="co">// double型の値1.0を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">double</span>&gt; b( <span class="fl">1.0</span> ) ;

    <span class="co">// intからdoubleへの型変換が行われる</span>
    <span class="co">// int型の値1を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; c ( <span class="fl">1.0</span> ) ;
}</code></pre></div>
<p><code>T</code>型から<code>U</code>型に型変換できるとき、<code>optional&lt;T&gt;</code>のコンストラクターに<code>optional&lt;U&gt;</code>を渡すと<code>U</code>から<code>T</code>に型変換されて<code>T</code>型の値を保持する<code>optional</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// long型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">long</span>&gt; b ( a ) ;
}</code></pre></div>
<p><code>optional</code>のコンストラクターの第一引数に<code>std::in_place_type&lt;T&gt;</code>を渡すと、後続の引数を使って<code>T</code>型のオブジェクトが<code>emplace</code>構築される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// X(1, 2)</span>
    <span class="bu">std::</span>optional&lt;X&gt; o( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h3 id="optionalの代入">optionalの代入</h3>
<p>通常のプログラマーの期待どおりの挙動をする。<code>std::nullopt</code>を代入すると値を保持しない<code>optional</code>になる。</p>
<h3 id="optionalの破棄">optionalの破棄</h3>
<p><code>optional</code>が破棄されるとき、保持している値があれば、適切に破棄される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X() { }
} ;

<span class="dt">int</span> main()
{
    {
        <span class="co">// 値を保持する</span>
        <span class="bu">std::</span>optional&lt;X&gt; o ( X{} ) ;
        <span class="co">// Xのデストラクターが呼ばれる</span>
    }

    {
        <span class="co">// 値を保持しない</span>
        <span class="bu">std::</span>optional&lt;X&gt; o ;
        <span class="co">// Xのデストラクターは呼ばれない</span>
    }   
}</code></pre></div>
<h3 id="swap-1">swap</h3>
<p><code>optional</code>は<code>swap</code>に対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">1</span>), b(<span class="dv">2</span>) ;

    a.swap(b) ;
}</code></pre></div>
<h3 id="has_value-値を保持しているかどうか確認する">has_value : 値を保持しているかどうか確認する</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">bool</span> has_value() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p><code>has_value</code>メンバー関数は<code>optional</code>が値を保持している場合、<code>true</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b(<span class="dv">42</span>) ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = b.has_value() ;
}</code></pre></div>
<h3 id="operator-bool-値を保持しているかどうか確認する">operator bool : 値を保持しているかどうか確認する</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p><code>optional</code>を文脈上<code>bool</code>に変換すると、値を保持している場合にのみ<code>true</code>として評価される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">bool</span>&gt; a = some_function();
    <span class="co">// OK、文脈上boolに変換</span>
    <span class="cf">if</span> ( a )
    {
        <span class="co">// 値を保持</span>
    }
    <span class="cf">else</span>
    {
        <span class="co">// 値を不保持</span>
    }

    <span class="co">// エラー、暗黙の型変換は行われない</span>
    <span class="dt">bool</span> b1 = a ;
    <span class="co">// OK、明示的な型変換</span>
    <span class="dt">bool</span> b2 = <span class="kw">static_cast</span>&lt;<span class="dt">bool</span>&gt;(a) ;
}</code></pre></div>
<h3 id="value-保持している値を取得">value : 保持している値を取得</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="at">const</span> T&amp; value() <span class="at">const</span>&amp;;
<span class="kw">constexpr</span> T&amp; value() &amp;;
<span class="kw">constexpr</span> T&amp;&amp; value() &amp;&amp;;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;&amp; value() <span class="at">const</span>&amp;&amp;;</code></pre></div>
<p><code>value</code>メンバー関数は<code>optional</code>が値を保持している場合、値へのリファレンスを返す。値を保持していない場合、<code>std::bad_optional_access</code>が<code>throw</code>される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">42</span>) ;

    <span class="co">// OK</span>
    <span class="dt">int</span> x = a.value () ;

    <span class="cf">try</span> {
        <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b ;
        <span class="dt">int</span> y = b.value() ;
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_optional_access e )
    {
        <span class="co">// 値を保持していなかった</span>
    }
}</code></pre></div>
<h3 id="value_or-値もしくはデフォルト値を返す">value_or : 値もしくはデフォルト値を返す</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> T value_or(U&amp;&amp; v) <span class="at">const</span>&amp;;
<span class="kw">template</span> &lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> T value_or(U&amp;&amp; v) &amp;&amp;;</code></pre></div>
<p><code>value_or(v)</code>メンバー関数は、<code>optional</code>が値を保持している場合はその値を、保持していない場合は<code>v</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// 42</span>
    <span class="dt">int</span> x = a.value_or(<span class="dv">0</span>) ;

    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b ;

    <span class="co">// 0</span>
    <span class="dt">int</span> x = b.value_or(<span class="dv">0</span>) ;
}</code></pre></div>
<h3 id="reset-保持している値を破棄する">reset : 保持している値を破棄する</h3>
<p><code>reset</code>メンバー関数を呼び出すと、保持している値がある場合破棄する。<code>reset</code>メンバー関数を呼び出した後の<code>optional</code>は値を保持しない状態になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    a.reset() ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = a.has_value() ;
}</code></pre></div>
<h3 id="optional同士の比較">optional同士の比較</h3>
<p><code>optional&lt;T&gt;</code>を比較するためには、<code>T</code>型のオブジェクト同士が比較できる必要がある。</p>
<h4 id="同一性の比較-1">同一性の比較</h4>
<p>値を保持しない2つの<code>optional</code>は等しい。片方のみが値を保持している<code>optional</code>は等しくない。両方とも値を保持している<code>optional</code>は値による比較になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a, b ;

    <span class="co">// true</span>
    <span class="co">// どちらも値を保持しないoptional</span>
    <span class="dt">bool</span> b1 = a == b ;

    a = <span class="dv">0</span> ;

    <span class="co">// false</span>
    <span class="co">// aのみ値を保持</span>
    <span class="dt">bool</span> b2 = a == b ;

    b = <span class="dv">1</span> ;

    <span class="co">// false</span>
    <span class="co">// どちらも値を保持。値による比較</span>
    <span class="dt">bool</span> b3 = a == b ;
}</code></pre></div>
<h4 id="大小比較-1">大小比較</h4>
<p><code>optional</code>同士の大小比較は、<code>a &lt; b</code>の場合</p>
<ol style="list-style-type: decimal">
<li><code>b</code>が値を保持していなければ<code>false</code></li>
<li>それ以外の場合で、<code>a</code>が値を保持していなければ<code>true</code></li>
<li>それ以外の場合、<code>a</code>と<code>b</code>の保持している値同士の比較</li>
</ol>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a, b ;

    <span class="co">// false</span>
    <span class="co">// bが値なし</span>
    <span class="dt">bool</span> b1 = a &lt; b ;

    b = <span class="dv">0</span> ;

    <span class="co">// true</span>
    <span class="co">// bは値ありでaが値なし</span>
    <span class="dt">bool</span> b2 = a &lt; b ;

    a = <span class="dv">1</span> ;

    <span class="co">// false</span>
    <span class="co">// どちらとも値があるので値同士の比較</span>
    <span class="co">// 1 &lt; 0はfalse</span>
    <span class="dt">bool</span> b3 = a &lt; b ;
}</code></pre></div>
<h3 id="optionalとstdnulloptとの比較">optionalとstd::nulloptとの比較</h3>
<p><code>optional</code>と<code>std::nullopt</code>との比較は、<code>std::nullopt</code>が値を持っていない<code>optional</code>として扱われる。</p>
<h3 id="optionaltとtの比較">optional&lt;T&gt;とTの比較</h3>
<p><code>optional&lt;T&gt;</code>と<code>T</code>型の比較では、<code>optional&lt;t&gt;</code>が値を保持していない場合<code>false</code>が返る。それ以外の場合、<code>optional</code>の保持している値と<code>T</code>が比較される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; o(<span class="dv">1</span>) ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = ( o == <span class="dv">1</span> ) ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = ( o == <span class="dv">0</span> ) ;

    <span class="co">// oは値を保持しない</span>
    o.reset() ;

    <span class="co">// Tの値にかかわらずfalse</span>
    <span class="co">// false</span>
    <span class="dt">bool</span> b3 = ( o == <span class="dv">1</span> ) ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b4 = ( o == <span class="dv">0</span> ) ;
}</code></pre></div>
<h3 id="make_optionalt-optionaltを返す">make_optional&lt;T&gt; : optional&lt;T&gt;を返す</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> optional&lt;<span class="dt">decay_t</span>&lt;T&gt;&gt; make_optional(T&amp;&amp; v);</code></pre></div>
<p><code>make_optional&lt;T&gt;(T t)</code>は<code>optional&lt;T&gt;(t)</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::optional&lt;int&gt;、値は0</span>
    <span class="kw">auto</span> o1 = <span class="bu">std::</span>make_optional( <span class="dv">0</span> ) ;

    <span class="co">// std::optional&lt;double&gt;、値は0.0</span>
    <span class="kw">auto</span> o2 = <span class="bu">std::</span>make_optional( <span class="fl">0.0</span> ) ;
}</code></pre></div>
<h3 id="make_optionalt-args-...-optionaltをin_place_type構築して返す">make_optional&lt;T, Args ... &gt; : optional&lt;T&gt;をin_place_type構築して返す</h3>
<p><code>make_optional</code>の第一引数が<code>T</code>型ではない場合、<code>in_place_type</code>構築するオーバーロード関数が選ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// std::optional&lt;X&gt;( std::in_place_type&lt;X&gt;, 1, 2 )</span>
    <span class="kw">auto</span> o = <span class="bu">std::</span>make_optional&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h1 id="string_view-文字列ラッパー">string_view : 文字列ラッパー</h1>
<p><code>string_view</code>は、文字型（<code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code>）の連続した配列で表現された文字列に対する共通の文字列ビューを提供する。文字列は所有しない。</p>
<h2 id="使い方-3">使い方</h2>
<p>連続した文字型の配列を使った文字列の表現方法にはさまざまある。C++では最も基本的な文字列の表現方法として、<code>null</code>終端された文字型の配列がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> str[<span class="dv">6</span>] = { <span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;</span><span class="sc">\0</span><span class="st">&#39;</span> } ;</code></pre></div>
<p>あるいは、文字型の配列と文字数で表現することもある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sizeは文字数</span>
<span class="bu">std::</span>size_t size
<span class="dt">char</span> * ptr ;</code></pre></div>
<p>このような表現をいちいち管理するのは面倒なので、クラスで包むこともある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> <span class="dt">string_type</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> *ptr
} ;</code></pre></div>
<p>このように文字列を表現する方法はさまざまある。これらのすべてに対応していると、表現の数だけ関数のオーバーロードが追加されていくことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// null終端文字列用</span>
<span class="dt">void</span> process_string( <span class="dt">char</span> * ptr ) ;
<span class="co">// 配列へのポインターと文字数</span>
<span class="dt">void</span> process_string( <span class="dt">char</span> * ptr, <span class="bu">std::</span>size_t size ) ;
<span class="co">// std::stringクラス</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string s ) ;
<span class="co">// 自作のstring_typeクラス</span>
<span class="dt">void</span> process_string( <span class="dt">string_type</span> s ) ;
<span class="co">// 自作のmy_string_typeクラス</span>
<span class="dt">void</span> process_string( <span class="dt">my_string_type</span> s ) ;</code></pre></div>
<p><code>string_view</code>はさまざまな表現の文字列に対して共通の<code>view</code>を提供することで、この問題を解決できる。もう関数のオーバーロードを大量に追加する必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 自作のstring_type</span>
<span class="kw">struct</span> <span class="dt">string_type</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;

    <span class="co">// string_viewに対応する変換関数</span>
    <span class="kw">operator</span> <span class="bu">std::</span>string_view() <span class="at">const</span> <span class="kw">noexcept</span>
    {
        <span class="cf">return</span> <span class="bu">std::</span>string_view( ptr, size ) ;
    }
}

<span class="co">// これ1つだけでよい</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string_view s ) ;

<span class="dt">int</span> main()
{
    <span class="co">// OK</span>
    process_string( <span class="st">&quot;hello&quot;</span> ) ;
    <span class="co">// OK</span>
    process_string( { <span class="st">&quot;hello&quot;</span>, <span class="dv">5</span> } ) ;

    <span class="bu">std::</span>string str( <span class="st">&quot;hello&quot;</span> ) ;
    process_string( str ) ;

    <span class="dt">string_type</span> st{<span class="dv">5</span>, <span class="st">&quot;hello&quot;</span>} ;

    process_string( st ) ;
}</code></pre></div>
<h2 id="basic_string_view">basic_string_view</h2>
<p><code>std::stringがstd::basic_string&lt; CharT, Traits &gt;</code>に対する<code>std::basic_string&lt;char&gt;</code>であるように、<code>std::string_view</code>も、その実態は<code>std::basic_string_view</code>の特殊化への<code>typedef</code>名だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 本体</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> charT, <span class="kw">class</span> traits = char_traits&lt;charT&gt;&gt;
<span class="kw">class</span> basic_string_view ;

<span class="co">// それぞれの文字型のtypedef名</span>
<span class="kw">using</span> string_view = basic_string_view&lt;<span class="dt">char</span>&gt;;
<span class="kw">using</span> u16string_view = basic_string_view&lt;<span class="dt">char16_t</span>&gt;;
<span class="kw">using</span> u32string_view = basic_string_view&lt;<span class="dt">char32_t</span>&gt;;
<span class="kw">using</span> wstring_view = basic_string_view&lt;<span class="dt">wchar_t</span>&gt;;</code></pre></div>
<p>なので、通常は<code>basic_string_view</code>ではなく、<code>string_view</code>とか<code>u16string_view</code>などの<code>typedef</code>名を使うことになる。本書では<code>string_view</code>だけを解説するが、その他の<code>typedef</code>名も文字型が違うだけで同じだ。</p>
<h2 id="文字列の所有非所有">文字列の所有、非所有</h2>
<p><code>string_view</code>は文字列を所有しない。所有というのは、文字列を表現するストレージの確保と破棄に責任を持つということだ。所有しないことの意味を説明するために、まず文字列を所有するライブラリについて説明する。</p>
<p><code>std::string</code>は文字列を所有する。<code>std::string</code>風のクラスの実装は、たとえば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;

<span class="kw">public</span> :
    <span class="co">// 文字列を表現するストレージの動的確保</span>
    string ( <span class="dt">char</span> <span class="at">const</span> * str )
    {
        size = <span class="bu">std::</span>strlen( str ) ;
        ptr = <span class="kw">new</span> <span class="dt">char</span>[size<span class="dv">+1</span>] ;
        <span class="bu">std::</span>strcpy( ptr, str ) ;
    }

    <span class="co">// コピー</span>
    <span class="co">// 別のストレージを動的確保</span>
    string ( string <span class="at">const</span> &amp; r )
        : size( r.size ), ptr ( <span class="kw">new</span> <span class="dt">char</span>[size<span class="dv">+1</span>] )
    {
        <span class="bu">std::</span>strcpy( ptr, r.ptr ) ;
    }

    <span class="co">// ムーブ</span>
    <span class="co">// 所有権の移動</span>
    string ( string &amp;&amp; r )
        : size( r.size ), ptr( r.ptr )
    {
        r.size = <span class="dv">0</span> ;
        r.ptr = <span class="kw">nullptr</span> ;
    }

    <span class="co">// 破棄</span>
    <span class="co">// 動的確保したストレージを解放</span>
    ~string()
    {
        <span class="kw">delete</span>[] ptr ;
    }
    
} ;</code></pre></div>
<p><code>std::string</code>は文字列を表現するストレージを動的に確保し、所有する。コピーは別のストレージを確保する。ムーブするときはストレージの所有権を移す。デストラクターは所有しているストレージを破棄する。</p>
<p><code>std::string_view</code>は文字列を所有しない。<code>std::string_view</code>風のクラスの実装は、たとえば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> strin<span class="va">g_view</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> <span class="at">const</span> * ptr ;

<span class="kw">public</span> :

    <span class="co">// 所有しない</span>
    <span class="co">// strの参照先の寿命は呼び出し側が責任を持つ</span>
    string_view( <span class="dt">char</span> <span class="at">const</span> * str ) <span class="kw">noexcept</span>
        : size( <span class="bu">std::</span>strlen(str) ), ptr( str )
    { }

    <span class="co">// コピー</span>
    <span class="co">// メンバーごとのコピーだけでよいのでdefault化するだけでよい</span>
    string_view( string_view <span class="at">const</span> &amp; r ) <span class="kw">noexcept</span> = <span class="cf">default</span> ;

    <span class="co">// ムーブはコピーと同じ</span>
    <span class="co">// 所有しないので所有権の移動もない</span>

    <span class="co">// 破棄</span>
    <span class="co">// 何も解放するストレージはない</span>
    <span class="co">// デストラクターもトリビアルでよい</span>
} ;</code></pre></div>
<p><code>string_view</code>に渡した連続した文字型の配列へのポインターの寿命は、渡した側が責任を持つ。つまり、以下のようなコードは間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>string_view get_string()
{
    <span class="dt">char</span> str[] = <span class="st">&quot;hello&quot;</span> ;

    <span class="co">// エラー</span>
    <span class="co">// strの寿命は関数の呼び出し元に戻った時点で尽きている</span>
    <span class="cf">return</span> str ;
}</code></pre></div>
<h2 id="string_viewの構築">string_viewの構築</h2>
<p><code>string_view</code>の構築には4種類ある。</p>
<ul>
<li>デフォルト構築</li>
<li><code>null</code>終端された文字型の配列へのポインター</li>
<li>文字型の配列へのポインターと文字数</li>
<li>文字列クラスからの変換関数</li>
</ul>
<h3 id="デフォルト構築">デフォルト構築</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view() <span class="kw">noexcept</span>;</code></pre></div>
<p><code>string_view</code>のデフォルト構築は、空の<code>string_view</code>を作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 空のstring_view</span>
    <span class="bu">std::</span>string_view s ;
}</code></pre></div>
<h3 id="null終端された文字型の配列へのポインター">null終端された文字型の配列へのポインター</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view(<span class="at">const</span> charT* str);</code></pre></div>
<p>この<code>string_view</code>のコンストラクターは、<code>null</code>終端された文字型へのポインターを受け取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string_view s( <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<h3 id="文字型へのポインターと文字数">文字型へのポインターと文字数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view(<span class="at">const</span> charT* str, <span class="dt">size_type</span> len);</code></pre></div>
<p>この<code>string_view</code>のコンストラクターは、文字型の配列へのポインターと文字数を受け取る。ポインターは<code>null</code>終端されていなくてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">char</span> str[] = {<span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>} ;

    <span class="bu">std::</span>string_view s( str, <span class="dv">5</span> ) ;
}</code></pre></div>
<h2 id="文字列クラスからの変換関数">文字列クラスからの変換関数</h2>
<p>他の文字列クラスから<code>string_view</code>を作るには、変換関数を使う。<code>string_view</code>のコンストラクターは使わない。</p>
<p><code>std::string</code>は<code>string_view</code>への変換関数をサポートしている。独自の文字列クラスを<code>string_view</code>に対応させるにも変換関数を使う。たとえば以下のように実装する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;
<span class="kw">public</span> :
    <span class="kw">operator</span> <span class="bu">std::</span>string_view() <span class="at">const</span> <span class="kw">noexcept</span>
    {
        <span class="cf">return</span> <span class="bu">std::</span>string_view( ptr, size ) ;
    }
} ;</code></pre></div>
<p>これにより、<code>std::string</code>から<code>string_view</code>への変換が可能になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;
    <span class="bu">std::</span>string_view sv = s ;
}</code></pre></div>
<p>コレと同じ方法を使えば、独自の文字列クラスも<code>string_view</code>に対応させることができる。</p>
<p><code>std::string</code>は<code>string_view</code>を受け取るコンストラクターを持っているので、<code>string_view</code>から<code>string</code>への変換もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string_view sv = <span class="st">&quot;hello&quot;</span> ;

    <span class="co">// コピーされる</span>
    <span class="bu">std::</span>string s = sv ;
}</code></pre></div>
<h2 id="string_viewの操作">string_viewの操作</h2>
<p><code>string_view</code>は既存の標準ライブラリの<code>string</code>とほぼ同じ操作性を提供している。たとえばイテレーターを取ることができるし、<code>operator []</code>で要素にアクセスできるし、<code>size()</code>で要素数が返るし、<code>find()</code>で検索もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T  t )
{
    <span class="cf">for</span> ( <span class="kw">auto</span> c : t )
    {
        <span class="bu">std::</span>cout &lt;&lt; c ;
    }

    <span class="cf">if</span> ( t.size() &gt; <span class="dv">3</span> )
    {
        <span class="kw">auto</span> c = t[<span class="dv">3</span>] ;
    }

    <span class="kw">auto</span> pos = t.find( <span class="st">&quot;fox&quot;</span> ) ;
}

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s(<span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>) ;

    f( s ) ;

    <span class="bu">std::</span>string_view sv = s ;

    f( sv ) ;
}</code></pre></div>
<p><code>string_view</code>は文字列を所有しないので、文字列を書き換える方法を提供していない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;

    s[<span class="dv">0</span>] = <span class="st">&#39;H&#39;</span> ;
    s += <span class="st">&quot;,world&quot;</span> ;

    <span class="bu">std::</span>string_view sv = s ;

    <span class="co">// エラー</span>
    <span class="co">// string_viewは書き換えられない</span>
    sv[<span class="dv">0</span>] = <span class="st">&#39;h&#39;</span> ;
    s += <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
}</code></pre></div>
<p><code>string_view</code>は文字列を所有せず、ただ参照しているだけだからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;
    <span class="bu">std::</span>string_view sv = s ;

    <span class="co">// &quot;hello&quot;</span>
    <span class="bu">std::</span>cout &lt;&lt; sv ;

    s = <span class="st">&quot;world&quot;</span> ;

    <span class="co">// &quot;world&quot;</span>
    <span class="co">// string_viewは参照しているだけ</span>
    <span class="bu">std::</span>cout &lt;&lt; sv ;
}</code></pre></div>
<p><code>string_view</code>は<code>string</code>とほぼ互換性のあるメンバーを持っているが、一部の文字列を変更するメンバーは削除されている。</p>
<h3 id="remove_prefixremove_suffix-先頭末尾の要素の削除">remove_prefix/remove_suffix : 先頭、末尾の要素の削除</h3>
<p><code>string_view</code>は先頭と末尾から<code>n</code>個の要素を削除するメンバー関数を提供している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">void</span> remove_prefix(<span class="dt">size_type</span> n);
<span class="kw">constexpr</span> <span class="dt">void</span> remove_suffix(<span class="dt">size_type</span> n);</code></pre></div>
<p><code>string_view</code>にとって、先頭と末尾から<code>n</code>個の要素を削除するのは、ポインターを<code>n</code>個ずらすだけなので、これは文字列を所有しない<code>string_view</code>でも行える操作だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;

    <span class="bu">std::</span>string_view s1 = s ;

    <span class="co">// &quot;lo&quot;</span>
    s1.remove_prefix(<span class="dv">3</span>) ;

    <span class="bu">std::</span>string_view s2 = s ;

    <span class="co">// &quot;he&quot;</span>
    s2.remove_suffix(<span class="dv">3</span>) ;
}</code></pre></div>
<p>このメンバー関数は既存の<code>std::string</code>にも追加されている。</p>
<h2 id="ユーザー定義リテラル">ユーザー定義リテラル</h2>
<p><code>std::string</code>と<code>std::string_view</code>にはユーザー定義リテラルが追加されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char</span>* str, <span class="dt">size_t</span> len);
u16string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char16_t</span>* str, <span class="dt">size_t</span> len);
u32string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char32_t</span>* str, <span class="dt">size_t</span> len);
wstring operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">wchar_t</span>* str, <span class="dt">size_t</span> len);

<span class="kw">constexpr</span> strin<span class="va">g_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;

<span class="kw">constexpr</span> u<span class="er">16string_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char16_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;

<span class="kw">constexpr</span> u<span class="er">32string_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char32_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;

<span class="kw">constexpr</span> wstrin<span class="va">g_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">wchar_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;</code></pre></div>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// std::string</span>
    <span class="kw">auto</span> s = <span class="st">&quot;hello&quot;</span>s ;

    <span class="co">// std::string_view</span>
    <span class="kw">auto</span> sv = <span class="st">&quot;hello&quot;</span>sv ;
}</code></pre></div>
<h1 id="メモリーリソース-動的ストレージ確保ライブラリ">メモリーリソース : 動的ストレージ確保ライブラリ</h1>
<p>ヘッダーファイル<code>&lt;memory_resource&gt;</code>で定義されているメモリーリソースは、動的ストレージを確保するためのC++17で追加されたライブラリだ。その特徴は以下のとおり。</p>
<ul>
<li>アロケーターに変わる新しいインターフェースとしてのメモリーリソース</li>
<li>ポリモーフィックな振る舞いを可能にするアロケーター</li>
<li>標準で提供されるさまざまな特性を持ったメモリーリソースの実装</li>
</ul>
<h2 id="メモリーリソース">メモリーリソース</h2>
<p>メモリーリソースはアロケーターに変わる新しいメモリー確保と解放のためのインターフェースとしての抽象クラスだ。コンパイル時に挙動を変える静的ポリモーフィズム設計のアロケーターと違い、メモリーリソースは実行時に挙動を変える動的ポリモーフィズム設計となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( memory_resource * mem )
{
    <span class="co">// 10バイトのストレージを確保</span>
    <span class="kw">auto</span> ptr = mem-&gt;allocate( <span class="dv">10</span> ) ;
    <span class="co">// 確保したストレージを解放</span>
    mem-&gt;deallocate( ptr ) ;
}</code></pre></div>
<p>クラス<code>std::pmr::memory_resource</code>の宣言は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> memory_resource {
<span class="kw">public</span>:
    <span class="kw">virtual</span> ~ memory_resource();
    <span class="dt">void</span>* allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment = max_align);
    <span class="dt">void</span> deallocate(<span class="dt">void</span>* p, <span class="dt">size_t</span> bytes,
                    <span class="dt">size_t</span> alignment = max_align);
    <span class="dt">bool</span> is_equal(<span class="at">const</span> memory_resource&amp; other) <span class="at">const</span> <span class="kw">noexcept</span>;

<span class="kw">private</span>:
    <span class="kw">virtual</span> <span class="dt">void</span>* do_allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate( <span class="dt">void</span>* p, <span class="dt">size_t</span> bytes,
                                <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal(<span class="at">const</span> memory_resource&amp; other)
        <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;
};

}</code></pre></div>
<p>クラス<code>memory_resource</code>は<code>std::pmr</code>名前空間スコープの中にある。</p>
<h3 id="メモリーリソースの使い方">メモリーリソースの使い方</h3>
<p><code>memory_resource</code>を使うのは簡単だ。<code>memory_resource</code>のオブジェクトを確保したら、メンバー関数<code>allocate( bytes, alignment )</code>でストレージを確保する。メンバー関数<code>deallocate( p, bytes, alignment )</code>でストレージを解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * mem )
{
    <span class="co">// 100バイトのストレージを確保</span>
    <span class="dt">void</span> * ptr = mem-&gt;allocate( <span class="dv">100</span> ) ;
    <span class="co">// ストレージを解放</span>
    mem-&gt;deallocate( ptr, <span class="dv">100</span> ) ;
}</code></pre></div>
<p>2つの<code>memory_resource</code>のオブジェクト<code>a</code>, <code>b</code>があるとき、一方のオブジェクトで確保したストレージをもう一方のオブジェクトで解放できるとき、<code>a.is_equal( b )</code>は<code>true</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * a, <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resouce * b )
{
    <span class="dt">void</span> * ptr = a-&gt;allocate( <span class="dv">1</span> ) ;

    <span class="co">// aで確保したストレージはbで解放できるか？</span>
    <span class="cf">if</span> ( a-&gt;is_equal( *b ) )
    {<span class="co">// できる</span>
        b-&gt;deallocate( ptr, <span class="dv">1</span> ) ;
    }
    <span class="cf">else</span>
    {<span class="co">// できない</span>
        a-&gt;deallocate( ptr, <span class="dv">1</span> ) ;
    }
}</code></pre></div>
<p><code>is_equal</code>を呼び出す<code>operator ==</code>と<code>operator !=</code>も提供されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * a, <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * b )
{
    <span class="dt">bool</span> b1 = ( *a == *b ) ;
    <span class="dt">bool</span> b2 = ( *a != *b ) ;
}</code></pre></div>
<h3 id="メモリーリソースの作り方">メモリーリソースの作り方</h3>
<p>独自のメモリーアロケーターを<code>memory_resouce</code>のインターフェースに合わせて作るには、<code>memory_resource</code>から派生した上で、<code>do_allocate</code>, <code>do_deallocate</code>, <code>do_is_equal</code>の3つの<code>private</code>純粋<code>virtual</code>メンバー関数をオーバーライドする。必要に応じてデストラクターもオーバーライドする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> memory_resource {
    <span class="co">// 非公開</span>
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> max_align = <span class="kw">alignof</span>(<span class="dt">max_align_t</span>);

<span class="kw">public</span>:
    <span class="kw">virtual</span> ~ memory_resource();

<span class="kw">private</span>:
    <span class="kw">virtual</span> <span class="dt">void</span>* do_allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate( <span class="dt">void</span>* p, <span class="dt">size_t</span> bytes,
                                <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal(<span class="at">const</span> memory_resource&amp; other)
        <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;
};</code></pre></div>
<p><code>do_allocate(bytes, alignment)</code>は少なくとも<code>alignment</code>バイトでアライメントされた<code>bytes</code>バイトのストレージへのポインターを返す。ストレージが確保できなかった場合は、適切な例外を<code>throw</code>する。</p>
<p><code>do_deallocate(p, bytes, alignment)</code>は事前に同じ<code>*this</code>から呼び出された<code>allocate( bytes, alignment )</code>で返されたポインター<code>p</code>を解放する。すでに解放されたポインター<code>p</code>を渡してはならない。例外は投げない。</p>
<p><code>do_is_equal(other)</code>は、<code>*thisとother</code>が互いに一方で確保したストレージをもう一方で解放できる場合に<code>true</code>を返す。</p>
<p>たとえば、<code>malloc</code>/<code>free</code>を使った<code>memory_resouce</code>の実装は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// malloc/freeを使ったメモリーリソース</span>
<span class="kw">class</span> malloc_resource : <span class="kw">public</span> <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource
{
<span class="kw">public</span> :
    <span class="co">//</span>
    ~malloc_resource() { }
<span class="kw">private</span> :
    <span class="co">// ストレージの確保</span>
    <span class="co">// 失敗した場合std::bad_allocをthrowする</span>
    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc( bytes ) ;
        <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )
        { <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc{} ; }

        <span class="cf">return</span> ptr ;
    }

    <span class="co">// ストレージの解放</span>
    <span class="kw">virtual</span> <span class="dt">void</span> 
    do_deallocate(  <span class="dt">void</span> * p, <span class="bu">std::</span>size_t bytes, 
                    <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>free( p ) ;
    }

    <span class="kw">virtual</span> <span class="dt">bool</span> 
    do_is_equal( <span class="at">const</span> memory_resource &amp; other )
        <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>
    {
        <span class="cf">return</span> <span class="kw">dynamic_cast</span>&lt; <span class="at">const</span> malloc_resource * &gt;
                    ( &amp;other ) != <span class="kw">nullptr</span> ;
    }

} ;</code></pre></div>
<p><code>do_allocate</code>は<code>malloc</code>でストレージを確保し、<code>do_deallocate</code>は<code>free</code>でストレージを解放する。メモリーリソースで0バイトのストレージを確保しようとしたときの規定はないので、<code>malloc</code>の挙動に任せる。<code>malloc</code>は0バイトのメモリーを確保しようとしたとき、C11では規定がない。POSIXでは<code>null</code>ポインターを返すか、<code>free</code>で解放可能な何らかのアドレスを返すものとしている。</p>
<p><code>do_is_equal</code>は、<code>malloc_resource</code>でさえあればどのオブジェクトから確保されたストレージであっても解放できるので、<code>*this</code>が<code>malloc_resource</code>であるかどうかを<code>dynamic_cast</code>で確認している。</p>
<h2 id="polymorphic_allocator-動的ポリモーフィズムを実現するアロケーター">polymorphic_allocator : 動的ポリモーフィズムを実現するアロケーター</h2>
<p><code>std::pmr::polymorphic_allocator</code>はメモリーリソースを動的ポリモーフィズムとして振る舞うアロケーターにするためのライブラリだ。</p>
<p>従来のアロケーターは、静的ポリモーフィズムを実現するために設計されていた。たとえば独自の<code>custom_int_allocator</code>型を使いたい場合は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>vector&lt; <span class="dt">int</span>, custom_int_allocator &gt; v ;</code></pre></div>
<p>コンパイル時に使うべきアロケーターが決定できる場合はこれでいいのだが、実行時にアロケーターを選択したい場合、アロケーターをテンプレート引数に取る設計は問題になる。</p>
<p>そのため、C++17ではメモリーリソースをコンストラクター引数に取り、メモリーリソースからストレージを確保する実行時ポリモーフィックの振る舞いをする<code>std::pmr::polymorphic_allocator</code>が追加された。</p>
<p>たとえば、標準入力から<code>true</code>か<code>false</code>が入力されたかによって、システムのデフォルトのメモリーリソースと、<code>monotonic_buffer_resource</code>を実行時に切り替えるには、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b;

    <span class="bu">std::</span>cin &gt;&gt; b ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>mempry_resource * mem ;
    <span class="bu">std::</span>unique_ptr&lt; memory_resource &gt; mono ;

    <span class="cf">if</span> ( b )
    { <span class="co">// デフォルトのメモリーリソースを使う</span>
        mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;
    }
    <span class="cf">else</span>
    { <span class="co">// モノトニックバッファーを使う</span>
        mono = <span class="bu">std::</span>make_unique&lt; <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource &gt;
                ( <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;
        mem = mono.get() ;
    }

    <span class="bu">std::</span>vector&lt; <span class="dt">int</span>, <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; &gt;
        v( <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt;( mem ) ) ;
}</code></pre></div>
<p><code>std::pmr::polymorphic_allocator</code>は以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">class</span> polymorphic_allocator ;

}</code></pre></div>
<p>テンプレート実引数には<code>std::allocator&lt;T&gt;</code>と同じく、確保する型を与える。</p>
<h3 id="コンストラクター">コンストラクター</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">polymorphic_allocator() <span class="kw">noexcept</span>;
polymorphic_allocator(memory_resource* r);</code></pre></div>
<p><code>std::pmr::polymorphic_allocator</code>のデフォルトコンストラクターは、メモリーリソースを<code>std::pmr::get_default_resource()</code>で取得する。</p>
<p><code>memory_resource *</code>を引数に取るコンストラクターは、渡されたメモリーリソースをストレージ確保に使う。<code>polymorphic_allocator</code>の生存期間中、メモリーリソースへのポインターは妥当なものでなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// p1( std::pmr::get_default_resource () ) と同じ</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; p1 ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; p2(
        <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;
}</code></pre></div>
<p>後は通常のアロケーターと同じように振る舞う。</p>
<h2 id="プログラム全体で使われるメモリーリソースの取得">プログラム全体で使われるメモリーリソースの取得</h2>
<p>C++17では、プログラム全体で使われるメモリーリソースへのポインターを取得することができる。</p>
<h3 id="new_delete_resource">new_delete_resource()</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* new_delete_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>関数<code>new_delete_resource</code>はメモリーリソースへのポインターを返す。参照されるメモリーリソースは、ストレージの確保に<code>::operator new</code>を使い、ストレージの解放に<code>::operator delete</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> mem = <span class="bu">std::</span>pmr<span class="bu">::</span>new_delete_resource() ;
}</code></pre></div>
<h3 id="null_memory_resource">null_memory_resource()</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* null_memory_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>関数<code>null_memory_resource</code>はメモリーリソースへのポインターを返す。参照されるメモリーリソースの<code>allocate</code>は必ず失敗し、<code>std::bad_alloc</code>を<code>throw</code>する。<code>deallocate</code>は何もしない。</p>
<p>このメモリーリソースは、ストレージの確保に失敗した場合のコードをテストする目的で使える。</p>
<h3 id="デフォルトリソース">デフォルトリソース</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* set_default_resource(memory_resource* r) <span class="kw">noexcept</span> ;
memory_resource* get_default_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>デフォルト・メモリーリソース・ポインターとは、メモリーリソースを明示的に指定することができない場合に、システムがデフォルトで利用するメモリーリソースへのポインターのことだ。初期値は<code>new_delete_resource()</code>の戻り値となっている。</p>
<p>現在のデフォルト・メモリーリソース・ポインターと取得するためには、関数<code>get_default_resource</code>を使う。デフォルト・メモリーリソース・ポインターを独自のメモリーリソースに差し替えるには、関数<code>set_default_resource</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 現在のデフォルトのメモリーリソースへのポインター</span>
    <span class="kw">auto</span> init_mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource pool_mem ;

    <span class="co">// デフォルトのメモリーリソースを変更する</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>set_default_resource( &amp;pool_mem ) ;

    <span class="kw">auto</span> current_mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b = current_mem == pool_mem ;
}</code></pre></div>
<h2 id="標準ライブラリのメモリーリソース">標準ライブラリのメモリーリソース</h2>
<p>標準ライブラリはメモリーリソースの実装として、プールリソースとモノトニックリソースを提供している。このメモリーリソースの詳細は後に解説するが、ここではそのための事前知識として、汎用的なメモリーアロケーター一般の解説をする。</p>
<p>プログラマーはメモリーを気軽に確保している。たとえば47バイトとか151バイトのような中途半端なサイズのメモリーを以下のように気軽に確保している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> mem = <span class="bu">std::</span>get_default_resource() ;

    <span class="kw">auto</span> p1 = mem-&gt;allocate( <span class="dv">47</span> ) ;
    <span class="kw">auto</span> p2 = mem-&gt;allocate( <span class="dv">151</span> ) ;

    mem-&gt;deallocate( p1 ) ;
    mem-&gt;deallocate( p2 ) ;
}</code></pre></div>
<p>しかし、残念ながら現実のハードウェアやOSのメモリー管理は、このように柔軟にはできていない。たとえば、あるアーキテクチャーとOSでは、メモリーはページサイズと呼ばれる単位でしか確保できない。そして最小のページサイズですら4Kバイトであったりする。もしシステムの低級なメモリー管理を使って上のコードを実装しようとすると、47バイト程度のメモリーを使うのに3Kバイト超の無駄が生じることになる。</p>
<p>他にもアライメントの問題がある。アーキテクチャーによってはメモリーアドレスが適切なアライメントに配置されていないとメモリーアクセスができないか、著しくパフォーマンスが落ちることがある。</p>
<p><code>malloc</code>や<code>operator new</code>などのメモリーアロケーターは、低級なメモリー管理を隠匿し、小さなサイズのメモリー確保を効率的に行うための実装をしている。</p>
<p>一般的には、大きな連続したアドレス空間のメモリーを確保し、その中に管理用のデータ構造を作り、メモリーを必要なサイズに切り出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="co">// ストレージを分割して管理するためのリンクリストデータ構造</span>
<span class="kw">struct</span> <span class="kw">alignas</span>(<span class="bu">std::</span>max_align_t) chunk
{
    chunk * next ;
    chunk * prev ;
    <span class="bu">std::</span>size_t size ;
} ;

<span class="kw">class</span> memory_allocator : <span class="kw">public</span> <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource
{
    chunk * ptr ; <span class="co">// ストレージの先頭へのポインター</span>
    <span class="bu">std::</span>size_t size ; <span class="co">// ストレージのサイズ</span>
    <span class="bu">std::</span>mutex m ; <span class="co">// 同期用</span>

    
<span class="kw">public</span> :

    memory_allocator()
    {
        <span class="co">// 大きな連続したストレージを確保</span>
    }

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>scoped_lock lock( m ) ; 
        <span class="co">// リンクリストをたどり、十分な大きさの未使用領域を探し、リンクリスト構造体を</span>
        <span class="co">// 構築して返す</span>
        <span class="co">// アライメント要求に注意</span>
    }

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_deallocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>scoped_lock lock( m ) ;
        <span class="co">// リンクリストから該当する部分を削除</span>
    }

    <span class="kw">virtual</span> <span class="dt">bool</span> 
    do_is_equal( <span class="at">const</span> memory_resource &amp; other )
        <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>
    { 
    <span class="co">// *thisとotherで相互にストレージを解放できるかどうか返す</span>
    }
} ;</code></pre></div>
<h2 id="プールリソース">プールリソース</h2>
<p>プールリソースはC++17の標準ライブラリが提供しているメモリーリソースの実装だ。<code>synchronized_pool_resource</code>と<code>unsynchronized_pool_resource</code>の2つがある。</p>
<h3 id="アルゴリズム">アルゴリズム</h3>
<p>プールリソースは以下のような特徴を持つ。</p>
<ul>
<li>プールリソースのオブジェクトが破棄されるとき、そのオブジェクトから<code>allocate</code>で確保したストレージは、明示的に<code>deallocate</code>を呼ばずとも解放される。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource mem ;
    mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// 確保したストレージは破棄される</span>
}</code></pre></div>
<ul>
<li>プールリソースの構築時に、上流メモリーリソースを与えることができる。プールリソースは上流メモリーリソースからチャンクのためのストレージを確保する。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// get_default_resource()が使われる</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource m1 ;

    <span class="co">// 独自の上流メモリーリソースを指定</span>
    custom_memory_resource mem ;
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource m2( &amp;mem ) ;
    
}</code></pre></div>
<ul>
<li><p>プールリソースはストレージを確保する上流メモリーリソースから、プールと呼ばれる複数のストレージを確保する。プールは複数のチャンクを保持している。チャンクは複数の同一サイズのブロックを保持している。プールリソースに対する<code>do_allocate(size, alignment)</code>は、少なくとも<code>size</code>バイトのブロックサイズのプールのいずれかのチャンクのブロックが割り当てられる。</p>
<p>もし、最大のブロックサイズを超えるサイズのストレージを確保しようとした場合、上流メモリーリソースから確保される。</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="co">// チャンクの実装</span>
<span class="kw">template</span> &lt; <span class="dt">size_t</span> block_size &gt;
<span class="kw">class</span> chunk
{
    blocks&lt;block_size&gt; b ;
}

<span class="co">// プールの実装</span>
<span class="kw">template</span> &lt; <span class="dt">size_t</span> block_size &gt;
<span class="kw">class</span> pool : <span class="kw">public</span> memory_resource
{
    chunks&lt;block_size&gt; c ;
} ;

<span class="kw">class</span> pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="co">// それぞれのブロックサイズのプール</span>
    pool&lt;<span class="dv">8</span>&gt; pool_8bytes ;
    pool&lt;<span class="dv">16</span>&gt; pool_16bytes ;
    pool&lt;<span class="dv">32</span>&gt; pool_32bytes ;

    <span class="co">// 上流メモリーリソース</span>
    memory_resource * mem ;


    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 対応するブロックサイズのプールにディスパッチ</span>
        <span class="cf">if</span> ( bytes &lt;= <span class="dv">8</span> )
            <span class="cf">return</span> pool_8bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span> <span class="cf">if</span> ( bytes &lt;= <span class="dv">16</span> )
            <span class="cf">return</span> pool_16bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span> <span class="cf">if</span> ( bytes &lt; <span class="dv">32</span> )
            <span class="cf">return</span> pool_32bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span>
        <span class="co">// 最大ブロックサイズを超えたので上流メモリーリソースにディスパッチ</span>
            <span class="cf">return</span> mem-&gt;allocate( bytes, alignment ) ;
    }
} ;

}</code></pre></div>
<ul>
<li><p>プールリソースは構築時に<code>pool_options</code>を渡すことにより、最大ブロックサイズと最大チャンクサイズを設定できる。</p></li>
<li><p>マルチスレッドから呼び出しても安全な同期を取る<code>synchronized_pool_resource</code>と、同期を取らない<code>unsynchronized_pool_resource</code>がある。</p></li>
</ul>
<h3 id="synchronizedunsynchronized_pool_resource">synchronized/unsynchronized_pool_resource</h3>
<p>プールリソースには、<code>synchronized_pool_resource</code>と<code>unsynchronized_pool_resource</code>がある。どちらもクラス名以外は同じように使える。ただし、<code>synchronized_pool_resource</code>は複数のスレッドから同時に実行しても使えるように内部で同期が取られているのに対し、<code>unsynchronized_pool_resource</code>は同期を行わない。<code>unsyncrhonized_pool_resource</code>は複数のスレッドから同時に呼び出すことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> synchronized_pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="bu">std::</span>mutex m ;

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="dt">size_t</span> size, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 同期する</span>
        <span class="bu">std::</span>scoped_lock l(m) ;
        <span class="cf">return</span> do_allocate_impl( size, alignment ) ;
    }
} ;

<span class="kw">class</span> unsynchronized_pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="dt">size_t</span> size, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 同期しない</span>
        <span class="cf">return</span> do_allocate_impl( size, alignment ) ;
    }
} ;

}</code></pre></div>
<h3 id="pool_options">pool_options</h3>
<p><code>pool_options</code>はプールリソースの挙動を指定するためのクラスで、以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">struct</span> pool_options {
    <span class="dt">size_t</span> max_blocks_per_chunk = <span class="dv">0</span>;
    <span class="dt">size_t</span> largest_required_pool_block = <span class="dv">0</span>;
};

}</code></pre></div>
<p>このクラスのオブジェクトをプールリソースのコンストラクターに与えることで、プールリソースの挙動を指定できる。ただし、<code>pool_options</code>による指定はあくまでも目安で、実装には従う義務はない。</p>
<p><code>max_blocks_per_chunk</code>は、上流メモリーリソースからプールのチャンクを補充する際に一度に確保する最大のブロック数だ。この値がゼロか、実装の上限より大きい場合、実装の上限が使われる。実装は指定よりも小さい値を使うことができるし、またプールごとに別の値を使うこともできる。</p>
<p><code>largest_required_pool_block</code>はプール機構によって確保される最大のストレージのサイズだ。この値より大きなサイズのストレージを確保しようとすると、上流メモリーストレージから直接確保される。この値がゼロか、実装の上限よりも大きい場合、実装の上限が使われる。実装は指定よりも大きい値を使うこともできる。</p>
<h3 id="プールリソースのコンストラクター">プールリソースのコンストラクター</h3>
<p>プールリソースの根本的なコンストラクターは以下のとおり。<code>synchronized</code>と<code>unsynchronized</code>どちらも同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pool_resource(<span class="at">const</span> pool_options&amp; opts, memory_resource* upstream);

pool_resource()
: pool_resource(pool_options(), get_default_resource()) {}
<span class="kw">explicit</span> pool_resource(memory_resource* upstream)
: pool_resource(pool_options(), upstream) {}
<span class="kw">explicit</span> pool_resource(<span class="at">const</span> pool_options&amp; opts)
: pool_resource(opts, get_default_resource()) {}</code></pre></div>
<p><code>pool_options</code>と<code>memory_resource *</code>を指定する。指定しない場合はデフォルト値が使われる。</p>
<h3 id="プールリソースのメンバー関数">プールリソースのメンバー関数</h3>
<h4 id="release">release()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> release();</code></pre></div>
<p>確保したストレージすべてを解放する。たとえ明示的に<code>deallocate</code>を呼び出されていないストレージも解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    synchronized_pool_resource mem ;
    <span class="dt">void</span> * ptr = mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// ptrは解放される</span>
    mem.release() ;

}</code></pre></div>
<h4 id="upstream_resource">upstream_resource()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* upstream_resource() <span class="at">const</span>;</code></pre></div>
<p>構築時に渡した上流メモリーリソースへのポインターを返す。</p>
<h4 id="options">options()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pool_options options() <span class="at">const</span>;</code></pre></div>
<p>構築時に渡した<code>pool_options</code>オブジェクトと同じ値を返す。</p>
<h2 id="モノトニックバッファーリソース">モノトニックバッファーリソース</h2>
<p>モノトニックバッファーリソースはC++17で標準ライブラリに追加されたメモリーリソースの実装だ。クラス名は<code>monotonic_buffer_resource</code>。</p>
<p>モノトニックバッファーリソースは高速にメモリーを確保し、一気に解放するという用途に特化した特殊な設計をしている。モノトニックバッファーリソースはメモリー解放をせず、メモリー使用量がモノトニックに増え続けるので、この名前が付いている。</p>
<p>たとえばゲームで1フレームを描画する際に大量に小さなオブジェクトのためのストレージを確保し、その後確保したストレージをすべて解放したい場合を考える。通常のメモリーアロケーターでは、メモリー片を解放するためにメモリー全体に構築されたデータ構造をたどり、データ構造を書き換えなければならない。この処理は高くつく。すべてのメモリー片を一斉に解放してよいのであれば、データ構造をいちいちたどったり書き換えたりする必要はない。メモリーの管理は、単にポインターだけでよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> monotonic_buffer_resource : <span class="kw">public</span> memory_resource
{
    <span class="co">// 連続した長大なストレージの先頭へのポインター</span>
    <span class="dt">void</span> * ptr ;
    <span class="co">// 現在の未使用ストレージの先頭へのポインター</span>
    <span class="bu">std::</span>byte * current ;

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="dt">void</span> * result = <span class="kw">static_cast</span>&lt;<span class="dt">void</span> *&gt;(current) ;
        current += bytes ; <span class="co">// 必要であればアライメント調整</span>
        <span class="cf">return</span> result ;
    }

    <span class="kw">virtual</span> <span class="dt">void</span> 
    do_deallocate( <span class="dt">void</span> * ptr, <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span> 
    {
        <span class="co">// 何もしない</span>
    }

<span class="kw">public</span> :
    ~monotonic_buffer_resource()
    {
        <span class="co">// ptrの解放</span>
    }
} ;

}</code></pre></div>
<p>このように、基本的な実装としては、<code>do_allocate</code>はポインターを加算して管理するだけだ。なぜならば解放処理がいらないため、個々のストレージ片を管理するためのデータ構造を構築する必要がない。<code>do_deallocate</code>は何もしない。デストラクターはストレージ全体を解放する。</p>
<h3 id="アルゴリズム-1">アルゴリズム</h3>
<p>モノトニックバッファーリソースは以下のような特徴を持つ。</p>
<ul>
<li><code>deallocate</code>呼び出しは何もしない。メモリー使用量はリソースが破棄されるまでモノトニックに増え続ける。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem ;

    <span class="dt">void</span> * ptr = mem.allocate( <span class="dv">10</span> ) ;
    <span class="co">// 何もしない</span>
    <span class="co">// ストレージは解放されない</span>
    mem.deallocate( ptr ) ;

    <span class="co">// memが破棄される際に確保したストレージはすべて破棄される</span>
}</code></pre></div>
<ul>
<li>メモリー確保に使う初期バッファーを与えることができる。ストレージ確保の際に、初期バッファーに空きがある場合はそこから確保する。空きがない場合は上流メモリーリソースからバッファーを確保して、バッファーから確保する。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte initial_buffer[<span class="dv">10</span>] ;
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource 
        mem( initial_buffer, <span class="dv">10</span>, <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;

    <span class="co">// 初期バッファーから確保</span>
    mem.allocate( <span class="dv">1</span> ) ;
    <span class="co">// 上流メモリーリソースからストレージを確保して切り出して確保</span>
    mem.allocate( <span class="dv">100</span> ) ;
    <span class="co">// 前回のストレージ確保で空きがあればそこから</span>
    <span class="co">// なければ新たに上流から確保して切り出す</span>
    mem.allocate( <span class="dv">100</span> ) ;
}</code></pre></div>
<ul>
<li><p>1つのスレッドから使うことを前提に設計されている。<code>allocate</code>と<code>deallocate</code>は同期しない。</p></li>
<li><p>メモリーリソースが破棄されると確保されたすべてのストレージも解放される。明示的に<code>deallocate</code>を呼ばなくてもよい。</p></li>
</ul>
<h3 id="コンストラクター-1">コンストラクター</h3>
<p>モノトニックバッファーリソースには以下のコンストラクターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">explicit</span> monotonic_buffer_resource(memory_resource *upstream);
monotonic_buffer_resource(  <span class="dt">size_t</span> initial_size,
                            memory_resource *upstream);
monotonic_buffer_resource(  <span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size,
                            memory_resource *upstream);


monotonic_buffer_resource()
    : monotonic_buffer_resource(get_default_resource()) {}
<span class="kw">explicit</span> monotonic_buffer_resource(<span class="dt">size_t</span> initial_size)
    : monotonic_buffer_resource(initial_size,
                                get_default_resource()) {}
monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size)
    : monotonic_buffer_resource(buffer, buffer_size,
                                get_default_resource()) {}</code></pre></div>
<p>初期バッファーを取らないコンストラクターは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">explicit</span> monotonic_buffer_resource(memory_resource *upstream);
monotonic_buffer_resource(  <span class="dt">size_t</span> initial_size,
                            memory_resource *upstream);

monotonic_buffer_resource()
    : monotonic_buffer_resource(get_default_resource()) {}
<span class="kw">explicit</span> monotonic_buffer_resource(<span class="dt">size_t</span> initial_size)
    : monotonic_buffer_resource(initial_size,
                                get_default_resource()) {}</code></pre></div>
<p><code>initial_size</code>は、上流メモリーリソースから最初に確保するバッファーのサイズ（初期サイズ）のヒントとなる。実装はこのサイズか、あるいは実装依存のサイズをバッファーとして確保する。</p>
<p>デフォルトコンストラクターは上流メモリーリソースに<code>std::pmr_get_default_resource()</code>を与えたのと同じ挙動になる。</p>
<p><code>size_t</code>1つだけを取るコンストラクターは、初期サイズだけを与えて後はデフォルトの扱いになる。</p>
<p>初期バッファーを取るコンストラクターは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">monotonic_buffer_resource(  <span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size,
                            memory_resource *upstream);

monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size)
    : monotonic_buffer_resource(buffer, buffer_size,
                                get_default_resource()) {}</code></pre></div>
<p>初期バッファーは先頭アドレスを<code>void *</code>型で渡し、そのサイズを<code>size_t</code>型で渡す。</p>
<h3 id="その他の操作">その他の操作</h3>
<h4 id="release-1">release()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> release() ;</code></pre></div>
<p>メンバー関数<code>release</code>は、上流リソースから確保されたストレージをすべて解放する。明示的に<code>deallocate</code>を呼び出していないストレージも解放される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem ;

    mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// ストレージはすべて解放される</span>
    mem.release() ;

}</code></pre></div>
<h4 id="upstream_resource-1">upstream_resource()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* upstream_resource() <span class="at">const</span>;</code></pre></div>
<p>メンバー関数<code>uptream_resource</code>は、構築時に与えられた上流メモリーリソースへのポインターを返す。</p>
<h1 id="並列アルゴリズム">並列アルゴリズム</h1>
<p>並列アルゴリズムはC++17で追加された新しいライブラリだ。このライブラリは既存の<code>&lt;algorithm&gt;</code>に、並列実行版を追加する。</p>
<h2 id="並列実行について">並列実行について</h2>
<p>C++11では、スレッドと同期処理が追加され、複数の実行媒体が同時に実行されるという概念がC++標準規格に入った。</p>
<p>C++17では、既存のアルゴリズムに、並列実行版が追加された。</p>
<p>たとえば、<code>all_of(first, last, pred)</code>というアルゴリズムは、<code>[first,last)</code>の区間が空であるか、すべてのイテレーター<code>i</code>に対して<code>pred(*i)</code>が<code>true</code>を返すとき、<code>true</code>を返す。それ以外の場合は<code>false</code>を返す。</p>
<p>すべての値が100未満であるかどうかを調べるには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="cf">return</span> <span class="bu">std::</span>all_of( <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
        []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
}

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; input ;
    <span class="bu">std::</span>copy( <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin),
        <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(), <span class="bu">std::</span>back_inserter(input) ) ;

    <span class="dt">bool</span> result = is_all_of_less_than_100( input ) ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;result : &quot;</span> &lt;&lt; result &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>本書の執筆時点では、コンピューターはマルチコアが一般的になり、同時に複数のスレッドを実行できるようになった。さっそくこの処理を2つのスレッドで並列化してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> double_is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(input) ;
    <span class="kw">auto</span> last = first + (input.size()/<span class="dv">2</span>) ;

    <span class="kw">auto</span> r1 = <span class="bu">std::</span>async( [=]
    {
        <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,
                            [](<span class="kw">auto</span> x) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ; 
    } ) ;

    first = last ;
    last = <span class="bu">std::</span>end(input) ;

    <span class="kw">auto</span> r2 = <span class="bu">std::</span>async( [=]
    {
        <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,
                            [](<span class="kw">auto</span> x) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
    } ) ;

    <span class="cf">return</span> r1.get() &amp;&amp; r2.get() ;
}</code></pre></div>
<p>なるほど、とてもわかりにくいコードだ。</p>
<p>筆者のコンピューターのCPUは2つの物理コア、4つの論理コアを持っているので、4スレッドまで同時に並列実行できる。読者の使っているコンピューターは、より高性能でさらに多くのスレッドを同時に実行可能だろう。実行時に最大の効率を出すようにできるだけ頑張ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> parallel_is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="bu">std::</span>size_t cores = <span class="bu">std::</span>thread<span class="bu">::</span>hardware_concurrency() ;
    cores = <span class="bu">std::</span>min( input.size(), cores ) ;

    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>future&lt;<span class="dt">bool</span>&gt; &gt; futures( cores ) ;

    <span class="kw">auto</span> step = input.size() / cores ;
    <span class="kw">auto</span> remainder = input.size() % cores ;

    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(input) ;
    <span class="kw">auto</span> last = first + step + remainder ;

    <span class="cf">for</span> ( <span class="kw">auto</span> &amp; f : futures )
    {
        f = <span class="bu">std::</span>async( [=]
        {
            <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,
                                [](<span class="kw">auto</span> x){ <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
        } ) ;

        first = last ;
        last = first + step ;
    }

    <span class="cf">for</span> ( <span class="kw">auto</span> &amp; f : futures )
    {
        <span class="cf">if</span> ( f.get() == <span class="kw">false</span> )
            <span class="cf">return</span> <span class="kw">false</span> ;
    }
    <span class="cf">return</span> <span class="kw">true</span> ;
}</code></pre></div>
<p>もうわけがわからない。</p>
<p>このような並列化をそれぞれのアルゴリズムに対して自前で実装するのは面倒だ。そこで、C++17では標準で並列実行してくれる並列アルゴリズム（Parallelism）が追加された。</p>
<h2 id="使い方-4">使い方</h2>
<p>並列アルゴリズムは既存のアルゴリズムのオーバーロードとして追加されている。</p>
<p>以下は既存のアルゴリズムである<code>all_of</code>の宣言だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Predicate&gt;
<span class="dt">bool</span> all_of(InputIterator first, InputIterator last, Predicate pred);</code></pre></div>
<p>並列アルゴリズム版の<code>all_of</code>は以下のような宣言になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> ExecutionPolicy, <span class="kw">class</span> ForwardIterator,
            <span class="kw">class</span> Predicate&gt;
<span class="dt">bool</span> all_of(ExecutionPolicy&amp;&amp; exec, ForwardIterator first,
            ForwardIterator last, Predicate pred);</code></pre></div>
<p>並列アルゴリズムには、テンプレート仮引数として<code>ExecutionPolicy</code>が追加されていて第一引数に取る。これを実行時ポリシーと呼ぶ。</p>
<p>実行時ポリシーは<code>&lt;execution&gt;</code>で定義されている関数ディスパッチ用のタグ型で、<code>std::execution::seq</code>, <code>std::execution::par</code>, <code>std::execution::par_unseq</code>がある。</p>
<p>複数のスレッドによる並列実行を行うには、<code>std::execution::par</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="cf">return</span> <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par,
        <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
        []( <span class="kw">auto</span> x ){ <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
}</code></pre></div>
<p><code>std::execution::seq</code>を渡すと既存のアルゴリズムと同じシーケンシャル実行になる。<code>std::execution::par</code>を渡すとパラレル実行になる。<code>std::execution::par_unseq</code>は並列実行かつベクトル実行になる。</p>
<p>C++17には実行ポリシーを受け取るアルゴリズムのオーバーロード関数が追加されている。</p>
<h2 id="並列アルゴリズム詳細">並列アルゴリズム詳細</h2>
<h3 id="並列アルゴリズム-1">並列アルゴリズム</h3>
<p>並列アルゴリズム（parallel algorithm）とは、<code>ExecutionPolicy</code>（実行ポリシー）というテンプレートパラメーターのある関数テンプレートのことだ。既存の<code>&lt;algorithm&gt;</code>とC++14で追加された一部の関数テンプレートが、並列アルゴリズムに対応している。</p>
<p>並列アルゴリズムはイテレーター、仕様上定められた操作、ユーザーの提供する関数オブジェクトによる操作、仕様上定められた関数オブジェクトに対する操作によって、オブジェクトにアクセスする。そのような関数群を、要素アクセス関数（element access functions）と呼ぶ。</p>
<p>たとえば、<code>std::sort</code>は以下のような要素アクセス関数を持つ。</p>
<ul>
<li>テンプレート実引数で与えられたランダムアクセスイテレーター</li>
<li>要素に対する<code>swap</code>関数の適用</li>
<li>ユーザー提供された<code>Compare</code>関数オブジェクト</li>
</ul>
<p>並列アルゴリズムが使う要素アクセス関数は、並列実行に伴うさまざまな制約を満たさなければならない。</p>
<h3 id="ユーザー提供する関数オブジェクトの制約">ユーザー提供する関数オブジェクトの制約</h3>
<p>並列アルゴリズムのうち、テンプレートパラメーター名が、<code>Predicate</code>, <code>BinaryPredicate</code>, <code>Compare</code>, <code>UnaryOperation</code>, <code>BinaryOperation</code>, <code>BinaryOperation1</code>, <code>BinaryOperation2</code>となってるものは、関数オブジェクトとしてユーザーがアルゴリズムに提供するものである。このようなユーザー提供の関数オブジェクトには、並列アルゴリズムに渡す際の制約がある。</p>
<ul>
<li>実引数で与えられたオブジェクトを直接、間接に変更してはならない</li>
<li>実引数で与えられたオブジェクトの一意性に依存してはならない</li>
<li>データ競合と同期</li>
</ul>
<p>一部の特殊なアルゴリズムには例外もあるが、ほとんどの並列アルゴリズムではこの制約を満たさなければならない。</p>
<h4 id="実引数で与えられたオブジェクトを直接間接に変更してはならない">実引数で与えられたオブジェクトを直接、間接に変更してはならない</h4>
<p>ユーザー提供の関数オブジェクトは実引数で与えられたオブジェクトを直接、間接に変更してはならない。</p>
<p>つまり、以下のようなコードは違法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
    <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [](<span class="kw">auto</span> &amp; x){ ++x ; <span class="cf">return</span> <span class="kw">true</span> ; } ) ;
    <span class="co">// エラー</span>
}</code></pre></div>
<p>これは、ユーザー提供の関数オブジェクトが実引数を<code>lvalue</code>リファレンスで受け取って変更しているので、並列アルゴリズムの制約を満たさない。</p>
<p><code>std::for_each</code>はイテレーターが変更可能な要素を返す場合、ユーザー提供の関数オブジェクトが実引数を変更することが可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [](<span class="kw">auto</span> &amp; x){ ++x ; } ) ;
    <span class="co">// OK</span>
}</code></pre></div>
<p>これは、<code>for_each</code>は仕様上そのように定められているからだ。</p>
<h4 id="実引数で与えられたオブジェクトの一意性に依存してはならない">実引数で与えられたオブジェクトの一意性に依存してはならない</h4>
<p>ユーザー提供の関数オブジェクトは実引数で与えられたオブジェクトの一意性に依存してはならない。</p>
<p>これはどういうことかというと、たとえば実引数で渡されたオブジェクトのアドレスを取得して、そのアドレスがアルゴリズムに渡したオブジェクトのアドレスと同じであることを期待するようなコードを書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="co">// 最後の要素へのポインター</span>
    <span class="dt">int</span> * ptr = &amp;c[<span class="dv">4</span>] ;

    <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [=]( <span class="kw">auto</span> &amp; x ){
            <span class="cf">if</span> ( ptr == &amp;x )
            {
                <span class="co">// 最後の要素なので特別な処理</span>
                <span class="co">// エラー</span>
            }
        } ) ;
}</code></pre></div>
<p>これはなぜかというと、並列アルゴリズムはその並列処理の一環として、要素のコピーを作成し、そのコピーをユーザー提供の関数オブジェクトに渡すかもしれないからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">template</span> &lt;  <span class="kw">typename</span> ExecutionPolicy,
            <span class="kw">typename</span> ForwardIterator,
            <span class="kw">typename</span> Predicate &gt;
<span class="dt">bool</span> all_of(    ExecutionPolicy &amp;&amp; exec,
                ForwardIterator first, ForwardIterator last,
                Predicate pred )
{
    <span class="cf">if</span> <span class="kw">constexpr</span> (
        <span class="bu">std::</span>is_same_v&lt; ExecutionPolicy,
                        <span class="bu">std::</span>execution<span class="bu">::</span>parallel_policy &gt;
    )
    {
        <span class="bu">std::</span>vector c( first, last ) ;
        do_all_of_par( <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c), pred ) ;
    }
}</code></pre></div>
<p>このため、オブジェクトの一意性に依存したコードを書くことはできない。</p>
<h4 id="データ競合と同期">データ競合と同期</h4>
<p><code>std::execution::sequenced_policy</code>を渡した並列アルゴリズムによる要素アクセス関数の呼び出しは呼び出し側スレッドで実行される。パラレル実行ではない。</p>
<p><code>std::execution::parallel_policy</code>を渡した並列アルゴリズムによる要素アクセス関数の呼び出しは、呼び出し側スレッドか、ライブラリ側で作られたスレッドのいずれかで実行される。それぞれの要素アクセス関数の呼び出しの同期は定められていない。そのため、要素アクセス関数はデータ競合やデッドロックを起こさないようにしなければならない。</p>
<p>以下のコードはデータ競合が発生するのでエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [&amp;]( <span class="kw">auto</span> x ){ sum += x ; } ) ;
    <span class="co">// エラー、データ競合</span>
}</code></pre></div>
<p>なぜならば、ユーザー提供の関数オブジェクトは複数のスレッドから同時に呼び出されるかもしれないからだ。</p>
<p><code>std::execution::parallel_unsequenced_policy</code>の実行は変わっている。未規定のスレッドから同期されない実行が許されている。これは、パラレルベクトル実行で想定している実行媒体がスレッドのような強い実行保証のある実行媒体ではなく、SIMDやGPGPUのような極めて軽い実行媒体であるからだ。</p>
<p>その結果、要素アクセス関数は通常のデータ競合やデッドロックを防ぐための手段すら取れなくなる。なぜならば、スレッドは実行の途中に中断して別の処理をしたりするからだ。</p>
<p>たとえば、以下のコードは動かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
    <span class="bu">std::</span>mutex m ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="bu">std::</span>for_each(
        <span class="bu">std::</span>execution<span class="bu">::</span>par_unseq,
        <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [&amp;]( <span class="kw">auto</span> x ) {
            <span class="bu">std::</span>scoped_lock l(m) ;
            sum += x ; 
        } ) ;
    <span class="co">// エラー</span>
}</code></pre></div>
<p>このコードは<code>parallel_policy</code>ならば、非効率的ではあるが問題なく同期されてデータ競合なく動くコードだ。しかし、<code>parallel_unsequenced_policy</code>では動かない。なぜならば、<code>mutex</code>の<code>lock</code>という同期をする関数を呼び出すからだ。</p>
<p>C++では、ストレージの確保解放以外の同期する標準ライブラリの関数をすべて、ベクトル化非安全（vectorization-unsafe）に分類している。ベクトル化非安全な関数は<code>std::execution::parallel_unsequenced_policy</code>の要素アクセス関数内で呼び出すことはできない。</p>
<h3 id="例外">例外</h3>
<p>並列アルゴリズムの実行中に、一時メモリーの確保が必要になったが確保できない場合、<code>std::bad_allocがthrow</code>される。</p>
<p>並列アルゴリズムの実行中に、要素アクセス関数の外に例外が投げられた場合、<code>std::terminate</code>が呼ばれる。</p>
<h3 id="実行ポリシー">実行ポリシー</h3>
<p>実行ポリシーはヘッダーファイル<code>&lt;execution&gt;</code>で定義されている。その定義は以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">struct</span> is_execution_policy;
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span>
    is_execution_policy_v = is_execution_policy&lt;T&gt;::value;
}

<span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> sequenced_policy;
<span class="kw">class</span> parallel_policy;
<span class="kw">class</span> parallel_unsequenced_policy;

<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq{ };

}</code></pre></div>
<h4 id="is_execution_policy-traits">is_execution_policy traits</h4>
<p><code>std::is_execution_policy&lt;T&gt;</code>は<code>T</code>が実行ポリシー型であるかどうかを返す<code>traits</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// false</span>
<span class="kw">constexpr</span> <span class="dt">bool</span> b1 = <span class="bu">std::</span>is_execution_policy_v&lt;<span class="dt">int</span>&gt; ;
<span class="co">// true</span>
<span class="kw">constexpr</span> <span class="dt">bool</span> b2 = 
    <span class="bu">std::</span>is_execution_policy_v&lt;<span class="bu">std::</span>execution<span class="bu">::</span>sequenced_policy&gt; ;</code></pre></div>
<h4 id="シーケンス実行ポリシー">シーケンス実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> sequenced_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq { } ;

}</code></pre></div>
<p>シーケンス実行ポリシーは、並列アルゴリズムにパラレル実行を行わせないためのポリシーだ。この実行ポリシーが渡された場合、処理は呼び出し元のスレッドだけで行われる。</p>
<h4 id="パラレル実行ポリシー">パラレル実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> parallel_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par { } ;

}</code></pre></div>
<p>パラレル実行ポリシーは、並列アルゴリズムにパラレル実行を行わせるためのポリシーだ。この実行ポリシーが渡された場合、処理は呼び出し元のスレッドと、ライブラリが作成したスレッドを用いる。</p>
<h4 id="パラレル非シーケンス実行ポリシー">パラレル非シーケンス実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> parallel_unsequenced_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq { } ;

}</code></pre></div>
<p>パラレル非シーケンス実行ポリシーは、並列アルゴリズムにパラレル実行かつベクトル実行を行わせるためのポリシーだ。この実行ポリシーが渡された場合、処理は複数のスレッドと、SIMDやGPGPUのようなベクトル実行による並列化を行う。</p>
<h4 id="実行ポリシーオブジェクト">実行ポリシーオブジェクト</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq{ };

}</code></pre></div>
<p>実行ポリシーの型を直接書くのは面倒だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>parallel_policy{}, ... ) ;</code></pre></div>
<p>そのため、標準ライブラリは実行ポリシーのオブジェクトを用意している。<code>seq</code>と<code>par</code>と<code>par_unseq</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, ... ) ;</code></pre></div>
<p>並列アルゴリズムを使うには、このオブジェクトを並列アルゴリズムの第一引数に渡すことになる。</p>
<h1 id="数学の特殊関数群">数学の特殊関数群</h1>
<p>C++17では数学の特殊関数群（mathematical special functions）がヘッダーファイル<code>&lt;cmath&gt;</code>に追加された。</p>
<p>数学の特殊関数は、いずれも実引数を取って、規定の計算をし、結果を浮動小数点数型の戻り値として返す。</p>
<p>数学の特殊関数は<code>double</code>, <code>float</code>, <code>long double</code>型の3つのオーバーロードがある。それぞれ、関数名の最後に、何もなし、<code>f</code>, <code>l</code>というサフィックスで表現されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      function_name() ;   <span class="co">// 何もなし</span>
<span class="dt">float</span>       function_namef() ;  <span class="co">// f</span>
<span class="dt">long</span> <span class="dt">double</span> function_namel() ;  <span class="co">// l</span></code></pre></div>
<p>数学の特殊関数の説明は、関数の宣言、効果、戻り値、注意がある。</p>
<p>もし、数学の特殊関数に渡した実引数がNaN（Not a Number）である場合、関数の戻り値もNaNになる。ただし定義域エラーは起こらない。</p>
<p>それ以外の場合で、関数が定義域エラーを返すべきときは、</p>
<ul>
<li>関数の戻り値の記述で、定義域が示されていて実引数が示された定義域を超えるとき</li>
<li>実引数に対応する数学関数の結果の値が非ゼロの虚数部を含むとき</li>
<li>実引数に対応する数学関数の結果の値が数学的に定義されていないとき</li>
</ul>
<p>別途示されていない場合、関数はすべての有限の値、負の無限大、正の無限大に対しても定義されている。</p>
<p>数学関数が与えられた実引数の値に対して定義されているというとき、それは以下のいずれかである。</p>
<ul>
<li>実引数の値の集合に対して明示的に定義されている</li>
<li>計算方法に依存しない極限値が存在する</li>
</ul>
<p>ある関数の効果が実装定義（implementation-defined）である場合、その効果はC++標準規格で定義されず、C++実装はどのように実装してもよいという意味だ。</p>
<h2 id="ラゲール多項式laguerre-polynomials">ラゲール多項式（Laguerre polynomials）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       laguerre(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        laguerref(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  laguerrel(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>n</code>, <code>x</code>に対するラゲール多項式（Laguerre polynomials）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{L}_n(x) =
  \frac{e^x}{n!} \frac{ \mathsf{d} ^ n}
            { \mathsf{d}x ^ n} \, (x^n e^{-x}),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(n\)</span>を<code>n</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>： <code>n</code> &gt;= 128のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="ラゲール陪多項式associated-laguerre-polynomials">ラゲール陪多項式（Associated Laguerre polynomials）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      assoc_laguerre(<span class="dt">unsigned</span> n, <span class="dt">unsigned</span> m, <span class="dt">double</span> x);
<span class="dt">float</span>       assoc_laguerref(<span class="dt">unsigned</span> n, <span class="dt">unsigned</span> m, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span> assoc_laguerrel(<span class="dt">unsigned</span> n, <span class="dt">unsigned</span> m, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>n</code>, <code>m</code>, <code>x</code>に対するラゲール陪多項式（Associated Laguerre polynomials）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{L}_n^m(x) =
  (-1)^m \frac{\mathsf{d} ^ m}
       {\mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(n\)</span>を<code>n</code>, <span class="math inline">\(m\)</span>を<code>m</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>n</code> &gt;= 128 もしくは <code>m</code> &gt;= 128 のときの関数呼び出しの効果は実装定義である。</p>
<h2 id="ルジャンドル多項式legendre-polynomials">ルジャンドル多項式（Legendre polynomials）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       legendre(<span class="dt">unsigned</span> l, <span class="dt">double</span> x);
<span class="dt">float</span>        legendref(<span class="dt">unsigned</span> l, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  legendrel(<span class="dt">unsigned</span> l, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>l</code>, <code>x</code>に対するルジャンドル多項式（Legendre polynomials）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{P}_\ell(x) =
  \frac{1}
       {2^\ell \, \ell!}
  \frac{ \mathsf{d} ^ \ell}
       { \mathsf{d}x ^ \ell} \, (x^2 - 1) ^ \ell,
       \quad \mbox{for $|x| \le 1$}
\]</span></p>
<p><span class="math inline">\(l\)</span>を<code>l</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>l</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="sf.cmath.assoc_legendre">ルジャンドル陪関数（Associated Legendre functions）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      assoc_legendre(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">double</span> x);
<span class="dt">float</span>       assoc_legendref(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span> assoc_legendrel(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>l</code>, <code>m</code>, <code>x</code>に対するルジャンドル陪関数（Associated Legendre functions）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{P}_\ell^m(x) =
  (1 - x^2) ^ {m/2}
  \:
  \frac{ \mathsf{d} ^ m}
       { \mathsf{d}x ^ m} \, \mathsf{P}_\ell(x),
       \quad \mbox{for $|x| \le 1$}
\]</span></p>
<p><span class="math inline">\(l\)</span>を<code>l</code>, <span class="math inline">\(m\)</span>を<code>m</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>l</code> &gt;= 128 のときの関数呼び出しの効果は実装定義である。</p>
<h2 id="球面ルジャンドル陪関数spherical-associated-legendre-functions">球面ルジャンドル陪関数（Spherical associated Legendre functions）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       sph_legendre(  <span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">double</span> theta);
<span class="dt">float</span>        sph_legendref( <span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">float</span> theta);
<span class="dt">long</span> <span class="dt">double</span>  sph_legendrel( <span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m,
                            <span class="dt">long</span> <span class="dt">double</span> theta);</code></pre></div>
<p><strong>効果</strong>：実引数<code>l</code>, <code>m</code>, <code>theta</code>（<code>theta</code>の単位はラジアン）に対する球面ルジャンドル陪関数（Spherical associated Legendre functions）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{Y}_\ell^m(\theta, 0)
\]</span></p>
<p>このとき、</p>
<p><span class="math display">\[
  \mathsf{Y}_\ell^m(\theta, \phi) =
  (-1)^m \left[ \frac{(2 \ell + 1)}
                     {4 \pi}
            \frac{(\ell - m)!}
                 {(\ell + m)!}
         \right]^{1/2}
     \mathsf{P}_\ell^m
     ( \cos\theta ) e ^ {i m \phi},
       \quad \mbox{for $|m| \le \ell$}
\]</span></p>
<p><span class="math inline">\(l\)</span>を<code>l</code>, <span class="math inline">\(m\)</span>を<code>m</code>, <span class="math inline">\(\theta\)</span>を<code>theta</code>とする。</p>
<p><strong>注意</strong>：<code>l</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p>球面調和関数（Spherical harmonics） <span class="math inline">\(\mathsf{Y}_\ell^m(\theta, \phi)\)</span> は、以下のような関数を定義することによって計算できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span>
<span class="pp">#include </span><span class="im">&lt;complex&gt;</span>

<span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt;
spherical_harmonics(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">double</span> theta, <span class="dt">double</span> phi)
{
    <span class="cf">return</span> <span class="bu">std::</span>sph_legendre(l, m, theta) * <span class="bu">std::</span>polar(<span class="fl">1.0</span>, m * phi) ;
}</code></pre></div>
<p><a href="#sf.cmath.assoc_legendre">ルジャンドル陪関数</a>も参照。</p>
<h2 id="エルミート多項式hermite-polynomials">エルミート多項式（Hermite polynomials）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       hermite(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        hermitef(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  hermitel(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>n</code>, <code>x</code>に対するエルミート多項式（Hermite polynomials）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{H}_n(x) =
  (-1)^n e^{x^2} \frac{ \mathsf{d} ^n}
              { \mathsf{d}x^n} \, e^{-x^2}
\;
\]</span></p>
<p><span class="math inline">\(n\)</span>を<code>n</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>n</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="ベータ関数beta-function">ベータ関数（Beta function）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      beta(<span class="dt">double</span> x, <span class="dt">double</span> y);
<span class="dt">float</span>       betaf(<span class="dt">float</span> x, <span class="dt">float</span> y);
<span class="dt">long</span> <span class="dt">double</span> betal(<span class="dt">long</span> <span class="dt">double</span> x, <span class="dt">long</span> <span class="dt">double</span> y);</code></pre></div>
<p><strong>効果</strong>：実引数<code>x</code>, <code>y</code>に対するベータ関数（Beta function）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{B}(x, y) =
  \frac{ \Gamma(x) \, \Gamma(y) }
       { \Gamma(x+y) },
       \quad \mbox{for $x &gt; 0$,\, $y &gt; 0$}
\]</span></p>
<p><span class="math inline">\(x\)</span>を<code>x</code>, <span class="math inline">\(y\)</span>を<code>y</code>とする。</p>
<h2 id="第1種完全楕円積分complete-elliptic-integral-of-the-first-kind">第1種完全楕円積分（Complete elliptic integral of the first kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      comp_ellint_1(<span class="dt">double</span> k);
<span class="dt">float</span>       comp_ellint_1f(<span class="dt">float</span> k);
<span class="dt">long</span> <span class="dt">double</span> comp_ellint_1l(<span class="dt">long</span> <span class="dt">double</span> k);</code></pre></div>
<p><strong>効果</strong>：実引数<code>k</code>に対する第1種完全楕円積分（Complete elliptic integral of the first kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{K}(k) =
  \mathsf{F}(k, \pi / 2),
              \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>を<code>k</code>とする。</p>
<p><a href="#sf.cmath.ellint_1">第1種不完全楕円積分</a>も参照。</p>
<h2 id="第2種完全楕円積分complete-elliptic-integral-of-the-second-kind">第2種完全楕円積分（Complete elliptic integral of the second kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      comp_ellint_2(<span class="dt">double</span> k);
<span class="dt">float</span>       comp_ellint_2f(<span class="dt">float</span> k);
<span class="dt">long</span> <span class="dt">double</span> comp_ellint_2l(<span class="dt">long</span> <span class="dt">double</span> k);</code></pre></div>
<p><strong>効果</strong>：実引数<code>k</code>に対する第2種完全楕円積分（Complete elliptic integral of the second kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{E}(k) =
  \mathsf{E}(k, \pi / 2),
\quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>を<code>k</code>とする。</p>
<p><a href="#sf.cmath.ellint_2">第2種不完全楕円積分</a>も参照。</p>
<h2 id="第3種完全楕円積分complete-elliptic-integral-of-the-third-kind">第3種完全楕円積分（Complete elliptic integral of the third kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      comp_ellint_3(<span class="dt">double</span> k, <span class="dt">double</span> nu);
<span class="dt">float</span>       comp_ellint_3f(<span class="dt">float</span> k, <span class="dt">float</span> nu);
<span class="dt">long</span> <span class="dt">double</span> comp_ellint_3l(<span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> nu);</code></pre></div>
<p><strong>効果</strong>：実引数<code>k</code>, <code>nu</code>に対する第3種完全楕円積分（Complete elliptic integral of the third kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{\Pi}(\nu, k) = \mathsf{\Pi}(\nu, k, \pi / 2),
        \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>を<code>k</code>, <span class="math inline">\(\nu\)</span>を<code>nu</code>とする。</p>
<p><a href="#sf.cmath.ellint_3">第3種不完全楕円積分</a>も参照。</p>
<h2 id="sf.cmath.ellint_1">第1種不完全楕円積分（Incomplete elliptic integral of the first kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       ellint_1(<span class="dt">double</span> k, <span class="dt">double</span> phi);
<span class="dt">float</span>        ellint_1f(<span class="dt">float</span> k, <span class="dt">float</span> phi);
<span class="dt">long</span> <span class="dt">double</span>  ellint_1l(<span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> phi);</code></pre></div>
<p><strong>効果</strong>：実引数<code>k</code>, <code>phi</code>（<code>phi</code>の単位はラジアン）に対する第1種不完全楕円積分（Incomplete elliptic integral of the first kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{F}(k, \phi) =
  \int_0^\phi \! \frac{\mathsf{d}\theta}
                      {\sqrt{1 - k^2 \sin^2 \theta}},
       \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>を<code>k</code>, <span class="math inline">\(\phi\)</span>を<code>phi</code>とする。</p>
<h2 id="sf.cmath.ellint_2">第2種不完全楕円積分（Incomplete elliptic integroal of the second kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       ellint_2(<span class="dt">double</span> k, <span class="dt">double</span> phi);
<span class="dt">float</span>        ellint_2f(<span class="dt">float</span> k, <span class="dt">float</span> phi);
<span class="dt">long</span> <span class="dt">double</span>  ellint_2l(<span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> phi);</code></pre></div>
<p><strong>効果</strong>：実引数<code>k</code>, <code>phi</code>（<code>phi</code>の単位はラジアン）に対する第2種不完全楕円積分（Incomplete elliptic integral of the second kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{E}(k, \phi) =
  \int_0^\phi \! \sqrt{1 - k^2 \sin^2 \theta} \, \mathsf{d}\theta,
       \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>を<code>k</code>, <span class="math inline">\(\phi\)</span>を<code>phi</code>とする。</p>
<h2 id="sf.cmath.ellint_3">第3種不完全楕円積分（Incomplete elliptic integral of the third kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       ellint_3(  <span class="dt">double</span> k, <span class="dt">double</span> nu, <span class="dt">double</span> phi);
<span class="dt">float</span>        ellint_3f( <span class="dt">float</span> k, <span class="dt">float</span> nu, <span class="dt">float</span> phi);
<span class="dt">long</span> <span class="dt">double</span>  ellint_3l( <span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> nu,
                        <span class="dt">long</span> <span class="dt">double</span> phi);</code></pre></div>
<p><strong>効果</strong>：実引数<code>k</code>, <code>nu</code>, <code>phi</code>（<code>phi</code>の単位はラジアン）に対する第3種不完全楕円積分（Incomplete elliptic integral of the third kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{\Pi}(\nu, k, \phi) =
  \int_0^\phi \! \frac{ \mathsf{d}\theta }
                      { (1 - \nu \, \sin^2 \theta) \sqrt{1 - k^2 \sin^2 \theta} },
       \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(\nu\)</span>を<code>nu</code>, <span class="math inline">\(k\)</span>を<code>k</code>, <span class="math inline">\(\phi\)</span>を<code>phi</code>とする。</p>
<h2 id="sf.cmath.cyl_bessel_j">第1種ベッセル関数（Cylindrical Bessel functions of the first kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_bessel_j(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_bessel_jf(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_bessel_jl(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>nu</code>, <code>k</code>に対する第1種ベッセル関数（Cylindrical Bessel functions of the first kind, Bessel functions of the first kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{J}_\nu(x) =
  \sum_{k=0}^\infty \frac{(-1)^k (x/2)^{\nu+2k}}
             {k! \: \Gamma(\nu+k+1)},
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(\nu\)</span>を<code>nu</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>nu</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="sf.cmath.cyl_neumann">ノイマン関数（Cylindrical Neumann functions）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_neumann(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_neumannf(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_neumannl(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>nu</code>, <code>x</code>に対するノイマン関数（Cylindrical Neumann functions, Neumann functions）、またの名を第2種ベッセル関数（Cylindrical Bessel functions of the second kind, Bessel functions of the second kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{N}_\nu(x) =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \frac{\mathsf{J}_\nu(x) \cos \nu\pi - \mathsf{J}_{-\nu}(x)}
       {\sin \nu\pi },
  &amp; \mbox{for $x \ge 0$ and non-integral $\nu$}
  \\
  \\
  \displaystyle
  \lim_{\mu \rightarrow \nu} \frac{\mathsf{J}_\mu(x) \cos \mu\pi - \mathsf{J}_{-\mu}(x)}
                                {\sin \mu\pi },
  &amp; \mbox{for $x \ge 0$ and integral $\nu$}
  \end{array}
  \right.
\]</span></p>
<p><span class="math inline">\(\nu\)</span>を<code>nu</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>nu</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>も参照。</p>
<h2 id="sf.cmath.cyl_bessel_i">第1種変形ベッセル関数（Regular modified cylindrical Bessel functions）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_bessel_i(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_bessel_if(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_bessel_il(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>nu</code>, <code>x</code>に対する第1種変形ベッセル関数（Regular modified cylindrical Bessel functions, Modified Bessel functions of the first kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{I}_\nu(x) =
  \mathrm{i}^{-\nu} \mathsf{J}_\nu(\mathrm{i}x)
  =
  \sum_{k=0}^\infty \frac{(x/2)^{\nu+2k}}
             {k! \: \Gamma(\nu+k+1)},
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(\nu\)</span>を<code>nu</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>nu</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>も参照。</p>
<h2 id="第2種変形ベッセル関数irregular-modified-cylindrical-bessel-functions">第2種変形ベッセル関数（Irregular modified cylindrical Bessel functions）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_bessel_k(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_bessel_kf(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_bessel_kl(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>nu</code>, <code>x</code>に対する第2種変形ベッセル関数（Irregular modified cylindrical Bessel functions, Modified Bessel functions of the second kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{K}_\nu(x) =
  (\pi/2)\mathrm{i}^{\nu+1} (            \mathsf{J}_\nu(\mathrm{i}x)
                + \mathrm{i} \mathsf{N}_\nu(\mathrm{i}x)
                )
  =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \frac{\pi}{2}
  \frac{\mathsf{I}_{-\nu}(x) - \mathsf{I}_{\nu}(x)}
       {\sin \nu\pi },
  &amp; \mbox{for $x \ge 0$ and non-integral $\nu$}
  \\
  \\
  \displaystyle
  \frac{\pi}{2}
  \lim_{\mu \rightarrow \nu} \frac{\mathsf{I}_{-\mu}(x) - \mathsf{I}_{\mu}(x)}
                                  {\sin \mu\pi },
  &amp; \mbox{for $x \ge 0$ and integral $\nu$}
  \end{array}
  \right.
\]</span></p>
<p><span class="math inline">\(\nu\)</span>を<code>nu</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>nu</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_i">第1種変形ベッセル関数</a>、<a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>、<a href="#sf.cmath.cyl_neumann">ノイマン関数</a>も参照。</p>
<h2 id="第1種球ベッセル関数spherical-bessel-functions-of-the-first-kind">第1種球ベッセル関数（Spherical Bessel functions of the first kind）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       sph_bessel(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        sph_besself(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  sph_bessell(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>n</code>, <code>x</code>に対する第1種球ベッセル関数（Spherical Bessel functions of the first kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{j}_n(x) =
  (\pi/2x)^{1\!/\!2} \mathsf{J}_{n + 1\!/\!2}(x),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><strong>注意</strong>： <code>n</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>も参照。</p>
<h2 id="球ノイマン関数spherical-neumann-functions">球ノイマン関数（Spherical Neumann functions）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       sph_neumann(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        sph_neumannf(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  sph_neumannl(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>n</code>, <code>x</code>に対する球ノイマン関数（Spherical Neumann functions）、またの名を第2種球ベッセル関数（Spherical Bessel functions of the second kind）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{n}_n(x) =
  (\pi/2x)^{1\!/\!2} \mathsf{N}_{n + 1\!/\!2}(x),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(n\)</span>を<code>n</code>, <span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<p><strong>注意</strong>：<code>n</code> &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_neumann">ノイマン関数</a>も参照。</p>
<h2 id="指数積分exponential-integral">指数積分（Exponential integral）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       expint(<span class="dt">double</span> x);
<span class="dt">float</span>        expintf(<span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  expintl(<span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>x</code>に対する指数積分（Exponential integral）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{Ei}(x) =
  - \int_{-x}^\infty \frac{e^{-t}}
                          {t     } \, \mathsf{d}t
\;
\]</span></p>
<p><span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<h2 id="リーマンゼータ関数riemann-zeta-function">リーマンゼータ関数（Riemann zeta function）</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       riemann_zeta(<span class="dt">double</span> x);
<span class="dt">float</span>        riemann_zetaf(<span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  riemann_zetal(<span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p><strong>効果</strong>：実引数<code>x</code>に対するリーマンゼータ関数（Riemann zeta function）を計算する。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
  \mathsf{\zeta}(x) =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \sum_{k=1}^\infty k^{-x},
  &amp; \mbox{for $x &gt; 1$}
  \\
  \\
  \displaystyle
  \frac{1}
    {1 - 2^{1-x}}
  \sum_{k=1}^\infty (-1)^{k-1} k^{-x},
  &amp; \mbox{for $0 \le x \le 1$}
  \\
  \\
  \displaystyle
  2^x \pi^{x-1} \sin(\frac{\pi x}{2}) \, \Gamma(1-x) \, \zeta(1-x),
  &amp; \mbox{for $x &lt; 0$}
  \end{array}
  \right.
\;
\]</span></p>
<p><span class="math inline">\(x\)</span>を<code>x</code>とする。</p>
<h1 id="その他の標準ライブラリ">その他の標準ライブラリ</h1>
<p>この章ではC++17で追加された細かいライブラリをまとめて解説する。</p>
<h2 id="ハードウェア干渉サイズキャッシュライン">ハードウェア干渉サイズ（キャッシュライン）</h2>
<p>C++17にはハードウェアの干渉サイズを取得するライブラリが入った。ハードウェアの干渉サイズとは、俗にキャッシュライン（cache line）とも呼ばれている概念だ。</p>
<p>残念ながら、この2017年では、メモリーは極めて遅い。そのため、プロセッサーはより高速にアクセスできるキャッシュメモリーを用意している。メモリーに対するキャッシュはある程度のまとまったバイト数単位で行われる。この単位が何バイトであるのかは実装依存だ。C++17にはこのサイズを取得できるライブラリが入った。</p>
<p>ハードウェア干渉サイズを知りたい理由は2つある。2つのオブジェクトを同一の局所性を持つキャッシュに載せたくない場合と載せたい場合だ。</p>
<p>2つのオブジェクトのうち、一方は頻繁に変更し、もう一方はめったに変更しない場合で、2つのオブジェクトが同じ局所性を持つキャッシュに載っている場合、よく変更するオブジェクトを変更しただけで、めったに変更しないオブジェクトも、メモリーとの同期が発生する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Data
{
    <span class="dt">int</span> counter ;
    <span class="dt">int</span> status ;
} ;</code></pre></div>
<p>ここで、<code>counter</code>は頻繁に変更するが、<code>status</code>はめったに変更しない場合、<code>counter</code>と<code>status</code>の間に適切なパディングを挿入することで、2つのオブジェクトが同じ局所性を持たないようにしたい。</p>
<p>この場合には、<code>std::hardware_destructive_interference_size</code>が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Data
{
    <span class="dt">int</span> counter ;
    <span class="bu">std::</span>byte padding[
        <span class="bu">std::</span>hardware_destructive_interference_size - <span class="kw">sizeof</span>(<span class="dt">int</span>)
    ] ;
    <span class="dt">int</span> status ;
} ;</code></pre></div>
<p>反対に、2つのオブジェクトを同一の局所性を持つキャッシュに載せたい場合、<code>std::hardware_constructive_interference_size</code>が使える。</p>
<p>ハードウェア干渉サイズは<code>&lt;new&gt;</code>ヘッダーで以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span>
        hardware_destructive_interference_size = 実装依存 ;
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span>
        hardware_constructive_interference_size = 実装依存 ;
}</code></pre></div>
<h2 id="stduncaught_exceptions">std::uncaught_exceptions</h2>
<p>C++14までは、まだ<code>catch</code>されていない例外がある場合は、<code>bool std::uncaught_exception()</code>で判定することができた。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    {
        <span class="cf">if</span> ( <span class="bu">std::</span>uncaught_exception() )
        {
            <span class="co">// デストラクターはスタックアンワインディング中に呼ばれた</span>
        }
        <span class="cf">else</span>
        {
            <span class="co">// 通常の破棄</span>
        }
    }
} ;

<span class="dt">int</span> main()
{
    {
        X x ;
    }<span class="co">// 通常の破棄</span>

    {
        X x ;
        <span class="cf">throw</span> <span class="dv">0</span> ;
    }<span class="co">// スタックアンワインディング中</span>

}</code></pre></div>
<p><code>bool std::uncaught_exception()</code>は、C++17では非推奨扱いになった。いずれ廃止される見込みだ。</p>
<p>廃止の理由としては、単に以下のような例で役に立たないからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    {
        <span class="cf">try</span> {
            <span class="co">// true</span>
            <span class="dt">bool</span> b = <span class="bu">std::</span>uncaught_exception() ;
        } <span class="cf">catch</span>( ... ) { }
    }
} ;</code></pre></div>
<p>このため、<code>int std::uncaught_exceptions()</code>が新たに追加された。この関数は現在<code>catch</code>されていない例外の個数を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    {
        <span class="cf">try</span> {
            <span class="cf">if</span> ( <span class="dt">int</span> x = <span class="bu">std::</span>uncaught_exceptions() ; x &gt; <span class="dv">1</span> )
            {
                <span class="co">// ネストされた例外</span>
            }
        } <span class="cf">catch</span>( ... )
    }

} ;</code></pre></div>
<h2 id="apply-tupleの要素を実引数に関数を呼び出す">apply : tupleの要素を実引数に関数を呼び出す</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> F, <span class="kw">class</span> Tuple&gt;
<span class="kw">constexpr</span> <span class="kw">decltype</span>(<span class="kw">auto</span>) apply(F&amp;&amp; f, Tuple&amp;&amp; t);</code></pre></div>
<p><code>std::apply</code>は<code>tuple</code>のそれぞれの要素を順番に実引数に渡して関数を呼び出すヘルパー関数だ。</p>
<p>ある要素数<code>N</code>の<code>tuple t</code>と関数オブジェクト<code>f</code>に対して、<code>apply( f, t )</code>は、<code>f( get&lt;0&gt;(t), get&lt;1&gt;(t), ... , get&lt;N-1&gt;(t) )</code>のように<code>f</code>を関数呼び出しする。</p>
<p><strong>例</strong>：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> f( Types ... args ) { }

<span class="dt">int</span> main()
{
    <span class="co">// int, int, int</span>
    <span class="bu">std::</span>tuple t1( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> ) ;

    <span class="co">// f( 1, 2, 3 )の関数呼び出し</span>
    <span class="bu">std::</span>apply( f, t1 ) ;

    <span class="co">// int, double, const char *</span>
    <span class="bu">std::</span>tuple t2( <span class="dv">123</span>, <span class="fl">4.56</span>, <span class="st">&quot;hello&quot;</span> ) ;

    <span class="co">// f( 123, 4.56, &quot;hello&quot; )の関数呼び出し</span>
    <span class="bu">std::</span>apply( f, t2 ) ;
}</code></pre></div>
<h2 id="searcher-検索">Searcher : 検索</h2>
<p>C++17では<code>&lt;functional&gt;</code>に<code>searcher</code>というライブラリが追加された。これは順序のあるオブジェクトの集合に、ある部分集合（パターン）が含まれているかどうかを検索するためのライブラリだ。その最も一般的な応用例は文字列検索となる。</p>
<p><code>searcher</code>の基本的な設計としては、クラスのオブジェクトを構築して、コンストラクターで検索したい部分集合（パターン）を与え、<code>operator ()</code>で部分集合が含まれているかを検索したい集合を与える。</p>
<p>この設計のライブラリが追加された理由は、パターンの検索のために何らかの事前の準備を状態として保持しておきたい検索アルゴリズムを実装するためだ。</p>
<h3 id="default_searcher">default_searcher</h3>
<p>クラス<code>std::default_searcher</code>は以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> ForwardIterator1,
            <span class="kw">class</span> BinaryPredicate = equal_to&lt;&gt; &gt;
<span class="kw">class</span> default_searcher {
<span class="kw">public</span>:
    <span class="co">// コンストラクター</span>
    default_searcher( 
        ForwardIterator1 pat_first, ForwardIterator1 pat_last
        , BinaryPredicate pred = BinaryPredicate() ) ;

    <span class="co">// operator ()</span>
    <span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator2&gt;
    pair&lt;ForwardIterator2, ForwardIterator2&gt;
    <span class="kw">operator</span>()(ForwardIterator2 first, ForwardIterator2 last) <span class="at">const</span> ;
} ;</code></pre></div>
<p>コンストラクターで部分集合を受け取る。<code>operator ()</code>で集合を受け取り、部分集合（パターン）と一致した場所をイテレーターのペアで返す。見つからない場合、イテレーターのペアは<code>[last, last)</code>になっている。</p>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string pattern(<span class="st">&quot;fox&quot;</span>) ;
    <span class="bu">std::</span>default_searcher
        fox_searcher( <span class="bu">std::</span>begin(pattern), <span class="bu">std::</span>end(pattern) ) ;

    <span class="bu">std::</span>string corpus = <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span> ;

    <span class="kw">auto</span>[first, last] = fox_searcher( <span class="bu">std::</span>begin(corpus),
                                      <span class="bu">std::</span>end(corpus) ) ;
    <span class="bu">std::</span>string fox( first, last ) ;
}</code></pre></div>
<p><code>default_searcher</code>の検索は、内部的に<code>std::search</code>が使われる。</p>
<h3 id="boyer_moore_searcher">boyer_moore_searcher</h3>
<p><code>std::boyer_moore_searcher</code>はBoyer-Moore文字列検索アルゴリズムを使って部分集合の検索を行う。</p>
<p>Boyer-Moore文字列検索アルゴリズムは極めて効率的な文字列検索のアルゴリズムだ。Boyer-MooreアルゴリズムはBob BoyerとStrother Mooreによって発明され、1977年のCommunications of the ACMで発表された。その内容は以下のURLで読むことができる。</p>
<p><a href="http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf" class="uri">http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf</a></p>
<p>愚直に実装した文字列検索アルゴリズムは検索すべき部分文字列（パターン）を検索対象の文字列（コーパス）から探す際、パターンの先頭の文字をコーパスの先頭から順に探していき、見つかれば2文字目以降も一致するかどうかを調べる。</p>
<p>Boyer-Mooreアルゴリズムはパターンの末尾の文字から調べる。文字が一致しなければ、パターンから絶対に不一致であるとわかっている長さだけの文字を比較せずに読み飛ばす。これによって効率的な文字列検索を実現している。</p>
<p>Boyer-Mooreアルゴリズムは事前にパターンのどの文字が不一致ならば何文字比較せずに読み飛ばせるかという情報を計算した2つのテーブルを生成する必要がある。このため、Boyer-Mooreアルゴリズムはメモリー使用量と検索前の準備時間というコストがかかる。そのコストは、より効率的な検索により相殺できる。特に、パターンが長い場合は効果的だ。</p>
<p>C++17に入るBoyer-Mooreアルゴリズムに基づく検索は、テンプレートを使った汎用的な<code>char</code>型のような状態数の少ない型に対しての実装だけではなく、ハッシュを使ったハッシュマップのようなデータ構造を使うことにより、任意の型に対応できる汎用的な設計になっている。</p>
<p>クラス<code>boyer_moore_searcher</code>は以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;
    <span class="kw">class</span> RandomAccessIterator1,
    <span class="kw">class</span> Hash = hash&lt;
        <span class="kw">typename</span> iterator_traits&lt;RandomAccessIterator1&gt;::<span class="dt">value_type</span>&gt;,
    <span class="kw">class</span> BinaryPredicate = equal_to&lt;&gt; &gt;
<span class="kw">class</span> boyer_moore_searcher {
<span class="kw">public</span>:
    <span class="co">// コンストラクター</span>
    boyer_moore_searcher(
        RandomAccessIterator1 pat_first,
        RandomAccessIterator1 pat_last,
        Hash hf = Hash(),
        BinaryPredicate pred = BinaryPredicate() ) ;

    <span class="co">// operator ()</span>
    <span class="kw">template</span> &lt;<span class="kw">class</span> RandomAccessIterator2&gt;
    pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    <span class="kw">operator</span>()( RandomAccessIterator2 first,
                RandomAccessIterator2 last) <span class="at">const</span>;
} ;</code></pre></div>
<p><code>boyer_moore_searcher</code>は、文字列以外にも適用できる汎用的な設計のため、ハッシュ関数を取る。<code>char</code>型のような取りうる状態数の少ない型以外が渡された場合は、<code>std::unordered_map</code>のようなメモリー使用量を削減できる何らかのデータ構造を使ってテーブルを構築する。</p>
<p>使い方は<code>default_searcher</code>とほとんど変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string pattern(<span class="st">&quot;fox&quot;</span>) ;
    <span class="bu">std::</span>boyer_moore_searcher
        fox_searcher( <span class="bu">std::</span>begin(pattern), <span class="bu">std::</span>end(pattern) ) ;

    <span class="bu">std::</span>string corpus = <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span> ;

    <span class="kw">auto</span>[first, last] = fox_searcher( <span class="bu">std::</span>begin(corpus),
        <span class="bu">std::</span>end(corpus) ) ;
    <span class="bu">std::</span>string fox( first, last ) ;
}</code></pre></div>
<h3 id="boyer_moore_horspool_searcher">boyer_moore_horspool_searcher</h3>
<p><code>std::boyer_moore_horspool_searcher</code>はBoyer-Moore-Horspool検索アルゴリズムを使って部分集合の検索を行う。Boyer-Moore-HorspoolアルゴリズムはNigel Horspoolによって1980年に発表された。</p>
<p><strong>参考</strong>：&quot;Practical fast searching in strings&quot; 1980</p>
<p>Boyer-Moore-Horspoolアルゴリズムは内部テーブルに使うメモリー使用量を削減しているが、最悪計算量の点でオリジナルのBoyer-Mooreアルゴリズムには劣っている。つまり、実行時間の増大を犠牲にしてメモリー使用量を削減したトレードオフなアルゴリズムと言える。</p>
<p>クラス<code>boyer_moore_horspool_searcher</code>の宣言は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;
    <span class="kw">class</span> RandomAccessIterator1,
    <span class="kw">class</span> Hash = hash&lt;
        <span class="kw">typename</span> iterator_traits&lt;RandomAccessIterator1&gt;::<span class="dt">value_type</span>&gt;,
    <span class="kw">class</span> BinaryPredicate = equal_to&lt;&gt; &gt;
<span class="kw">class</span> boyer_moore_horspool_searcher {
<span class="kw">public</span>:
    <span class="co">// コンストラクター</span>
    boyer_moore_horspool_searcher(
        RandomAccessIterator1 pat_first,
        RandomAccessIterator1 pat_last,
        Hash hf = Hash(),
        BinaryPredicate pred = BinaryPredicate() );

    <span class="co">// operator () </span>
    <span class="kw">template</span> &lt;<span class="kw">class</span> RandomAccessIterator2&gt;
    pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    <span class="kw">operator</span>()( RandomAccessIterator2 first,
                RandomAccessIterator2 last) <span class="at">const</span>;
} ;</code></pre></div>
<p>使い方は<code>boyer_moore__searcher</code>と変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string pattern(<span class="st">&quot;fox&quot;</span>) ;
    <span class="bu">std::</span>boyer_moore_horspool_searcher
        fox_searcher( <span class="bu">std::</span>begin(pattern), <span class="bu">std::</span>end(pattern) ) ;

    <span class="bu">std::</span>string corpus = <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span> ;

    <span class="kw">auto</span>[first, last] = fox_searcher(   <span class="bu">std::</span>begin(corpus),
                                        <span class="bu">std::</span>end(corpus) ) ;
    <span class="bu">std::</span>string fox( first, last ) ;
}</code></pre></div>
<h2 id="sample-乱択アルゴリズム">sample : 乱択アルゴリズム</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;

SampleIterator sample(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g) ;</code></pre></div>
<p>C++17で<code>&lt;algorithm&gt;</code>に追加された<code>std::sample</code>は、標本を確率的に選択するための乱択アルゴリズムだ。</p>
<p><code>[first, last)</code>は標本を選択する先の集合を指すイテレーター。<code>out</code>は標本を出力する先のイテレーター。<code>n</code>は選択する標本の個数。<code>g</code>は標本を選択するのに使う乱数生成器。戻り値は<code>out</code>。</p>
<p>ある要素の集合から、<code>n</code>個の要素を確率的に公平に選択したい場合に使うことができる。</p>
<h3 id="乱択アルゴリズム">乱択アルゴリズム</h3>
<p><code>std::sample</code>を使う前に、まず正しい乱択アルゴリズムについて学ぶ必要がある。乱択アルゴリズムについて詳しくは、Donald E. Knuthの <em>The Arf of Computer Programming</em> （以下TAOCP、邦訳はアスキードワンゴから同名の書名で出版されている）を参照。</p>
<p>ユーザーからの入力、計測した気象情報のデータ、サーバーへのアクセスログなど、世の中には膨大な量のデータが存在する。これらの膨大なデータをすべて処理するのではなく、標本を採取することによって、統計的にそれなりに信頼できる確率で正しい全体のデータを推定することができる。そのためには<span class="math inline">\(n\)</span>個の標本をバイアスがかからない方法で選択する必要がある。バイアスのかからない方法で<span class="math inline">\(n\)</span>個の標本を取り出すには、集合の先頭から<span class="math inline">\(n\)</span>個とか、1つおきに<span class="math inline">\(n\)</span>個といった方法で選択してはならない。それはバイアスがかかっている。</p>
<p>ある値の集合から、バイアスのかかっていない<span class="math inline">\(n\)</span>個の標本を得るには、集合のすべての値が等しい確率で選ばれた上で<span class="math inline">\(n\)</span>個を選択しなければならない。いったいどうすればいいのだろうか。</p>
<p><code>std::sample</code>を使えば、100個の値から10個の標本を得るのは、以下のように書くことが可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 100個の値の集合</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; pop(<span class="dv">100</span>) ;
    <span class="bu">std::</span>iota( <span class="bu">std::</span>begin(pop), <span class="bu">std::</span>end(pop), <span class="dv">0</span> ) ;

    <span class="co">// 標本を格納するコンテナー</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; out(<span class="dv">10</span>) ;

    <span class="co">// 乱数生成器</span>
    <span class="bu">std::</span>array&lt;<span class="bu">std::</span>uint32_t, <span class="kw">sizeof</span>(<span class="bu">std::</span>knuth_b)/<span class="dv">4</span>&gt; a ;
    <span class="bu">std::</span>random_device r ;
    <span class="bu">std::</span>generate( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), [&amp;]{ <span class="cf">return</span> r() ; } ) ;
    <span class="bu">std::</span>seed_seq seed( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a) ) ;
    <span class="bu">std::</span>knuth_b g( seed ) ;

    <span class="co">// 10個の標本を得る</span>
    sample( <span class="bu">std::</span>begin(pop), <span class="bu">std::</span>end(pop), <span class="bu">std::</span>begin(out), <span class="dv">10</span>, g ) ;

    <span class="co">// 標本を出力</span>
    <span class="bu">std::</span>copy(  <span class="bu">std::</span>begin(out), <span class="bu">std::</span>end(out),
                <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;, &quot;</span>) ) ;
}</code></pre></div>
<p>集合に含まれる値の数が<span class="math inline">\(N\)</span>個だとわかっているならば、それぞれの値について<span class="math inline">\(n/m\)</span>の確率で選ぶというのはどうだろうか。100個中10個を選ぶのであれば、<span class="math inline">\(1/10\)</span>の確率でそれぞれの値を標本として選択することになる。</p>
<p>この考えに基づく乱択アルゴリズムは以下のようになる。</p>
<ol style="list-style-type: decimal">
<li>集合の要素数を<span class="math inline">\(N\)</span>、選択すべき標本の数を<span class="math inline">\(n\)</span>, <span class="math inline">\(i\)</span>を0とする。</li>
<li>0ベースインデックスで<span class="math inline">\(i\)</span>番目の値を<span class="math inline">\(n/m\)</span>の確率で標本として選択する。</li>
<li><span class="math inline">\(i\)</span>をインクリメントする。</li>
<li><span class="math inline">\(i\ != N\)</span>ならばgoto 2。</li>
</ol>
<p>このアルゴリズムをコードで書くと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator sample(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    <span class="kw">auto</span> N = <span class="bu">std::</span>distance( first, last ) ;

    <span class="co">// 確率n/Nでtrueを返すベルヌーイ分布</span>
    <span class="dt">double</span> probability = <span class="dt">double</span>(n)/<span class="dt">double</span>(N) ;
    <span class="bu">std::</span>bernoulli_distribution d( probability ) ;

    <span class="co">// それぞれの値に対して</span>
    <span class="bu">std::</span>for_each( first, last,
        [&amp;]( <span class="kw">auto</span> &amp;&amp; value )
        {
            <span class="cf">if</span> ( d(g) )
            {<span class="co">// n/Nの確率で標本として選択する</span>
                *out = value ;
                ++out ;
            }
        } ) ;

    <span class="cf">return</span> out ;
}</code></pre></div>
<p>残念ながらこのアルゴリズムは正しく動かない。この例では、100個の値の集合から10個の標本を選択したい。しかし、選ばれる標本の数はプログラムの実行ごとに異なる。このアルゴリズムは、標本の数が平均的に10個選ばれることが期待できるが、運が悪いと0個や100個の標本が選ばれてしまう可能性がある。</p>
<p>ちなみに、TAOCP Vol. 2によれば、このとき選ばれる標本数の標準偏差は<span class="math inline">\(\sqrt{n(1-n/N)}\)</span>になる。</p>
<p>正しいアルゴリズムは、要素の集合のうちの<span class="math inline">\((t+1)\)</span>番目の要素は、すでに<span class="math inline">\(m\)</span>個の要素が標本として選ばれたとき、<span class="math inline">\((n-m)(N-t)\)</span>の確率で選ぶものだ。</p>
<h3 id="アルゴリズムs選択標本要素数がわかっている集合からの標本の選択">アルゴリズムS：選択標本、要素数がわかっている集合からの標本の選択</h3>
<p>KnuthのTAOCP Vol. 2では、アルゴリズムSと称して、要素数のわかっている集合から標本を選択する方法を解説している。</p>
<p>アルゴリズムSは以下のとおり。</p>
<p><span class="math inline">\(0 &lt; n \leq N\)</span> のとき、<span class="math inline">\(N\)</span>個の集合から<span class="math inline">\(n\)</span>個の標本をランダムに選択する。</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(t\)</span>, <span class="math inline">\(m\)</span>を0とする。<span class="math inline">\(t\)</span>はこれまでに処理した要素数、<span class="math inline">\(m\)</span>は標本として選択した要素数とする。</li>
<li><span class="math inline">\(0 \leq U \leq N - t\)</span>の範囲の乱数<span class="math inline">\(U\)</span>を生成する。</li>
<li><span class="math inline">\(U \geq n - m\)</span>であればgoto 5。</li>
<li>次の要素を標本として選択する。<span class="math inline">\(m\)</span>と<span class="math inline">\(t\)</span>をインクリメントする。<span class="math inline">\(m &lt; n\)</span>であれば、goto 2。そうでなければ標本は完了したのでアルゴリズムは終了する。</li>
<li>次の要素を標本として選択しない。<span class="math inline">\(t\)</span>をインクリメントする。goto 2。</li>
</ol>
<p>実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator
sample_s(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    <span class="co">// 1.</span>
    Distance t = <span class="dv">0</span> ;
    Distance m = <span class="dv">0</span> ;
    <span class="at">const</span> <span class="kw">auto</span> N = <span class="bu">std::</span>distance( first, last ) ;

    <span class="kw">auto</span> r = [&amp;]{
        <span class="bu">std::</span>uniform_int_distribution&lt;&gt; d(<span class="dv">0</span>, N-t) ;
        <span class="cf">return</span> d(g) ;
    } ;

    <span class="cf">while</span> ( m &lt; n  &amp;&amp; first != last )
    {
        <span class="co">// 2. 3.</span>
        <span class="cf">if</span> ( r() &gt;= n - m )
        {<span class="co">// 5.</span>
            ++t ;
            ++first ;
        }
        <span class="cf">else</span> { <span class="co">// 4.</span>
            *out = *first ;
            ++first ; ++out ;
            ++m ; ++t ;
        }
    }
    
    <span class="cf">return</span> out ;
}</code></pre></div>
<h3 id="アルゴリズムr保管標本要素数がわからない集合からの標本の選択">アルゴリズムR：保管標本、要素数がわからない集合からの標本の選択</h3>
<p>アルゴリズムSは集合の要素数が<span class="math inline">\(N\)</span>個であるとわかっている場合に、<span class="math inline">\(n\)</span>個の標本を選択するアルゴリズムだ。では、もし<span class="math inline">\(N\)</span>がわからない場合はどうすればいいのだろうか。</p>
<p>現実には<span class="math inline">\(N\)</span>がわからない状況がよくある。</p>
<ul>
<li>ユーザーからの入力</li>
<li>シーケンシャルアクセスしか提供しておらず全部読み込まなければ要素数のわからないテープデバイスからの入力</li>
<li>ガイガーカウンターからの入力</li>
</ul>
<p>このような要素数のわからない入力にアルゴリズムSを適用するには、まず一度全部入力を得て、全体の要素数を確定させた上で、全要素に対してアルゴリズムSを適用させるという2段階の方法を使うことができる。</p>
<p>しかし、1段階の要素の巡回だけで済ませたい。要素数のわからない入力を処理して、その時点で公平に選択された標本を得たい。</p>
<p>アルゴリズムRはそのような状況で使えるアルゴリズムだ。</p>
<p>アルゴリズムRでは、要素数のわからない要素の集合から<span class="math inline">\(n\)</span>個の標本を選択する。そのために標本として選択した要素を保管しておき、新しい入力が与えられるたびに、標本として選択するかどうかの判断をし、選択をするのであれば、保管しておいた既存の標本と置き換える。</p>
<p>アルゴリズムRは以下のとおり（このアルゴリズムはKnuth本とは違う）</p>
<p><span class="math inline">\(n &gt; 0\)</span>のとき、<span class="math inline">\(size \geq n\)</span>である未確定の<span class="math inline">\(size\)</span>個の要素数を持つ入力から、<span class="math inline">\(n\)</span>個の標本をランダムに選択する。標本の候補は<span class="math inline">\(n\)</span>個まで保管される。<span class="math inline">\(1 \leq j \leq n\)</span>のとき<span class="math inline">\(I[j]\)</span>は保管された標本を指す。</p>
<ol style="list-style-type: decimal">
<li>入力から最初の<span class="math inline">\(n\)</span>個を標本として選択し、保管する。<span class="math inline">\(1 \leq j \leq n\)</span>の範囲で<span class="math inline">\(I[j]\)</span>に<span class="math inline">\(j\)</span>番目の標本を保管する。<span class="math inline">\(t\)</span>の値を<span class="math inline">\(n\)</span>とする。<span class="math inline">\(I[1]\)</span>, ..., <span class="math inline">\(I[n]\)</span>は現在の標本を指す。<span class="math inline">\(t\)</span>は現在処理した入力の個数を指す。</li>
<li>入力の終わりであればアルゴリズムを終了する。</li>
<li><span class="math inline">\(t\)</span>をインクリメントする。<span class="math inline">\(1 \leq M \leq t\)</span>の範囲の乱数<span class="math inline">\(M\)</span>を生成する。<span class="math inline">\(M &gt; n\)</span> ならばgoto 5。</li>
<li>次の入力を<span class="math inline">\(I[M]\)</span>に保管する。goto 2。</li>
<li>次の入力を保管しない。goto 2。</li>
</ol>
<p>実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;

SampleIterator sample_r(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    Distance t = <span class="dv">0</span> ;

    <span class="kw">auto</span> result = out ;

    <span class="cf">for</span> ( ; (first != last) &amp;&amp; (t != n) ; ++first, ++t, ++result )
    {
        out[t] = *first ;
    }

    <span class="cf">if</span> ( t != n )
        <span class="cf">return</span> result ;


    <span class="kw">auto</span> I = [&amp;](Distance j) -&gt; <span class="kw">decltype</span>(<span class="kw">auto</span>) { <span class="cf">return</span> out[j<span class="dv">-1</span>] ; } ;

    <span class="cf">while</span> ( first != last )
    {
        ++t ;
        <span class="bu">std::</span>uniform_int_distribution&lt;Distance&gt; d( <span class="dv">1</span>, t ) ;
        <span class="kw">auto</span> M = d(g) ;

        <span class="cf">if</span> ( M &gt; n )
        {
            ++first ;
        }
        <span class="cf">else</span> {
            I(M) = *first ;
            ++first ;
        }
    }

    <span class="cf">return</span> result ;
}</code></pre></div>
<h3 id="cのsample">C++のsample</h3>
<p>ここまで説明したように、乱択アルゴリズムには2種類ある。入力の要素数がわかっている場合のアルゴリズムS（選択標本）と、入力の要素数がわからない場合のアルゴリズムR（保管標本）だ。</p>
<p>しかし、C++に追加された乱択アルゴリズムの関数テンプレートの宣言は、はじめに説明したように以下の1つしかない。並列アルゴリズムには対応していない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;
    <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
    <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator
sample(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g) ;</code></pre></div>
<p><code>[first, last)</code>は標本を選択する先の集合を指すイテレーター。<code>out</code>は標本を出力する先のイテレーター。<code>n</code>は選択する標本の個数。<code>g</code>は標本を選択するのに使う乱数生成器。戻り値は<code>out</code>。</p>
<p><code>sample</code>は<code>PopulationIterator</code>と<code>SampleIterator</code>のイテレーターカテゴリーによって、どちらのアルゴリズムを使うべきか判断している。</p>
<p>アルゴリズムS（選択標本）を使う場合、<code>PopulationIterator</code>は前方イテレーター、<code>SampleIterator</code>は出力イテレーターを満たさなければならない。</p>
<p>アルゴリズムR（保管標本）を使う場合、<code>PopulationIterator</code>は入力イテレーター、<code>SampleIterator</code>はランダムアクセスイテレーターを満たさなければならない。</p>
<p>これはどういうことかというと、要素数の取得のためには、入力元の<code>PopulationIterator [first, last)</code>から要素数を得る必要があり、そのためには<code>PopulationIterator</code>は前方イテレーターを満たしていなければならない。その場合、選択した標本はそのままイテレーターに出力すればいいので、出力先の<code>SampleIterator</code>は出力イテレーターを満たすだけでよい。</p>
<p>もし入力元の<code>PopulationIterator</code>が入力イテレーターしか満たさない場合、この場合は<code>PopulationIterator</code>の<code>[first, last)</code>から要素数を得ることができないので、要素数がわからないときに使えるアルゴリズムR（保管標本）を選択せざるを得ない。その場合、入力を処理するに連れて、新たに選択した標本が既存の標本を上書きするので、出力先の<code>SampleIterator</code>はランダムアクセスイテレーターである必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; input ;

    <span class="bu">std::</span>knuth_b g ;

    <span class="co">// PopulationIteratorは前方イテレーターを満たす</span>
    <span class="co">// SampleIteratorは出力イテレーターでよい</span>
    <span class="bu">std::</span>sample(    <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
                    <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout), <span class="dv">100</span>
                    g ) ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; sample(<span class="dv">100</span>) ;

    <span class="co">// PopulationIteratorは入力イテレーターしか満たさない</span>
    <span class="co">// SampleIteratorにはランダムアクセスイテレーターが必要</span>
    <span class="bu">std::</span>sample(
        <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin),
        <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;{},
        <span class="bu">std::</span>begin(sample), <span class="dv">100</span>, g ) ;

}</code></pre></div>
<p>注意が必要なこととして、C++の<code>sample</code>は入力元の<code>PopulationIterator</code>が前方イテレーター以上を満たす場合は、かならずアルゴリズムS（選択標本）を使うということだ。これはつまり、要素数を得るために<code>std::distance(first, last)</code>が行われるということを意味する。もしこの処理が非効率的なイテレーターを渡した場合、必要以上に非効率的なコードになってしまう。</p>
<p>たとえば以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; input(<span class="dv">10000</span>) ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; sample(<span class="dv">100</span>) ;
    <span class="bu">std::</span>knuth_b g ;

    <span class="bu">std::</span>sample(    <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
                    <span class="bu">std::</span>begin(sample), <span class="dv">100</span>, g ) ;
}</code></pre></div>
<p>以下のような意味を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; input(<span class="dv">10000</span>) ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; sample(<span class="dv">100</span>) ;
    <span class="bu">std::</span>knuth_b g ;

    <span class="bu">std::</span>size_t count = <span class="dv">0</span> ;
    
    <span class="co">// 要素数の得るためにイテレーターを回す</span>
    <span class="co">// 非効率的</span>
    <span class="cf">for</span>( <span class="kw">auto</span> &amp;&amp; e : input )
    { ++count ; }

    <span class="co">// 標本の選択のためにイテレーターを回す</span>
    <span class="cf">for</span> ( <span class="kw">auto</span> &amp;&amp; e : input )
    {<span class="co">/* 標本の選択 */</span>}
}</code></pre></div>
<p><code>std::list</code>のメンバー関数<code>size</code>は定数時間であることが保証されているため、このコードにおけるイテレーターを回すループは1回に抑えられる。しかし、<code>std::sample</code>は要素数を渡す実引数がないために要素数がイテレーターを全走査しなくてもわかっている場合でも、非効率的な処理を行わなければならない。</p>
<p>もしランダムアクセスイテレーター未満、前方イテレーター以上のイテレーターカテゴリーのイテレーターの範囲から標本を選択したい場合で、イテレーターの範囲の指す要素数があらかじめわかっている場合は、自前でアルゴリズムSを実装したほうが効率がよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator
sample_s(
    PopulationIterator first, PopulationIterator last,
    Distance size,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    <span class="co">// 1.</span>
    Distance t = <span class="dv">0</span> ;
    Distance m = <span class="dv">0</span> ;
    <span class="at">const</span> <span class="kw">auto</span> N = size ;

    <span class="kw">auto</span> r = [&amp;]{
        <span class="bu">std::</span>uniform_int_distribution&lt;&gt; d(<span class="dv">0</span>, N-t) ;
        <span class="cf">return</span> d(g) ;
    } ;

    <span class="cf">while</span> ( m &lt; n  &amp;&amp; first != last )
    {
        <span class="co">// 2. 3.</span>
        <span class="cf">if</span> ( r() &gt;= n - m )
        {<span class="co">// 5.</span>
            ++t ;
            ++first ;
        }
        <span class="cf">else</span> { <span class="co">// 4.</span>
            *out = *first ;
            ++first ; ++out ;
            ++m ; ++t ;
        }
    }
    
    <span class="cf">return</span> out ;
}</code></pre></div>
<h2 id="shared_ptrt-配列に対するshared_ptr">shared_ptr&lt;T[]&gt; : 配列に対するshared_ptr</h2>
<p>C++17では、<code>shared_ptr</code>が配列に対応した。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 配列対応のshared_ptr</span>
    <span class="bu">std::</span>shared_ptr&lt; <span class="dt">int</span> [] &gt; ptr( <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">5</span>] ) ;

    <span class="co">// operator []で配列に添字アクセスできる</span>
    ptr[<span class="dv">0</span>] = <span class="dv">42</span> ;

    <span class="co">// shared_ptrのデストラクターがdelete[]を呼び出す</span>
}</code></pre></div>
<h2 id="as_const-const性の付与">as_const: const性の付与</h2>
<p><code>as_const</code>はヘッダーファイル<code>&lt;utility&gt;</code>で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt; <span class="kw">constexpr</span> <span class="dt">add_const_t</span>&lt;T&gt;&amp; as_const(T&amp; t) <span class="kw">noexcept</span>
{
    <span class="cf">return</span> t ;
}</code></pre></div>
<p><code>as_const</code>は引数として渡した<code>lvalue</code>リファレンスを<code>const</code>な<code>lvalue</code>リファレンスにキャストする関数だ。<code>const</code>性を付与する手軽なヘルパー関数として使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp; ) {}
<span class="co">// 2、こちらを呼び出したい</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="at">const</span> &amp; ) { }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> x{} ;

    f(x) ; <span class="co">// 1</span>

    <span class="co">// constを付与する冗長な方法</span>
    <span class="dt">int</span> <span class="at">const</span> &amp; ref = x ;
    f(ref) ; <span class="co">// 2</span>

    <span class="co">// 簡潔</span>
    f( <span class="bu">std::</span>as_const(x) ) ; <span class="co">// 2</span>
}</code></pre></div>
<h2 id="make_from_tuple-tupleの要素を実引数にコンストラクターを呼び出す">make_from_tuple : tupleの要素を実引数にコンストラクターを呼び出す</h2>
<p><code>make_from_tuple</code>はヘッダーファイル<code>&lt;tuple&gt;</code>で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> Tuple&gt;
<span class="kw">constexpr</span> T make_from_tuple(Tuple&amp;&amp; t);</code></pre></div>
<p><code>apply</code>は<code>tuple</code>の要素を実引数に関数を呼び出すライブラリだが、<code>make_from_tuple</code>は<code>tuple</code>の要素を実引数にコンストラクターを呼び出すライブラリだ。</p>
<p>ある型<code>T</code>と要素数<code>N</code>の<code>tuple t</code>に対して、<code>make_from_tuple&lt;T&gt;(t)</code>は、<code>T</code>型を<code>T( get&lt;0&gt;(t), get&lt;1&gt;(t), ... , get&lt;N-1&gt;(t) )</code>のように構築して、構築した<code>T</code>型のオブジェクトを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X
{
    <span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
    T( Types ... ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// int, int, int</span>
    <span class="bu">std::</span>tuple t1(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) ;

    <span class="co">// X(1,2,3)</span>
    X x1 = <span class="bu">std::</span>make_from_tuple&lt;X&gt;( t1 ) 

    <span class="co">// int, double, const char *</span>
    <span class="bu">std::</span>tuple t2( <span class="dv">123</span>, <span class="fl">4.56</span>, <span class="st">&quot;hello&quot;</span> ) ;

    <span class="co">// X(123, 4.56, &quot;hello&quot;)</span>
    X x2 = <span class="bu">std::</span>make_from_tuple&lt;X&gt;( t2 ) ;
}</code></pre></div>
<h2 id="invoke-指定した関数を指定した実引数で呼び出す">invoke : 指定した関数を指定した実引数で呼び出す</h2>
<p><code>invoke</code>はヘッダーファイル<code>&lt;functional&gt;</code>で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> F, <span class="kw">class</span>... Args&gt;
<span class="dt">invoke_result_t</span>&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)
<span class="kw">noexcept</span>(is_nothrow_invocable_v&lt;F, Args...&gt;);</code></pre></div>
<p><code>invoke( f, t1, t2, ... , tN )</code>は、関数<code>f</code>を<code>f( a1, a2, ... , aN )</code>のように呼び出す。</p>
<p>より正確には、C++標準規格の<code>INVOKE(f, t1, t2, ... , tN)</code>と同じ規則で呼び出す。これにはさまざまな規則があり、たとえばメンバー関数へのポインターやデータメンバーへのポインター、またその場合に与えるクラスへのオブジェクトがリファレンスかポインターか<code>reference_wrapper</code>かによっても異なる。その詳細はここでは解説しない。</p>
<p><code>INVOKE</code>は<code>std::function</code>や<code>std::bind</code>でも使われている規則なので、標準ライブラリと同じ挙動ができるようになると覚えておけばよい。</p>
<p><strong>例</strong>：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> ) { }

<span class="kw">struct</span> S
{
    <span class="dt">void</span> f( <span class="dt">int</span> ) ;
    <span class="dt">int</span> data ;
} ;

<span class="dt">int</span> main()
{
    <span class="co">// f( 1 ) </span>
    <span class="bu">std::</span>invoke( f, <span class="dv">1</span> ) ;

    S s ;

    <span class="co">// (s.*&amp;S::f)(1)</span>
    <span class="bu">std::</span>invoke( &amp;S::f, s, <span class="dv">1</span> ) ;
    <span class="co">// ((*&amp;s).*&amp;S::f)(1)</span>
    <span class="bu">std::</span>invoke( &amp;S::f, &amp;s, <span class="dv">1</span> ) ;
    <span class="co">// s.*&amp;S::data </span>
    <span class="bu">std::</span>invoke( &amp;S::data, s ) ;
}</code></pre></div>
<h2 id="not_fn-戻り値の否定ラッパー">not_fn : 戻り値の否定ラッパー</h2>
<p><code>not_fn</code>はヘッダーファイル<code>&lt;functional&gt;</code>で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> F&gt; unspecified not_fn(F&amp;&amp; f);</code></pre></div>
<p>関数オブジェクト<code>f</code>に対して<code>not_fn(f)</code>を呼び出すと、戻り値として何らかの関数オブジェクトが返ってくる。その関数オブジェクトを呼び出すと、実引数を<code>f</code>に渡して<code>f</code>を関数呼び出しして、戻り値を<code>operator !</code>で否定して返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="kw">auto</span> r1 = <span class="bu">std::</span>not_fn( []{ <span class="cf">return</span> <span class="kw">true</span> ; } ) ;

    r1() ; <span class="co">// false</span>

    <span class="kw">auto</span> r2 = <span class="bu">std::</span>not_fn( []( <span class="dt">bool</span> b ) { <span class="cf">return</span> b ; } ) ;

    r2(<span class="kw">true</span>) ; <span class="co">// false</span>
}</code></pre></div>
<p>すでに廃止予定になった<code>not1</code>, <code>not2</code>の代替品。</p>
<h2 id="メモリー管理アルゴリズム">メモリー管理アルゴリズム</h2>
<p>C++17ではヘッダーファイル<code>&lt;memory&gt;</code>にメモリー管理用のアルゴリズムが追加された。</p>
<h3 id="addressof">addressof</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt; <span class="kw">constexpr</span> T* addressof(T&amp; r) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>addressof</code>はC++17以前からもある。<code>addressof(r)</code>は<code>r</code>のポインターを取得する。たとえ、<code>r</code>の型が<code>operator &amp;</code>をオーバーロードしていても正しいポインターを取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    S * <span class="kw">operator</span> &amp;() <span class="at">const</span> <span class="kw">noexcept</span>
    { <span class="cf">return</span> <span class="kw">nullptr</span> ; } 
} ;

<span class="dt">int</span> main()
{
    S s ;

    <span class="co">// nullptr</span>
    S * p1 = &amp; s ;
    <span class="co">// 妥当なポインター</span>
    S * p2 = <span class="bu">std::</span>addressof(s) ;

}</code></pre></div>
<h3 id="uninitialized_default_construct">uninitialized_default_construct</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator&gt;
<span class="dt">void</span> uninitialized_default_construct(
    ForwardIterator first, ForwardIterator last);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size&gt;
ForwardIterator uninitialized_default_construct_n(
    ForwardIterator first, Size n);</code></pre></div>
<p><code>[first, last)</code>の範囲、もしくは<code>first</code>から<code>n</code>個の範囲の未初期化のメモリーを<code>typename iterator_traits&lt;ForwardIterator&gt;::value_type</code>でデフォルト初期化する。2つ目のアルゴリズムは<code>first</code>から<code>n</code>個をデフォルト初期化する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>shared_ptr&lt;<span class="dt">void</span>&gt; raw_ptr
    (   ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(<span class="bu">std::</span>string) * <span class="dv">10</span> ),
        [](<span class="dt">void</span> * ptr){ ::<span class="kw">operator</span> <span class="kw">delete</span>(ptr) ; } ) ;
 
    <span class="bu">std::</span>string * ptr = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>string *&gt;( raw_ptr.get() ) ;

    <span class="bu">std::</span>uninitialized_default_construct_n( ptr, <span class="dv">10</span> ) ;
    <span class="bu">std::</span>destroy_n( ptr, <span class="dv">10</span> ) ;
}</code></pre></div>
<h3 id="uninitialized_value_construct">uninitialized_value_construct</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator&gt;
<span class="dt">void</span> uninitialized_value_construct(
    ForwardIterator first, ForwardIterator last);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size&gt;
ForwardIterator uninitialized_value_construct_n(
    ForwardIterator first, Size n);</code></pre></div>
<p>使い方は<code>uninitialized_default_construct</code>と同じ。ただし、こちらはデフォルト初期化ではなく値初期化する。</p>
<h3 id="uninitialized_copy">uninitialized_copy</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> ForwardIterator&gt;
ForwardIterator
uninitialized_copy( InputIterator first, InputIterator last,
                    ForwardIterator result);

<span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Size, <span class="kw">class</span> ForwardIterator&gt;
ForwardIterator
uninitialized_copy_n(   InputIterator first, Size n,
                        ForwardIterator result);</code></pre></div>
<p><code>[first, last)</code>の範囲、もしくは<code>first</code>から<code>n</code>個の範囲の値を、<code>result</code>の指す未初期化のメモリーにコピー構築する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; input(<span class="dv">10</span>, <span class="st">&quot;hello&quot;</span>) ;

    <span class="bu">std::</span>shared_ptr&lt;<span class="dt">void</span>&gt; raw_ptr
    (   ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(<span class="bu">std::</span>string) * <span class="dv">10</span> ),
        [](<span class="dt">void</span> * ptr){ ::<span class="kw">operator</span> <span class="kw">delete</span>(ptr) ; } ) ;
 
    <span class="bu">std::</span>string * ptr = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>string *&gt;( raw_ptr.get() ) ;


    <span class="bu">std::</span>uninitialized_copy_n( <span class="bu">std::</span>begin(input), <span class="dv">10</span>, ptr ) ;
    <span class="bu">std::</span>destroy_n( ptr, <span class="dv">10</span> ) ;
}</code></pre></div>
<h3 id="uninitialized_move">uninitialized_move</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> ForwardIterator&gt;
ForwardIterator
uninitialized_move( InputIterator first, InputIterator last,
                    ForwardIterator result);

<span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Size, <span class="kw">class</span> ForwardIterator&gt;
pair&lt;InputIterator, ForwardIterator&gt;
uninitialized_move_n(   InputIterator first, Size n,
                        ForwardIterator result);</code></pre></div>
<p>使い方は<code>uninitialized_copy</code>と同じ。ただしこちらはコピーではなくムーブする。</p>
<h3 id="uninitialized_fill">uninitialized_fill</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> T&gt;
<span class="dt">void</span> uninitialized_fill(
    ForwardIterator first, ForwardIterator last,
    <span class="at">const</span> T&amp; x);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size, <span class="kw">class</span> T&gt;
ForwardIterator uninitialized_fill_n(
    ForwardIterator first, Size n,
    <span class="at">const</span> T&amp; x);</code></pre></div>
<p><code>[first, last)</code>の範囲、もしくは<code>first</code>から<code>n</code>個の範囲の未初期化のメモリーを、コンストラクターに実引数<code>x</code>を与えて構築する。</p>
<h3 id="destory">destory</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="dt">void</span> destroy_at(T* location);</code></pre></div>
<p><code>location-&gt;~T()</code>を呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator&gt;
<span class="dt">void</span> destroy(ForwardIterator first, ForwardIterator last);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size&gt;
ForwardIterator destroy_n(ForwardIterator first, Size n);</code></pre></div>
<p><code>[first, last)</code>の範囲、もしくは<code>first</code>から<code>n</code>個の範囲に<code>destroy_at</code>を呼び出す。</p>
<h2 id="shared_ptrweak_type">shared_ptr::weak_type</h2>
<p>C++17では<code>shared_ptr</code>に<code>weak_type</code>というネストされた型名が追加された。これは<code>shared_ptr</code>に対する<code>weak_ptr</code>の<code>typedef</code>名となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> shared_ptr
{
    <span class="kw">using</span> <span class="dt">weak_type</span> = weak_ptr&lt;T&gt; ;
} ;

}</code></pre></div>
<p><strong>使い方</strong>：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Shared_ptr &gt;
<span class="dt">void</span> f( Shared_ptr sptr )
{
    <span class="co">// C++14</span>
    <span class="kw">auto</span> wptr1 = <span class="bu">std::</span>weak_ptr&lt;
                    <span class="kw">typename</span> Shared_ptr::<span class="dt">element_type</span>
                &gt;( sptr ) ;

    <span class="co">// C++17</span>
    <span class="kw">auto</span> wptr2 = <span class="kw">typename</span> Shared_ptr::<span class="dt">weak_type</span>( sptr ) ;
}</code></pre></div>
<h2 id="void_t">void_t</h2>
<p>ヘッダーファイル<code>&lt;type_traits&gt;</code>で定義されている<code>void_t</code>は以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {

<span class="kw">template</span> &lt; <span class="kw">class</span> ... &gt;
<span class="kw">using</span> <span class="dt">void_t</span> = <span class="dt">void</span> ;

}</code></pre></div>
<p><code>void_t</code>は任意個の型をテンプレート実引数として受け取る<code>void</code>型だ。この性質はテンプレートメタプログラミングにおいてとても便利なので、標準ライブラリに追加された。</p>
<h2 id="bool_constant">bool_constant</h2>
<p>ヘッダーファイル<code>&lt;type_traits&gt;</code>に<code>bool_constant</code>が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">bool</span> B&gt;
<span class="kw">using</span> bool_constant = integral_constant&lt;<span class="dt">bool</span>, B&gt;;

<span class="kw">using</span> <span class="dt">true_type</span> = bool_constant&lt;<span class="kw">true</span>&gt;;
<span class="kw">using</span> <span class="dt">false_type</span> = bool_constant&lt;<span class="kw">false</span>&gt;;</code></pre></div>
<p>今まで<code>integral_constant</code>を使っていた場面で特に<code>bool</code>だけが必要な場面では、C++17以降は単に<code>std::true_type</code>か<code>std::false_type</code>と書くだけでよくなる。</p>
<h2 id="type_traits">type_traits</h2>
<p>C++17では<code>&lt;type_traits&gt;</code>に機能追加が行われた。</p>
<h3 id="変数テンプレート版traits">変数テンプレート版traits</h3>
<p>C++17では、既存の<code>traits</code>に変数テンプレートを利用した<code>_v</code>版が追加された。</p>
<p>たとえば、<code>is_integral&lt;T&gt;::value</code>と書く代わりに<code>is_integral_v&lt;T&gt;</code>と書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T x )
{
    <span class="kw">constexpr</span> <span class="dt">bool</span> b1 = <span class="bu">std::</span>is_integral&lt;T&gt;::value ; <span class="co">// データメンバー</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b2 = <span class="bu">std::</span>is_integral_v&lt;T&gt; ; <span class="co">// 変数テンプレート</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b3 = <span class="bu">std::</span>is_integral&lt;T&gt;{} ; <span class="co">// operator bool()</span>
}</code></pre></div>
<h3 id="論理演算traits">論理演算traits</h3>
<p>C++17ではクラステンプレート<code>conjunction</code>, <code>disjunction</code>, <code>negation</code>が追加された。これはテンプレートメタプログラミングで論理積、論理和、否定を手軽に扱うための<code>traits</code>だ。</p>
<h4 id="conjunction-論理積">conjunction : 論理積</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span>... B&gt; <span class="kw">struct</span> conjunction;</code></pre></div>
<p>クラステンプレート<code>conjunction&lt;B1, B2, ..., BN&gt;</code>はテンプレート実引数<code>B1</code>, <code>B2</code>, ..., <code>BN</code>に論理積を適用する。<code>conjunction</code>はそれぞれのテンプレート実引数<code>Bi</code>に対して、<code>bool(Bi::value)</code>が<code>false</code>となる最初の型を基本クラスに持つか、あるいは最後の<code>BN</code>を基本クラスに持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// is_void&lt;void&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t1 =
        conjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;, is_integral&lt;<span class="dt">int</span>&gt;,
            is_void&lt;<span class="dt">void</span>&gt; &gt; ;

    <span class="co">// is_integral&lt;double&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t2 =
        conjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;, is_integral&lt;<span class="dt">double</span>&gt;,
            is_void&lt;<span class="dt">void</span>&gt; &gt; ;

}</code></pre></div>
<h4 id="disjunction-論理和">disjunction : 論理和</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span>... B&gt; <span class="kw">struct</span> disjunction;</code></pre></div>
<p>クラステンプレート<code>disjunction&lt;B1, B2, ..., BN&gt;</code>はテンプレート実引数<code>B1</code>, <code>B2</code>, ..., <code>BN</code>に論理和を適用する。<code>disjunction</code>はそれぞれのテンプレート実引数<code>Bi</code>に対して、<code>bool(Bi::value)</code>が<code>true</code>となる最初の型を基本クラスに持つか、あるいは最後の<code>BN</code>を基本クラスに持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// is_same&lt;int,int&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t1 =
        disjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;, is_integral&lt;<span class="dt">int</span>&gt;,
            is_void&lt;<span class="dt">void</span>&gt; &gt; ;

    <span class="co">// is_void&lt;int&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t2 =
        disjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">double</span>&gt;, is_integral&lt;<span class="dt">double</span>&gt;,
            is_void&lt;<span class="dt">int</span>&gt; &gt; ;
}</code></pre></div>
<h3 id="negation-否定">negation : 否定</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> B&gt; <span class="kw">struct</span> negation;</code></pre></div>
<p>クラステンプレート<code>negation&lt;B&gt;</code>は<code>B</code>に否定を適用する。<code>negation</code>は基本クラスとして<code>bool_constant&lt;!bool(B::value)&gt;</code>を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b1 = negation&lt; <span class="dt">true_type</span> &gt;::value ;
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b2 = negation&lt; <span class="dt">false_type</span> &gt;::value ; 
}</code></pre></div>
<h3 id="is_invocable-呼び出し可能か確認するtraits">is_invocable : 呼び出し可能か確認するtraits</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_invocable;

<span class="kw">template</span> &lt;<span class="kw">class</span> R, <span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_invocable_r;

<span class="kw">template</span> &lt;<span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_nothrow_invocable;

<span class="kw">template</span> &lt;<span class="kw">class</span> R, <span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_nothrow_invocable_r;</code></pre></div>
<p><code>is_invocable</code>はテンプレート実引数で与えられた型<code>Fn</code>がパラメーターパック<code>ArgTypes</code>をパック展開した結果を実引数に関数呼び出しできるかどうか、そしてその戻り値は<code>R</code>へ暗黙変換できるかどうかを確認する<code>traits</code>だ。呼び出せるのであれば<code>true_type</code>, そうでなければ<code>false_type</code>を基本クラスに持つ。</p>
<p><code>is_invocable</code>は関数呼び出しした結果の戻り値の型については問わない。</p>
<p><code>is_invocable_r</code>は呼び出し可能性に加えて、関数呼び出しした結果の戻り値の型が<code>R</code>へ暗黙変換できることが確認される。</p>
<p><code>is_nothrow_invocable</code>と<code>is_nothrow_invocable_r</code>は、関数呼び出し（および戻り値型<code>R</code>への暗黙変換）が無例外保証されていることも確認する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span>, <span class="dt">double</span> ) ;

<span class="dt">int</span> main()
{
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b1 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">double</span> &gt;{} ;
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b2 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">int</span> &gt;{} ;

    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b3 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span> &gt;{} ;
    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b4 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="bu">std::</span>string &gt;{} ;
    
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b5 = 
        <span class="bu">std::</span>is_invocable_r&lt; <span class="dt">int</span>, <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">double</span> &gt;{} ;
    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b6 =
        <span class="bu">std::</span>is_invocable_r&lt; <span class="dt">double</span>, <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">double</span> &gt;{} ;
}</code></pre></div>
<h3 id="has_unique_object_representations-同値の内部表現が同一か確認するtraits">has_unique_object_representations : 同値の内部表現が同一か確認するtraits</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">struct</span> has_unique_object_representations ;</code></pre></div>
<p><code>has_unique_object_representations&lt;T&gt;</code>は、<code>T</code>型がトリビアルにコピー可能で、かつ<code>T</code>型の同値である2つのオブジェクトの内部表現が同じ場合に、<code>true</code>を返す。</p>
<p><code>false</code>を返す例としては、オブジェクトがパディング（padding）と呼ばれるアライメント調整などのための値の表現に影響しないストレージ領域を持つ場合だ。パディングビットの値は同値に影響しないので、<code>false</code>を返す。</p>
<p>たとえば以下のようなクラス<code>X</code>は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="bu">std::</span>uint8_t a ;
    <span class="bu">std::</span>uint32_t b ;
} ;</code></pre></div>
<p>ある実装においては、4バイトにアライメントする必要があり、そのオブジェクトの本当のレイアウトは以下のようになっているかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="bu">std::</span>uint8_t a ;

    <span class="bu">std::</span>byte unused_padding[<span class="dv">3</span>] ;

    <span class="bu">std::</span>uint32_t b ;
} ;</code></pre></div>
<p>この場合、<code>unused_padding</code>の値には意味がなく、クラス<code>X</code>の同値比較には用いられない。この場合、<code>std::has_unique_representations_v&lt;X&gt;</code>は<code>false</code>になる。</p>
<h3 id="is_nothrow_swappable-無例外swap可能か確認するtraits">is_nothrow_swappable : 無例外swap可能か確認するtraits</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">struct</span> is_nothrow_swappable;

<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U&gt;
<span class="kw">struct</span> is_nothrow_swappable_with;</code></pre></div>
<p><code>is_nothrow_swappable&lt;T&gt;</code>は<code>T</code>型が<code>swap</code>で例外を投げないときに<code>true</code>を返す。</p>
<p><code>is_nothrow_swappable_with&lt;T, U&gt;</code>は、<code>T</code>型と<code>U</code>型を相互に<code>swap</code>するときに例外を投げないときに<code>true</code>を返す。</p>
<h2 id="コンテナーで不完全型のサポート">コンテナーで不完全型のサポート</h2>
<p><strong>注意</strong>：この説明は上級者向けだ。</p>
<p>C++17では以下のコードが合法になった。このコードの挙動はC++14までは実装依存であった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="bu">std::</span>vector&lt;X&gt; v ;
    <span class="bu">std::</span>list&lt;X&gt; l ;
    <span class="bu">std::</span>forward_list&lt;X&gt; f ;
} ;</code></pre></div>
<p>クラスはクラス定義の終了である<code>}</code>を持って完全型となる。クラススコープに注入されたクラス名は、クラス定義の中ではまだ完全型ではない。不完全型をコンテナーの要素型に指定した場合の挙動は、C++14までは規定されていなかった。</p>
<p>C++17では、<code>vector</code>, <code>list</code>, <code>forward_list</code>に限り、要素型に一時的に不完全型を許すようになった。実際にコンテナーを使う際には完全型になっていなければならない。</p>
<h2 id="emplaceの戻り値">emplaceの戻り値</h2>
<p>C++17ではシーケンスコンテナーの<code>emplace_front</code>/<code>emplace_back</code>, <code>queue</code>と<code>stack</code>の<code>emplace</code>が構築した要素へのリファレンスを返すように変更された。</p>
<p>そのため、C++14では以下のように書いていたコードが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    v.emplace_back(<span class="dv">0</span>) ; <span class="co">// void</span>
    <span class="dt">int</span> value = v.back() ;
}</code></pre></div>
<p>以下のように書けるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="dt">int</span> value = v.emplace_back(<span class="dv">0</span>) ;
}</code></pre></div>
<h2 id="mapとunordered_mapの変更">mapとunordered_mapの変更</h2>
<p><code>map</code>と<code>unordered_map</code>に、<code>try_emplace</code>と<code>insert_or_assign</code>という2つのメンバー関数が入った。このメンバー関数は<code>multi_map</code>と<code>unordered_multi_map</code>には追加されていない。</p>
<h3 id="try_emplace">try_emplace</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Args&gt;
pair&lt;iterator, <span class="dt">bool</span>&gt;
try_emplace(<span class="at">const</span> <span class="dt">key_type</span>&amp; k, Args&amp;&amp;... args);

<span class="kw">template</span> &lt;<span class="kw">class</span>... Args&gt;
iterator
try_emplace(
    const_iterator hint,
    <span class="at">const</span> <span class="dt">key_type</span>&amp; k, Args&amp;&amp;... args);</code></pre></div>
<p>従来の<code>emplace</code>は、キーに対応する要素が存在しない場合、要素が<code>args</code>から<code>emplace</code>構築されて追加される。もし、キーに対応する要素が存在する場合、要素は追加されない。要素が追加されないとき、<code>args</code>がムーブされるかどうかは実装定義である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="bu">std::</span>unique_ptr&lt;<span class="dt">int</span>&gt; &gt; m ;

    <span class="co">// すでに要素が存在する</span>
    m[<span class="dv">0</span>] = <span class="kw">nullptr</span> ;

    <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="co">// emplaceは失敗する</span>
    <span class="kw">auto</span> [iter, is_emplaced] = m.emplace( <span class="dv">0</span>, <span class="bu">std::</span>move(ptr) ) ;

    <span class="co">// 結果は実装により異なる</span>
    <span class="co">// ptrはムーブされているかもしれない</span>
    <span class="dt">bool</span> b = ( ptr != <span class="kw">nullptr</span> ) ;
}</code></pre></div>
<p>この場合、実際に<code>map</code>に要素は追加されていないのに、<code>ptr</code>はムーブされてしまうかもしれない。</p>
<p>このため、C++17では、要素が追加されなかった場合<code>args</code>はムーブされないことが保証される<code>try_emplace</code>が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="bu">std::</span>unique_ptr&lt;<span class="dt">int</span>&gt; &gt; m ;

    <span class="co">// すでに要素が存在する</span>
    m[<span class="dv">0</span>] = <span class="kw">nullptr</span> ;

    <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="co">// emplaceは失敗する</span>
    <span class="kw">auto</span> [iter, is_emplaced] = m.emplace( <span class="dv">0</span>, <span class="bu">std::</span>move(ptr) ) ;

    <span class="co">// trueであることが保証される</span>
    <span class="co">// ptrはムーブされていない</span>
    <span class="dt">bool</span> b = ( ptr != <span class="kw">nullptr</span> ) ;
}</code></pre></div>
<h3 id="insert_or_assign">insert_or_assign</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> M&gt;
pair&lt;iterator, <span class="dt">bool</span>&gt;
insert_or_assign(<span class="at">const</span> <span class="dt">key_type</span>&amp; k, M&amp;&amp; obj);

<span class="kw">template</span> &lt;<span class="kw">class</span> M&gt;
iterator
insert_or_assign(
    const_iterator hint,
    <span class="at">const</span> <span class="dt">key_type</span>&amp; k, M&amp;&amp; obj);</code></pre></div>
<p><code>insert_or_assign</code>は<code>key</code>に連想された要素が存在する場合は要素を代入し、存在しない場合は要素を追加する。<code>operator []</code>との違いは、要素が代入されたか追加されたかが、戻り値の<code>pair</code>の<code>bool</code>でわかるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; m ;
    m[<span class="dv">0</span>] = <span class="dv">0</span> ;

    {
        <span class="co">// 代入</span>
        <span class="co">// is_insertedはfalse</span>
        <span class="kw">auto</span> [iter, is_inserted] = m.insert_or_assign( <span class="dv">0</span>, <span class="dv">1</span> ) ;
    }

    {
        <span class="co">// 追加</span>
        <span class="co">// is_insertedはtrue</span>
        <span class="kw">auto</span> [iter, is_inserted] = m.insert_or_assign( <span class="dv">1</span>, <span class="dv">1</span> ) ;
    }
}</code></pre></div>
<h2 id="連想コンテナーへのsplice操作">連想コンテナーへのsplice操作</h2>
<p>C++17では、連想コンテナーと非順序連想コンテナーで<code>splice</code>操作がサポートされた。</p>
<p>対象のコンテナーは<code>map</code>, <code>set</code>, <code>multimap</code>, <code>multiset</code>, <code>unordered_map</code>, <code>unordered_set</code>, <code>unordered_multimap</code>, <code>unordered_multiset</code>だ。</p>
<p><code>splice</code>操作とは<code>list</code>で提供されている操作で、アロケーター互換の<code>list</code>のオブジェクトの要素をストレージと所有権ごと別のオブジェクトに移動する機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    a.splice( <span class="bu">std::</span>end(a), b, <span class="bu">std::</span>begin(b) ) ;

    <span class="co">// aは{1,2,3,4}</span>
    <span class="co">// bは{5,6}</span>

    b.splice( <span class="bu">std::</span>end(b), a ) ;

    <span class="co">// aは{}</span>
    <span class="co">// bは{5,6,1,2,3,4}</span>

}</code></pre></div>
<p>連想コンテナーでは、ノードハンドルという仕組みを用いて、コンテナーのオブジェクトから要素の所有権をコンテナーの外に出す仕組みで、<code>splice</code>操作を行う。</p>
<h3 id="merge">merge</h3>
<p>すべての連想コンテナーと非順序連想コンテナーは、メンバー関数<code>merge</code>を持っている。コンテナー<code>a</code>, <code>b</code>がアロケーター互換のとき、<code>a.merge(b)</code>は、コンテナー<code>b</code>の要素の所有権をすべてコンテナー<code>a</code>に移す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="co">// bの要素をすべてaに移す</span>
    a.merge(b) ;

    <span class="co">// aは{1,2,3,4,5,6}</span>
    <span class="co">// bは{}</span>
}</code></pre></div>
<p>もし、キーの重複を許さないコンテナーの場合で、値が重複した場合、重複した要素は移動しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    a.merge(b) ;

    <span class="co">// aは{1,2,3,4,5,6}</span>
    <span class="co">// bは{1,2,3}</span>

}</code></pre></div>
<p><code>merge</code>によって移動された要素を指すポインターとイテレーターは、要素の移動後も妥当である。ただし、所属するコンテナーのオブジェクトが変わる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;


    <span class="kw">auto</span> iterator = <span class="bu">std::</span>begin(b) ;
    <span class="kw">auto</span> pointer = &amp;*iterator ;

    a.merge(b) ;

    <span class="co">// iteratorとpointerはまだ妥当</span>
    <span class="co">// ただし要素はaに所属する</span>
}</code></pre></div>
<h3 id="ノードハンドル">ノードハンドル</h3>
<p>ノードハンドルとは、コンテナーオブジェクトから要素を構築したストレージの所有権を切り離す機能だ。</p>
<p>ノードハンドルの型は、各コンテナーのネストされた型名<code>node_type</code>となる。たとえば<code>std::set&lt;int&gt;</code>のノードハンドル型は、<code>std::set&lt;int&gt;::node_type</code>となる。</p>
<p>ノードハンドルは以下のようなメンバーを持っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> node_handle
{
<span class="kw">public</span> :
    <span class="co">// ネストされた型名</span>
    <span class="kw">using</span> <span class="dt">value_type</span> = ... ;        <span class="co">// set限定、要素型</span>
    <span class="kw">using</span> <span class="dt">key_type</span> = ... ;          <span class="co">// map限定、キー型</span>
    <span class="kw">using</span> <span class="dt">mapped_type</span> = ... ;       <span class="co">// map限定、マップ型</span>
    <span class="kw">using</span> <span class="dt">allocator_type</span> = ... ;    <span class="co">// アロケーターの型</span>

    <span class="co">// デフォルトコンストラクター</span>
    <span class="co">// ムーブコンストラクター</span>
    <span class="co">// ムーブ代入演算子</span>


    <span class="co">// 値へのアクセス</span>
    <span class="dt">value_type</span> &amp; value() <span class="at">const</span> ;   <span class="co">// set限定</span>
    <span class="dt">key_type</span> &amp; key() <span class="at">const</span> ;        <span class="co">// map限定</span>
    <span class="dt">mapped_type</span> &amp; mapped() <span class="at">const</span> ;  <span class="co">// map限定</span>

    <span class="co">// アロケーターへのアクセス</span>
    <span class="dt">allocator_type</span> get_allocator() <span class="at">const</span> ;

    <span class="co">// 空かどうかの判定</span>
    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span> ;
    <span class="dt">bool</span> empty() <span class="at">const</span> <span class="kw">noexcept</span> ;

    <span class="dt">void</span> swap( node_handle &amp; ) ;
} ;</code></pre></div>
<p><code>set</code>のノードハンドルはメンバー関数<code>value</code>で値を得る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n = c.extract(<span class="dv">2</span>) ;

    <span class="co">// n.value() == 2</span>
    <span class="co">// cは{1,3}</span>
}</code></pre></div>
<p><code>map</code>のノードハンドルはメンバー関数<code>key</code>と<code>mapped</code>でそれぞれの値を得る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; m =
    {
        {<span class="dv">1</span>,<span class="dv">1</span>}, {<span class="dv">2</span>,<span class="dv">2</span>}, {<span class="dv">3</span>,<span class="dv">3</span>}
    } ;

    <span class="kw">auto</span> n = m.extract(<span class="dv">2</span>) ;

    <span class="co">// n.key() == 2 </span>
    <span class="co">// n.mapped() == 2</span>
    <span class="co">// mは{{1,1},{3,3}}</span>

}</code></pre></div>
<p>ノードハンドルはノードをコンテナーから切り離し、所有権を得る。そのため、ノードハンドルによって得たノードは、元のコンテナーから独立し、元のコンテナーオブジェクトの破棄の際にも破棄されない。ノードハンドルのオブジェクトの破棄時に破棄される。このため、ノードハンドルはアロケーターのコピーも持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ;

    {
        <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
        <span class="co">// 所有権の移動</span>
        n = c.extract( <span class="bu">std::</span>begin(c) ) ;
        <span class="co">// cが破棄される</span>
    }

    <span class="co">// OK</span>
    <span class="co">// ノードハンドルによって所有権が移動している</span>
    <span class="dt">int</span> x = n.value() ;

    <span class="co">// nが破棄される</span>
}</code></pre></div>
<h3 id="extract-ノードハンドルの取得">extract : ノードハンドルの取得</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">node_type</span> extract( const_iterator position ) ;
<span class="dt">node_type</span> extract( <span class="at">const</span> <span class="dt">key_type</span> &amp; x ) ;</code></pre></div>
<p>連想コンテナーと非順序連想コンテナーのメンバー関数<code>extract</code>は、ノードハンドルを取得するためのメンバー関数だ。</p>
<p>メンバー関数<code>extract(position)</code>は、イテレーターの<code>position</code>が指す要素を、コンテナーから除去して、その要素を所有するノードハンドルを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n1 = c.extract( <span class="bu">std::</span>begin(c) ) ;

    <span class="co">// cは{2,3}</span>

    <span class="kw">auto</span> n2 = c.extract( <span class="bu">std::</span>begin(c) ) ;

    <span class="co">// cは{3}</span>

}</code></pre></div>
<p>メンバー関数<code>extract(x)</code>は、キー<code>x</code>がコンテナーに存在する場合、その要素をコンテナーから除去して、その要素を所有するノードハンドルを返す。存在しない場合、空のノードハンドルを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n1 = c.extract( <span class="dv">1</span> ) ;
    <span class="co">// cは{2,3}</span>

    <span class="kw">auto</span> n2 = c.extract( <span class="dv">2</span> ) ;
    <span class="co">// cは{3}</span>

    <span class="co">// キー4は存在しない</span>
    <span class="kw">auto</span> n3 = c.extract( <span class="dv">4</span> ) ;
    <span class="co">// cは{3}</span>
    <span class="co">// n3.empty() == true</span>
}</code></pre></div>
<p>キーの重複を許すコンテナーの場合、複数あるうちの1つの所有権が解放される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>multiset&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>} ;
    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;
    <span class="co">// cは{1,1}</span>
}</code></pre></div>
<h3 id="insert-ノードハンドルから要素の追加">insert : ノードハンドルから要素の追加</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// キーの重複を許さないコンテナーの場合</span>
<span class="dt">insert_return_type</span>  insert(<span class="dt">node_type</span>&amp;&amp; nh);
<span class="co">// キーの重複を許すmultiコンテナーの場合</span>
iterator  insert(<span class="dt">node_type</span>&amp;&amp; nh);

<span class="co">// ヒント付きのinsert</span>
iterator            insert(const_iterator hint, <span class="dt">node_type</span>&amp;&amp; nh);</code></pre></div>
<p>ノードハンドルをコンテナーのメンバー関数<code>insert</code>の実引数に渡すと、ノードハンドルから所有権をコンテナーに移動する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="kw">auto</span> n = a.extract(<span class="dv">1</span>) ;

    b.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// n.empty() == true</span>
}</code></pre></div>
<p>ノードハンドルが空の場合、何も起こらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ;

    <span class="co">// 何も起こらない</span>
    c.insert( <span class="bu">std::</span>move(n) ) ;
}</code></pre></div>
<p>キーの重複を許さないコンテナーに、すでにコンテナーに存在するキーと等しい値を所有するノードハンドルを<code>insert</code>しようとすると、<code>insert</code>は失敗する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;
    c.insert( <span class="dv">1</span> ) ;

    <span class="co">// 失敗する</span>
    c.insert( <span class="bu">std::</span>move(n) ) ; 
}</code></pre></div>
<p>第一引数にイテレーター<code>hint</code>を受け取る<code>insert</code>の挙動は、従来の<code>insert</code>と同じだ。要素が<code>hint</code>の直前に追加されるのであれば償却定数時間で処理が終わる。</p>
<p>ノードハンドルを実引数に受け取る<code>insert</code>の戻り値の型は、キーの重複を許す<code>multi</code>コンテナーの場合<code>iterator</code>。キーの重複を許さないコンテナーの場合、<code>insert_return_type</code>となる。</p>
<p><code>multi</code>コンテナーの場合、戻り値は追加した要素を指すイテレーターとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>multiset&lt;<span class="dt">int</span>&gt; c { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;

    <span class="kw">auto</span> n = c.extract( <span class="dv">1</span> ) ;

    <span class="kw">auto</span> iter = c.insert( n ) ;

    <span class="co">// cは{1,2,3}</span>
    <span class="co">// iterは1を指す</span>
}</code></pre></div>
<p>キーの重複を許さないコンテナーの場合、コンテナーにネストされた型名<code>insert_return_type</code>が戻り値の型となる。たとえば<code>set&lt;int&gt;</code>の場合、<code>set&lt;int&gt;::insert_return_type</code>となる。</p>
<p><code>insert_return_type</code>の具体的な名前は規格上規定されていない。<code>insert_return_type</code>は以下のようなデータメンバーを持つ型となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> <span class="dt">insert_return_type</span>
{
    iterator position ;
    <span class="dt">bool</span> inserted ;
    <span class="dt">node_type</span> node ;
} ;</code></pre></div>
<p><code>position</code>は<code>insert</code>によってコンテナーに所有権を移動して追加された要素を指すイテレーター、<code>inserted</code>は要素の追加が行われた場合に<code>true</code>となる<code>bool</code>, <code>node</code>は要素の追加が失敗したときにノードハンドルの所有権が移動されるノードハンドルとなる。</p>
<p><code>insert</code>に渡したノードハンドルが空のとき、<code>inserted</code>は<code>false</code>, <code>position</code>は<code>end()</code>, <code>node</code>は空になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ; <span class="co">// 空</span>

    <span class="kw">auto</span> [position, inserted, node] = c.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// inserted == false</span>
    <span class="co">// position == c.end()</span>
    <span class="co">// node.empty() == true</span>
}</code></pre></div>
<p><code>insert</code>が成功したとき、<code>inserted</code>は<code>true</code>, <code>position</code>は追加された要素を指し、<code>node</code>は空になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;

    <span class="kw">auto</span> [position, inserted, node] = c.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// inserted == true</span>
    <span class="co">// position == c.find(1)</span>
    <span class="co">// node.empty() == true</span>
}</code></pre></div>
<p><code>insert</code>が失敗したとき、つまりすでに同一のキーがコンテナーに存在したとき、<code>inserted</code>は<code>false</code>, <code>node</code>は<code>insert</code>を呼び出す前のノードハンドルの値、<code>position</code>はコンテナーの中の追加しようとしたキーに等しい要素を指す。<code>insert</code>に渡したノードハンドルは未規定の値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;
    c.insert(<span class="dv">1</span>) ;

    <span class="kw">auto</span> [position, inserted, node] = c.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// nは未規定の値</span>
    <span class="co">// inserted == false</span>
    <span class="co">// nodeはinsert( std::move(n) )を呼び出す前のnの値</span>
    <span class="co">// position == c.find(1)</span>
}</code></pre></div>
<p>規格はこの場合の<code>n</code>の値について規定していないが、最もありうる実装としては、<code>n</code>は<code>node</code>にムーブされるので、<code>n</code>は空になり、ムーブ後の状態になる。</p>
<h3 id="ノードハンドルの利用例">ノードハンドルの利用例</h3>
<p>ノードハンドルの典型的な使い方は以下のとおり。</p>
<h4 id="ストレージの再確保なしにコンテナーの一部の要素だけ別のコンテナーに移す">ストレージの再確保なしに、コンテナーの一部の要素だけ別のコンテナーに移す</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="kw">auto</span> n = a.extract(<span class="dv">1</span>) ;
    b.insert( <span class="bu">std::</span>move(n) ) ;
}</code></pre></div>
<h4 id="コンテナーの寿命を超えて要素を存続させる">コンテナーの寿命を超えて要素を存続させる</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ;

    {
        <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
        n = c.extract(<span class="dv">1</span>) ;
        <span class="co">// cが破棄される</span>
    }

    <span class="co">// コンテナーの破棄後も存続する</span>
    <span class="dt">int</span> value = n.value() ;
}</code></pre></div>
<h4 id="mapのキーを変更する">mapのキーを変更する</h4>
<p><code>map</code>ではキーは変更できない。キーを変更したければ、元の要素は削除して、新しい要素を追加する必要がある。これには動的なストレージの解放と確保が必要になる。</p>
<p>ノードハンドルを使えば、既存の要素のストレージに対して、所有権を<code>map</code>から引き剥がした上で、キーを変更して、もう一度<code>map</code>に差し戻すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="bu">std::</span>string, <span class="bu">std::</span>string &gt; m =
    {
        {<span class="st">&quot;cat&quot;</span>, <span class="st">&quot;meow&quot;</span>},
        {<span class="st">&quot;DOG&quot;</span>, <span class="st">&quot;bow&quot;</span>}, <span class="co">// キーを間違えたので変更したい</span>
        {<span class="st">&quot;cow&quot;</span>, <span class="st">&quot;moo&quot;</span>}
    } ;

    <span class="co">// 所有権を引き剥がす</span>
    <span class="kw">auto</span> n = m.extract(<span class="st">&quot;DOG&quot;</span>) ;
    <span class="co">// キーを変更</span>
    n.key() = <span class="st">&quot;dog&quot;</span> ;
    <span class="co">// 差し戻す</span>
    m.insert( <span class="bu">std::</span>move(n) ) ;
}</code></pre></div>
<h2 id="コンテナーアクセス関数">コンテナーアクセス関数</h2>
<p>ヘッダーファイル<code>&lt;iterator&gt;</code>に、コンテナーアクセス関数として、フリー関数版の<code>size</code>, <code>empty</code>, <code>data</code>が追加された。それぞれ、メンバー関数の<code>size</code>, <code>empty</code>, <code>data</code>を呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="bu">std::</span>size(v) ; <span class="co">// v.size()</span>
    <span class="bu">std::</span>empty(v) ; <span class="co">// v.empty()</span>
    <span class="bu">std::</span>data(v) ; <span class="co">// v.data() </span>
}</code></pre></div>
<p>このフリー関数は配列や<code>std::initializer_list&lt;T&gt;</code>にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">10</span>] ;

    <span class="bu">std::</span>size(a) ; <span class="co">// 10</span>
    <span class="bu">std::</span>empty(a) ; <span class="co">// 常にfalse</span>
    <span class="bu">std::</span>data(a) ; <span class="co">// a</span>
}</code></pre></div>
<h2 id="clamp">clamp</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;
clamp(<span class="at">const</span> T&amp; v, <span class="at">const</span> T&amp; lo, <span class="at">const</span> T&amp; hi);
<span class="kw">template</span>&lt;<span class="kw">class</span> T, <span class="kw">class</span> Compare&gt;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;
clamp(<span class="at">const</span> T&amp; v, <span class="at">const</span> T&amp; lo, <span class="at">const</span> T&amp; hi, Compare comp);</code></pre></div>
<p>ヘッダーファイル<code>&lt;algorithm&gt;</code>に追加された<code>clamp(v, lo, hi)</code>は値<code>v</code>が<code>lo</code>より小さい場合は<code>lo</code>を、<code>hi</code>より高い場合は<code>hi</code>を、それ以外の場合は<code>v</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>clamp( <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">10</span> ) ; <span class="co">// 5</span>
    <span class="bu">std::</span>clamp( <span class="dv">-5</span>, <span class="dv">0</span>, <span class="dv">10</span> ) ; <span class="co">// 0</span>
    <span class="bu">std::</span>clamp( <span class="dv">50</span>, <span class="dv">0</span>, <span class="dv">10</span> ) ; <span class="co">// 10</span>
}</code></pre></div>
<p><code>comp</code>を実引数に取る<code>clamp</code>は<code>comp</code>を値の比較に使う</p>
<p><code>clamp</code>には浮動小数点数も使えるが、NaNは渡せない。</p>
<h2 id="次元hypot">3次元hypot</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> hypot(<span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z);
<span class="dt">double</span> hypot(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> z);
<span class="dt">long</span> <span class="dt">double</span> hypot(<span class="dt">long</span> <span class="dt">double</span> x, <span class="dt">long</span> <span class="dt">double</span> y, <span class="dt">long</span> <span class="dt">double</span> z);</code></pre></div>
<p>ヘッダーファイル<code>&lt;cmath&gt;</code>に3次元の<code>hypot</code>が追加された。</p>
<p><strong>戻り値</strong>：</p>
<p><span class="math display">\[
\sqrt{x^2+y^2+z^2}
\]</span></p>
<h2 id="atomictis_always_lock_free">atomic&lt;T&gt;::is_always_lock_free</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> atomic
{
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_always_lock_free = ... ;
} ;</code></pre></div>
<p>C++17で<code>&lt;atomic&gt;</code>に追加された<code>atomic&lt;T&gt;::is_always_lock_free</code>は、<code>atomic&lt;T&gt;</code>の実装がすべての実行においてロックフリーであるとコンパイル時に保証できる場合、<code>true</code>になる<code>static constexpr</code>な<code>bool</code>型のデータメンバーだ。</p>
<p><code>atomic</code>には、他にも<code>bool</code>を返すメンバー関数<code>is_lock_free</code>があるが、これは実行時にロックフリーであるかどうかを判定できる。<code>is_always_lock_free</code>はコンパイル時にロックフリーであるかどうかを判定できる。</p>
<h2 id="scoped_lock-可変長引数lock_guard">scoped_lock : 可変長引数lock_guard</h2>
<p><code>std::scoped_lock</code>クラス<code>&lt;T ...&gt;</code>は可変長引数版の<code>lock_guard</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>mutex a, b, c, d ;

    {
        <span class="co">// a,b,c,dをlockする</span>
        <span class="bu">std::</span>scoped_lock l( a, b, c, d ) ;
        <span class="co">// a,b,c,dをunlockする</span>
    }
}</code></pre></div>
<p><code>std::scoped_lock</code>のコンストラクターは複数のロックのオブジェクトのリファレンスを取り、それぞれにデッドロックを起こさない方法でメンバー関数<code>lock</code>を呼び出す。デストラクターはメンバー関数<code>unlock</code>を呼び出す。</p>
<h2 id="stdbyte">std::byte</h2>
<p>C++17ではバイトを表現する型として<code>std::byte</code>がライブラリに追加された。これは、コア言語の一部であり、<a href="#std.byte">別項で詳しく解説を行っている</a>。</p>
<h2 id="最大公約数gcdと最小公倍数lcm">最大公約数（gcd）と最小公倍数（lcm）</h2>
<p>C++17ではヘッダーファイル<code>&lt;numeric&gt;</code>に最大公約数（<code>gcd</code>）と最小公倍数（<code>lcm</code>）が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;

    <span class="cf">while</span>( <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b )
    {
        <span class="bu">std::</span>cout
            &lt;&lt; <span class="st">&quot;gcd: &quot;</span> &lt;&lt; gcd(a,b)
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">lcm: &quot;</span> &lt;&lt; lcm(a,b) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h3 id="gcd-最大公約数">gcd : 最大公約数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> M, <span class="kw">class</span> N&gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>common_type_t&lt;M,N&gt; gcd(M m, N n)
{
    <span class="cf">if</span> ( n == <span class="dv">0</span> )
        <span class="cf">return</span> m ;
    <span class="cf">else</span>
        <span class="cf">return</span> gcd( n, <span class="bu">std::</span>abs(m) % <span class="bu">std::</span>abs(n) ) ; 
}</code></pre></div>
<p><code>gcd(m, n)</code>は<code>m</code>と<code>n</code>がともにゼロの場合ゼロを返す。それ以外の場合、<span class="math inline">\(|m|\)</span>と<span class="math inline">\(|n|\)</span>の最大公約数（Greatest Common Divisor）を返す。</p>
<h3 id="lcm-最小公倍数">lcm : 最小公倍数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> M, <span class="kw">class</span> N&gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>common_type_t&lt;M,N&gt; lcm(M m, N n)
{
    <span class="cf">if</span> ( m == <span class="dv">0</span> || n == <span class="dv">0</span> )
        <span class="cf">return</span> <span class="dv">0</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>abs(m) / gcd( m, n ) * <span class="bu">std::</span>abs(n) ;
}</code></pre></div>
<p><code>lcm(m,n)</code>は、<code>m</code>と<code>n</code>のどちらかがゼロの場合ゼロを返す。それ以外の場合、<span class="math inline">\(|m|\)</span>と<span class="math inline">\(|n|\)</span>の最小公倍数（Least Common Multiple）を返す。</p>
<h1 id="ファイルシステム">ファイルシステム</h1>
<p>ヘッダーファイル<code>&lt;filesystem&gt;</code>で定義されている標準ライブラリのファイルシステムは、ファイルやディレクトリーとその属性を扱うためのライブラリだ。</p>
<p>一般に「ファイルシステム」といった場合、たとえばLinuxのext4, Microsoft WindowsのFATやNTFS, Apple MacのHFS+やAPFSといったファイルとその属性を表現するためのストレージ上のデータ構造を意味する。C++の標準ライブラリのファイルシステムとは、そのようなファイルシステムを実現するデータ構造を操作するライブラリではない。ファイルシステムというデータ構造で抽象化された、ファイルやディレクトリーとその属性、それに付随する要素、たとえばパスやファイルやディレクトリーを操作するためのライブラリのことだ。</p>
<p>また、ファイルシステムライブラリでは、「ファイル」という用語は単に通常のファイルのみならず、ディレクトリー、シンボリックリンク、FIFO（名前付きパイプ）、ソケットなどの特殊なファイルも含む。</p>
<p>本書ではファイルシステムライブラリのすべてを詳細に解説していない。ファイルシステムライブラリは量が膨大なので、特定の関数の意味については、C++コンパイラーに付属のリファレンスマニュアルなどを参照するとよい。</p>
<h2 id="名前空間">名前空間</h2>
<p>ファイルシステムライブラリは<code>std::filesystem</code>名前空間スコープの下に宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem<span class="bu">::</span>path p(<span class="st">&quot;/bin&quot;</span>) ;
}</code></pre></div>
<p>この名前空間は長いので、ファイルシステムライブラリを使うときは、関数のブロックスコープ単位で<code>using</code>ディレクティブを使うか、名前空間エイリアスを使って短い別名を付けるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> using_directive()
{
    <span class="co">// usingディレクティブ</span>
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;/etc&quot;</span>) ;
}

<span class="dt">void</span> namespace_alias()
{
    <span class="co">// 名前空間エイリアス</span>
    <span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem ;

    fs::path p(<span class="st">&quot;/usr&quot;</span>) ;
}</code></pre></div>
<h2 id="posix準拠">POSIX準拠</h2>
<p>C++のファイルシステムのファイル操作の挙動は、POSIX規格に従う。実装によってはPOSIXに規定された挙動を提供できない場合もある。その場合は制限の範囲内で、できるだけPOSIXに近い挙動を行う。実装がどのような意味のある挙動も提供できない場合、エラーが通知される。</p>
<h2 id="ファイルシステムの全体像">ファイルシステムの全体像</h2>
<p>ファイルシステムライブラリの全体像を簡単に箇条書きすると以下のとおり。</p>
<ul>
<li>クラス<code>path</code>でファイルパス文字列を扱う</li>
<li>例外クラス<code>filesystem_error</code>とクラス<code>error_code</code>でエラー通知</li>
<li>クラス<code>file_status</code>でファイルの情報とパーミッションの取得、設定</li>
<li>クラス<code>directory_entry</code>でディレクトリーの情報の取得、設定</li>
<li>クラス<code>directory_iterator</code>でディレクトリー構造をイテレーターとしてたどる</li>
<li>多数のフリー関数でファイルとディレクトリーの操作</li>
</ul>
<h2 id="エラー処理">エラー処理</h2>
<p>ファイルシステムライブラリでエラーが発生した場合、エラーの通知方法には2種類の方法がある。例外を使う方法と、ヘッダーファイル<code>&lt;system_error&gt;</code>で定義されているエラー通知用のクラス<code>std::error_code</code>へのリファレンスを実引数として渡してエラー内容を受け取る方法だ。</p>
<p>エラー処理の方法は、エラーの起こる期待度によって選択できる。一般に、エラーがめったに起こらない場合、エラーが起こるのは予期していない場合、エラー処理には例外を使ったほうがよい。エラーが頻繁に起こる場合、エラーが起こることが予期できる場合、エラー処理には例外を使わないほうがよい。</p>
<h3 id="例外-1">例外</h3>
<p>ファイルシステムライブラリの関数のうち、<code>std::error_code &amp;</code>型を実引数に取らない関数は、以下のようにエラー通知を行う。</p>
<ul>
<li><p>OSによるファイルシステム操作においてエラーが発生した場合、<code>std::filesystem::filesystem_error</code>型の例外が<code>throw</code>される。1つの<code>path</code>を実引数に取る関数の場合、<code>filesystem_error</code>のメンバー関数<code>path1</code>で実引数の<code>path</code>が得られる。2つの<code>path</code>を実引数に取る関数の場合、<code>filesystem_error</code>のメンバー関数<code>path1</code>, <code>path2</code>で第一、第二引数がそれぞれ得られる。<code>filesystem_error</code>はエラー内容に応じた<code>error_code</code>を持つ</p></li>
<li><p>ストレージの確保に失敗した場合、既存の例外による通知が行われる</p></li>
<li><p>デストラクターは例外を投げない</p></li>
</ul>
<p>例外を使ったエラー処理は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="cf">try</span> {
        <span class="co">// ファイル名から同じファイル名へのコピーによるエラー</span>
        path file(<span class="st">&quot;foobar.txt&quot;</span>) ;
        <span class="bu">std::</span>ofstream{ file } ;
        copy_file( file, file ) ;
       
    } <span class="cf">catch</span>( filesystem_error &amp; e )
    { <span class="co">// エラーの場合</span>
        <span class="kw">auto</span> path1 = e.path1() ; <span class="co">// 第一引数</span>
        <span class="kw">auto</span> path2 = e.path2() ; <span class="co">// 第二引数</span>
        <span class="kw">auto</span> error_code = e.code() ; <span class="co">// error_code</span>
        
        <span class="bu">std::</span>cout
            &lt;&lt; <span class="st">&quot;error number: &quot;</span> &lt;&lt; error_code.value ()
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">error message: &quot;</span> &lt;&lt; error_code.message() 
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path1: &quot;</span> &lt;&lt; path<span class="dv">1</span>
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<p><code>filesystem_error</code>は以下のようなクラスになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>filesystem {
    <span class="kw">class</span> filesystem_error : <span class="kw">public</span> system_error {
    <span class="kw">public</span>:
        <span class="co">// 第一引数</span>
        <span class="at">const</span> path&amp; path1() <span class="at">const</span> <span class="kw">noexcept</span>;
        <span class="co">// 第二引数</span>
        <span class="at">const</span> path&amp; path2() <span class="at">const</span> <span class="kw">noexcept</span>;
        <span class="co">// エラー内容を人間が読めるnull終端文字列で返す</span>
        <span class="at">const</span> <span class="dt">char</span>* what() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>;
    };
}</code></pre></div>
<h3 id="非例外">非例外</h3>
<p>ファイルシステムライブラリの関数のうち、<code>std::error_code &amp;</code>型を実引数に取る関数は、以下のようにエラー通知を行う。</p>
<ul>
<li>OSによるファイルシステム操作においてエラーが発生した場合、<code>error_code &amp;</code>型の実引数がエラー内容に応じて設定される。エラーがない場合、<code>error_code &amp;</code>型の実引数に対してメンバー関数<code>clear()</code>が呼ばれる。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// ファイル名から同じファイル名へのコピーによるエラー</span>
    path file(<span class="st">&quot;foobar.txt&quot;</span>) ;
    <span class="bu">std::</span>ofstream{ file } ;
    <span class="bu">std::</span>error_code error_code;
    copy_file( file, file, error_code ) ;

    <span class="cf">if</span> ( error_code )
    { <span class="co">// エラーの場合</span>
        <span class="kw">auto</span> path1 = file ; <span class="co">// 第一引数</span>
        <span class="kw">auto</span> path2 = file ; <span class="co">// 第二引数</span>
        
        <span class="bu">std::</span>cout
            &lt;&lt; <span class="st">&quot;error number: &quot;</span> &lt;&lt; error_code.value ()
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">error message: &quot;</span> &lt;&lt; error_code.message() 
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path1: &quot;</span> &lt;&lt; path<span class="dv">1</span>
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h2 id="path-ファイルパス文字列クラス">path : ファイルパス文字列クラス</h2>
<p><code>std::filesystem::path</code>はファイルパスを文字列で表現するためのクラスだ。文字列を表現するクラスとしてC++にはすでに<code>std::string</code>があるが、ファイルパスという文字列を表現するために、別の専用クラスが作られた。</p>
<p>クラス<code>path</code>は以下の機能を提供する。</p>
<ul>
<li>ファイルパス文字列の表現</li>
<li>ファイルパス文字列の操作</li>
</ul>
<p><code>path</code>はファイルパス文字列の表現と操作だけを提供するクラスで、物理ファイルシステムへの変更のコミットはしない。</p>
<p>ファイルパス文字列がどのように表現されているかは実装により異なる。POSIX環境では文字型を<code>char</code>型としてUTF-8エンコードで表現するOSが多いが、Microsoft Windowsで本書執筆現在、文字型を<code>wchar_t</code>としてUTF-16エンコードで表現する慣習になっている。</p>
<p>また、OSによってはラテンアルファベットの大文字小文字を区別しなかったり、区別はするが無視されたりする実装もある。</p>
<p>クラス<code>path</code>はそのようなファイルパス文字列の差異を吸収してくれる。</p>
<p>クラス<code>path</code>には以下のようなネストされた型名がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>filesystem {
<span class="kw">class</span> path {
<span class="kw">public</span>:
    <span class="kw">using</span> <span class="dt">value_type</span> = see below ;
    <span class="kw">using</span> <span class="dt">string_type</span> = basic_string&lt;<span class="dt">value_type</span>&gt;;
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">value_type</span> preferred_separator = see below ;
} ;</code></pre></div>
<p><code>value_type</code>と<code>string_type</code>は<code>path</code>が内部でファイルパス文字列を表現するのに使う文字と文字列の型だ。<code>preferred_separator</code>は、推奨されるディレクトリー区切り文字だ。たとえばPOSIX互換環境では<code>/</code>が用いられるが、Microsoft Windowsでは<code>\</code>が使われている。</p>
<h3 id="ファイルパスの文字列">ファイルパスの文字列</h3>
<p>ファイルパスは文字列で表現する。C++の文字列のエンコードには以下のものがある。</p>
<ul>
<li><code>char</code>: ネイティブナローエンコード</li>
<li><code>wchar_t</code>: ネイティブワイドエンコード</li>
<li><code>char</code>: UTF-8エンコード</li>
<li><code>char16_t</code>: UTF-16エンコード</li>
<li><code>char32_t</code>: UTF-32エンコード</li>
</ul>
<p><code>path::value_type</code>がどの文字型を使い、どの文字列エンコードを使っているかは実装依存だ。<code>path</code>はどの文字列エンコードが渡されても、<code>path::value_type</code>の文字型と文字エンコードになるように自動的に変換が行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// ネイティブナローエンコード</span>
    path p1( <span class="st">&quot;/dev/null&quot;</span> ) ;
    <span class="co">// ネイティブワイドエンコード</span>
    path p2( <span class="st">L&quot;/dev/null&quot;</span> ) ;
    <span class="co">// UTF-16エンコード</span>
    path p3( <span class="st">u&quot;/dev/null&quot;</span> ) ;
    <span class="co">// UTF-32エンコード</span>
    path p4( <span class="st">U&quot;/dev/null&quot;</span> ) ;
}</code></pre></div>
<p>なので、どの文字列エンコードで渡しても動く。</p>
<p>C++ではUTF-8エンコードの文字型は<code>char</code>で、これはネイティブナローエンコードの文字型と同じなので、型システムによって区別できない。そのため、UTF-8文字列リテラルを渡すと、ネイティブナローエンコードとして認識される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// ネイティブナローエンコードとして解釈される</span>
    path p( <span class="st">u8&quot;ファイル名&quot;</span> ) ;
}</code></pre></div>
<p>このコードは、ネイティブナローエンコードがUTF-8ではない場合、動く保証のない移植性の低いコードだ。UTF-8エンコードを移植性の高い方法でファイルパスとして使いたい場合、<code>u8path</code>を使うとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// UTF-8エンコードとして解釈される</span>
    <span class="co">// 実装の使う文字エンコードに変換される</span>
    path = u8path( <span class="st">u8&quot;ファイル名&quot;</span> ) ;
}</code></pre></div>
<p><code>u8path(Source)</code>は<code>Source</code>をUTF-8エンコードされた文字列として扱うので、通常の文字列リテラルを渡すと、ネイティブナローエンコードがUTF-8ではない環境では問題になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// UTF-8エンコードとして解釈される</span>
    <span class="co">// ネイティブナローエンコードがUTF-8ではない場合、問題になる</span>
    path = u8path( <span class="st">&quot;ファイル名&quot;</span> ) ;
}</code></pre></div>
<p><code>u8path</code>を使う場合は、文字列は必ずUTF-8エンコードしなければならない。</p>
<p>環境によっては、ファイルパスに使える文字に制限があり、また特定の文字列は特別な意味を持つ予約語になっていることもあるので、移植性の高いプログラムの作成に当たってはこの点でも注意が必要だ。たとえば、環境によっては大文字小文字の区別をしないかもしれない。また、<code>CON</code>や<code>AUX</code>のような文字列が特別な意味を持つかもしれない。</p>
<p><code>path</code>に格納されているファイルパス文字列を取得する方法は、環境依存の文字列エンコードとファイルパスの表現方法の差異により、さまざまな方法が用意されている。</p>
<p>ファイルパス文字列のフォーマットには以下の2つがある。</p>
<ul>
<li>ネイティブ：　実装依存のフォーマット</li>
<li>ジェネリック：汎用的な標準のフォーマット</li>
</ul>
<p>POSIX準拠の環境においては、ネイティブとジェネリックはまったく同じだ。POSIX準拠ではない環境では、ネイティブとジェネリックは異なるフォーマットを持つ可能性がある。</p>
<p>たとえば、Microsoft Windowsでは、ネイティブのファイルパス文字列はディレクトリーの区切り文字にPOSIX準拠の<code>/</code>ではなく<code>\</code>を使っている。</p>
<p>まずメンバー関数<code>native</code>と<code>c_str</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> path {
{
<span class="kw">public</span> :
    <span class="at">const</span> <span class="dt">string_type</span>&amp; native() <span class="at">const</span> <span class="kw">noexcept</span>;
    <span class="at">const</span> <span class="dt">value_type</span>* c_str() <span class="at">const</span> <span class="kw">noexcept</span>;
} ;</code></pre></div>
<p>これはクラス<code>path</code>が内部で使っている実装依存のネイティブな文字列型をそのまま返すものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p = current_path() ;

    <span class="co">// 実装依存のbasic_stringの特殊化</span>
    path::<span class="dt">string_type</span> str = p.native() ;

    <span class="co">// 実装依存の文字型</span>
    path::<span class="dt">value_type</span> <span class="at">const</span> * ptr = p.c_str() ;
    
}</code></pre></div>
<p>このメンバー関数を使うコードは移植性に注意が必要だ。</p>
<p><code>str</code>の型は<code>path::string_type</code>で、<code>ptr</code>の型は実装依存の<code>path::value_type const *</code>だ。<code>path::value_typeとpath::string_type</code>は、<code>char</code>や<code>wchar_t</code>, <code>std::string</code>や<code>std::wstring</code>のようなC++が標準で定義する型ではない可能性がある。</p>
<p>そして、<code>path::string_type</code>への変換関数<code>operator string_type()</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;

    <span class="kw">auto</span> p = current_path() ;

    <span class="co">// 暗黙の型変換</span>
    path::<span class="dt">string_type</span> str = p ;
}</code></pre></div>
<p><code>path</code>の<code>operator string_type()</code>は、ネイティブの文字列型を既存のファイルストリームライブラリでオープンできる形式に変換して返す。たとえば空白文字を含むファイルパスのために、二重引用符で囲まれている文字列に変換されるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path name(<span class="st">&quot;foo bar.txt&quot;</span>) ;
    <span class="bu">std::</span>basic_ofstream&lt;path::<span class="dt">value_type</span>&gt; file( name ) ;
    file &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>ネイティブのファイルパス文字列を<code>string</code>, <code>wstring</code>, <code>u16string</code>, <code>u32string</code>に変換して取得するメンバー関数に以下のものがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> path {
<span class="kw">public</span> :
    <span class="bu">std::</span>string string() <span class="at">const</span>;
    <span class="bu">std::</span>wstring wstring() <span class="at">const</span>;
    <span class="bu">std::</span>string u8string() <span class="at">const</span>;
    <span class="bu">std::</span>u16string u16string() <span class="at">const</span>;
    <span class="bu">std::</span>u32string u32string() <span class="at">const</span>;
} ;</code></pre></div>
<p>このうち、メンバー関数<code>string</code>はネイティブナローエンコードされた<code>std::string</code>, メンバー関数<code>u8string</code>はUTF-8エンコードされた<code>std::string</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path name(<span class="st">&quot;hello.txt&quot;</span>) ;
    <span class="bu">std::</span>ofstream file( name.string() ) ;
    file &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>ファイルパス文字列をジェネリックに変換して返す<code>generic_string()</code>系のメンバー関数がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> path {
<span class="kw">public</span> :
    <span class="bu">std::</span>string generic_string() <span class="at">const</span>;
    <span class="bu">std::</span>wstring generic_wstring() <span class="at">const</span>;
    <span class="bu">std::</span>string generic_u8string() <span class="at">const</span>;
    <span class="bu">std::</span>u16string generic_u16string() <span class="at">const</span>;
    <span class="bu">std::</span>u32string generic_u32string() <span class="at">const</span>
} ;</code></pre></div>
<p>使い方はネイティブな文字列を返す<code>string()</code>系のメンバー関数と同じだ。</p>
<p>ファイルパスの文字列の文字型と文字列エンコードは環境ごとに異なるので、移植性の高いコードを書くときには注意が必要だ。</p>
<p>現実的には、モダンなPOSIX準拠の環境では、文字型は<code>char</code>, 文字列型は<code>std::string</code>, エンコードはUTF-8になる。</p>
<p>Microsoft WindowsのWin32サブシステムとMSVCはPOSIX準拠ではなく、本書執筆時点では、歴史的経緯により、文字型は<code>wchar_t</code>, 文字列型は<code>std::wstring</code>, エンコードはUTF-16となっている。</p>
<h3 id="ファイルパスの操作">ファイルパスの操作</h3>
<p>クラス<code>path</code>はファイルパス文字列の操作を提供している。<code>std::string</code>とは違い、<code>find</code>や<code>substr</code>のような操作は提供していないが、ファイルパス文字列に特化した操作を提供している。</p>
<p><code>operator /</code>, <code>operator /=</code>はセパレーターで区切ったファイルパス文字列の追加を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;/&quot;</span>) ;

    <span class="co">// &quot;/usr&quot;</span>
    p /= <span class="st">&quot;usr&quot;</span> ;
    <span class="co">// &quot;usr/local/include&quot;</span>
    p = p / <span class="st">&quot;local&quot;</span> / <span class="st">&quot;include&quot;</span> ;
}</code></pre></div>
<p><code>operator +=</code>は単なる文字列の結合を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;/&quot;</span>) ;

    <span class="co">// &quot;/usr&quot;</span>
    p += <span class="st">&quot;usr&quot;</span> ;
    <span class="co">// &quot;/usrlocal&quot;</span>
    p += <span class="st">&quot;local&quot;</span> ;
    <span class="co">// &quot;/usrlocalinclude&quot;</span>
    p += <span class="st">&quot;include&quot;</span> ;
}</code></pre></div>
<p><code>operator /</code>と違い、<code>operator +</code>は存在しない。</p>
<p>その他にも、<code>path</code>はさまざまなファイルパス文字列に対する操作を提供している。以下はその一例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p( <span class="st">&quot;/home/cpp/src/main.cpp&quot;</span> ) ;

    <span class="co">// &quot;main.cpp&quot;</span>
    path filename = p.filename() ;
    <span class="co">// &quot;main&quot;</span>
    path stem = p.stem() ;
    <span class="co">// &quot;.cpp&quot;</span>
    path extension = p.extension() ;
    <span class="co">// &quot;/home/cpp/src/main.o&quot;</span>
    p.replace_extension(<span class="st">&quot;o&quot;</span>) ;
    <span class="co">// &quot;/home/cpp/src/&quot;</span>
    p.remove_filename() ;
}</code></pre></div>
<p><code>path</code>はファイルパス文字列に対してよく行う文字列処理を提供している。たとえばファイル名だけ抜き出す処理、拡張子だけ抜き出す処理、拡張子を変える処理などだ。</p>
<h2 id="file_status">file_status</h2>
<p>クラス<code>file_status</code>はファイルのタイプとパーミッションを保持するクラスだ。</p>
<p>ファイルのタイプとパーミッションはファイルパス文字列を指定して取得する方法が別途あるが、その方法では毎回物理ファイルシステムへのアクセスが発生する。<code>file_status</code>はファイルのタイプとパーミッション情報を保持するクラスとして、いわばキャッシュの役割を果たす。</p>
<p><code>file_status</code>は物理ファイルシステムへの変更のコミットはしない。</p>
<p><code>file_status</code>クラスは<code>status(path)</code>もしくは<code>status(path, error_code)</code>で取得できる。あるいは、<code>directory_entry</code>のメンバー関数<code>status()</code>から取得できる。</p>
<p>タイプというのは、ファイルが種類を表す<code>enum</code>型<code>file_type</code>で、通常のファイルやディレクトリーやシンボリックリンクといったファイルの種類を表す。</p>
<p>パーミッションというのは、ファイルの権限を表すビットマスクの<code>enum</code>型<code>perms</code>で、ファイルの所有者とグループと他人に対す読み込み、書き込み、実行のそれぞれの権限を表している。この値はPOSIXの値と同じになっている。</p>
<p>ファイルのタイプとパーミッションを取得するメンバー関数は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> <span class="dt">file_type</span> {
<span class="kw">public</span> :
    <span class="dt">file_type</span> type() <span class="at">const</span> <span class="kw">noexcept</span>;
    perms permissions() <span class="at">const</span> <span class="kw">noexcept</span>;
} ;</code></pre></div>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="dt">int</span> regular_files = <span class="dv">0</span> ;
    <span class="dt">int</span> execs = <span class="dv">0</span> ;

    <span class="bu">std::</span>for_each( iter, end, [&amp;]( <span class="kw">auto</span> entry )
    {
        <span class="kw">auto</span> file_status = entry.status() ;
        <span class="co">// is_regular_file( file_status )でも可</span>
        <span class="cf">if</span> ( file_status.type() == <span class="dt">file_type</span>::regular )
            ++regular_files ;

        <span class="kw">constexpr</span> <span class="kw">auto</span> exec_bits = 
            perms::owner_exec | perms::group_exec | perms::others_exec ;

        <span class="kw">auto</span> permissions = file_status.permissions() ;
        <span class="cf">if</span> ( (  permissions != perms::unknown) &amp;&amp;
                (permissions &amp; exec_bits) != perms::none ) 
            ++execs ;
    } ) ;

    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;Current directory has &quot;</span>
        &lt;&lt; regular_files
        &lt;&lt; <span class="st">&quot; regular files.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
        &lt;&lt; execs
        &lt;&lt; <span class="st">&quot; files are executable.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
}</code></pre></div>
<p>このプログラムは、カレントディレクトリーにある通常のファイルの数と、実行可能なファイルの数を表示する。</p>
<p>ファイルパーミッションを表現する<code>enum</code>型<code>perms</code>は、パーミッションが不明な場合<code>perms::unknown</code>になる。この値は<code>0xFFFF</code>なのでビット演算をする場合には注意が必要だ。</p>
<p>それ以外の<code>perms</code>の値はPOSIXに準拠しているが、<code>perms</code>は<code>scoped enum</code>型なので、明示的なキャストが必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="bu">std::</span>filesystem<span class="bu">::</span>perms a = <span class="bn">0755</span> ;

<span class="co">// OK</span>
<span class="bu">std::</span>filesystem<span class="bu">::</span>perms b = <span class="bu">std::</span>filesystem<span class="bu">::</span>perms(<span class="bn">0755</span>) ;</code></pre></div>
<p>ファイルのタイプとパーミッションを書き換えるメンバー関数は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> type(<span class="dt">file_type</span> ft) <span class="kw">noexcept</span>;
<span class="dt">void</span> permissions(perms prms) <span class="kw">noexcept</span>;</code></pre></div>
<p>ただし、<code>file_status</code>というのは単なるキャッシュ用のクラスなので、<code>file_status</code>のタイプとパーミッションを「書き換える」というのは、単に<code>file_status</code>のオブジェクトに保持されている値を書き換えるだけで、物理ファイルシステムに反映されるものではない。物理ファイルシステムを書き換えるには、フリー関数の<code>permissions</code>を使う。</p>
<h2 id="directory_entry">directory_entry</h2>
<p>クラス<code>directory_entry</code>はファイルパス文字列を保持し、ファイルパスの指し示すファイルの情報を取得できるクラスだ。</p>
<p>物理ファイルシステムからファイルの情報を毎回読むのは非効率的だ。<code>directory_entry</code>はいわばファイル情報のキャッシュとしての用途を持つ。</p>
<p><code>directory_entry</code>は物理ファイルシステムから情報を読み込むだけで、変更のコミットはしない。</p>
<p><code>directory_entry</code>の構築は、コンストラクターに引数として<code>path</code>を与える他、<code>directory_iterator</code>と<code>recursive_directory_iterator</code>からも得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;.&quot;</span>) ;

    <span class="co">// ファイルパス文字列から得る</span>
    directory_entry e1(p) ;

    <span class="co">// イテレーターから得る</span>
    directory_iterator i1(p) ;
    directory_entry e2 = *i1 ;

    recursive_directory_iterator i2(p) ;
    directory_entry e3 = *i2 ;
}</code></pre></div>
<p><code>directory_entry</code>にはさまざまなファイル情報を取得するメンバー関数があるが、これは同じ機能のものがフリー関数でも用意されている。<code>directory_entry</code>を使うと、ファイル情報をキャッシュできるため、同じファイルパスに対して、物理ファイルシステムの変更がないときに複数回のファイル情報取得を行うのが効率的になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    directory_entry entry(<span class="st">&quot;/home/cpp/foo&quot;</span>) ;

    <span class="co">// 存在確認</span>
    <span class="dt">bool</span> b = entry.exists() ;

    <span class="co">// &quot;/home/cpp/foo&quot;</span>
    path p = entry.path() ;
    file_status s = entry.status() ;

    <span class="co">// ファイルサイズを取得</span>
    <span class="bu">std::</span>uintmax_t size = entry.file_size() ;

    {
        <span class="bu">std::</span>ofstream foo( entry.path() ) ;
        foo &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
    }

    <span class="co">// 物理ファイルシステムから情報を更新</span>
    entry.refresh() ;
    <span class="co">// もう一度ファイルサイズを取得</span>
    size = entry.file_size() ;

    <span class="co">// 情報を取得するファイルパスを</span>
    <span class="co">// &quot;/home/cpp/bar&quot;</span>
    <span class="co">// に置き換えてrefresh()を呼び出す</span>
    entry.replace_filename(<span class="st">&quot;bar&quot;</span>) ;
}</code></pre></div>
<p><code>directory_entry</code>はキャッシュ用のクラスで、自動的に物理ファイルシステムの変更に追随しないので、最新の情報を取得するには、明示的にメンバー関数<code>refresh</code>を呼び出す必要がある。</p>
<h2 id="directory_iterator">directory_iterator</h2>
<p><code>directory_iterator</code>は、あるディレクトリー下に存在するファイルパスをイテレーターの形式で列挙するためのクラスだ。</p>
<p>たとえば、カレントディレクトリー下のファイルパスをすべて列挙するコードは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;
    directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;
    <span class="bu">std::</span>copy( iter, end,
        <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ) ;
}</code></pre></div>
<p><code>directory_iterator</code>はコンストラクターとして<code>path</code>を渡すと、そのディレクトリー下の最初のファイルに相当する<code>directory_entry</code>を返すイテレーターとなる。コンストラクターで指定されたディレクトリー下にファイルが存在しない場合、終端イテレーターになる。</p>
<p><code>directory_iterator</code>のデフォルトコンストラクターは終端イテレーターになる。終端イテレーターはデリファレンスできない。</p>
<p><code>directory_iterator::value_type</code>は<code>directory_entry</code>で、イテレーターのカテゴリーは入力イテレーターとなる。</p>
<p><code>directory_iterator</code>はカレントディレクトリー（<code>.</code>）と親ディレクトリー（<code>..</code>）は列挙しない。</p>
<p><code>directory_iterator</code>がディレクトリー下のファイルをどのような順番で列挙するかは未規定だ。</p>
<p><code>directory_iterator</code>によって返されるファイルパスは存在しない可能性があるので、ファイルが存在することを当てにしてはいけない。たとえば、存在しないファイルへのシンボリックリンクかもしれない。</p>
<p><code>directory_iterator</code>のオブジェクトが作成された後に物理ファイルシステムになされた変更は、反映されるかどうか未規定である。</p>
<p><code>directory_iterator</code>のコンストラクターは列挙時の動作を指定できる<code>directory_options</code>を実引数に受け取ることができる。しかし、C++17の標準規格の範囲では<code>directory_iterator</code>の挙動を変更する<code>directory_options</code>は規定されていない。</p>
<h3 id="エラー処理-1">エラー処理</h3>
<p><code>directory_iterator</code>は構築時にエラーが発生することがある。このエラーを例外ではなく<code>error_code</code>で受け取りたい場合、コンストラクターの実引数で<code>error_code</code>へのリファレンスを渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="bu">std::</span>error_code err ;

    directory_iterator iter(<span class="st">&quot;this-directory-does-not-exist&quot;</span>, err) ;

    <span class="cf">if</span> ( err )
    {
        <span class="co">// エラー処理</span>
    }
}</code></pre></div>
<p><code>directory_iterator</code>はインクリメント時にエラーが発生することがある。このエラーを例外ではなく<code>error_code</code>で受け取りたい場合、メンバー関数<code>increment</code>を呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ; 

    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="bu">std::</span>error_code err ;

    <span class="cf">for</span> ( ; iter != end &amp;&amp; !err ; iter.increment( err ) )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }

    <span class="cf">if</span> ( err )
    {
        <span class="co">// エラー処理</span>
    }
}</code></pre></div>
<h2 id="recursive_directory_iterator">recursive_directory_iterator</h2>
<p><code>recursive_directory_iterator</code>は指定されたディレクトリー下に存在するサブディレクトリーの下も含めて、すべてのファイルを列挙する。使い方は<code>directory_iterator</code>とほぼ同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ; 
    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="bu">std::</span>copy(  iter, end,
                <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ) ;
}</code></pre></div>
<p>メンバー関数<code>options</code>, <code>depth</code>, <code>recursion_pending</code>, <code>pop</code>, <code>disable_recursion_pending</code>をデリファレンスできないイテレーターに対して呼び出した際の挙動は未定義だ。</p>
<h3 id="オプション">オプション</h3>
<p><code>recursive_directory_iterator</code>はコンストラクターの実引数に<code>directory_options</code>型の<code>scoped enum</code>値を取ることによって、挙動を変更できる。<code>directory_options</code>型の<code>enum</code>値はビットマスクになっていて、以下の3つのビットマスク値が規定されている。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>none</code></td>
<td align="left">デフォルト。ディレクトリーシンボリックリンクをスキップ。パーミッション違反はエラー</td>
</tr>
<tr class="even">
<td align="left"><code>follow_directory_symlink</code></td>
<td align="left">ディレクトリーシンボリックリンクの中も列挙</td>
</tr>
<tr class="odd">
<td align="left"><code>skip_permission_denied</code></td>
<td align="left">パーミッション違反のディレクトリーはスキップ</td>
</tr>
</tbody>
</table>
<p>このうち取りうる組み合わせは、<code>none</code>, <code>follow_directory_symlink</code>, <code>skip_permission_denied</code>, <code>follow_directory_symlink | skip_permission_denied</code>の4種類になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ; 
    recursive_directory_iterator
        iter(<span class="st">&quot;/&quot;</span>, directory_options::skip_permission_denied), end ;

    <span class="bu">std::</span>copy(  iter, end,
                <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ) ;
}</code></pre></div>
<p><code>follow_directory_symlink</code>は、親ディレクトリーへのシンボリックリンクが存在する場合、イテレーターが終端イテレーターに到達しない可能性があるので注意すること。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// 自分自身を含むディレクトリーに対するシンボリックリンク</span>
    create_symlink(<span class="st">&quot;.&quot;</span>, <span class="st">&quot;foo&quot;</span>) ;

    recursive_directory_iterator
        iter(<span class="st">&quot;.&quot;</span>, directory_options::follow_directory_symlink), end ;

    <span class="co">// エラー、もしくは終了しない</span>
    <span class="bu">std::</span>copy( iter, end, <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout) ) ;
}</code></pre></div>
<p><code>recursive_directory_iterator</code>の現在の<code>directory_options</code>を得るには、メンバー関数<code>options</code>を呼ぶ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    directory_options options() <span class="at">const</span> ;
} ;</code></pre></div>
<h3 id="depth-深さ取得">depth : 深さ取得</h3>
<p><code>recursive_directory_iterator</code>が現在列挙しているディレクトリーの深さを知るには、メンバー関数<code>depth</code>を呼ぶ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    <span class="dt">int</span> depth() <span class="at">const</span> ;
} ;</code></pre></div>
<p>最初のディレクトリーの深さは0で、次のサブディレクトリーの深さは1、それ以降のサブディレクトリーも同様に続く。</p>
<h3 id="pop-現在のディレクトリーの列挙中止">pop : 現在のディレクトリーの列挙中止</h3>
<p>メンバー関数<code>pop</code>を呼ぶと、現在列挙中のディレクトリーの列挙を取りやめ、親ディレクトリーに戻る。現在のディレクトリーが初期ディレクトリーの場合、つまり<code>depth() == 0</code>の場合は、終端イテレーターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    <span class="dt">void</span> pop();
    <span class="dt">void</span> pop(error_code&amp; ec);
} ;</code></pre></div>
<p>たとえば、カレントディレクトリーが以下のようなディレクトリーツリーで、イテレーターが以下に書かれた順番でファイルを列挙する環境の場合、</p>
<pre><code>a
b
b/a
b/c
b/d
c
d</code></pre>
<p>以下のようなプログラムを実行すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem ;

    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="kw">auto</span> <span class="at">const</span> p = canonical(<span class="st">&quot;b/a&quot;</span>) ;

    <span class="cf">for</span> ( ; iter != end ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

        <span class="cf">if</span> ( canonical(iter-&gt;path()) == p )
            iter.pop() ;
    }
}</code></pre></div>
<p>標準出力が指すファイルとその順番は以下のようになる。</p>
<pre><code>a
b
b/a
c
d</code></pre>
<p>&quot;<code>b/a</code>&quot;に到達した時点で<code>pop()</code>が呼ばれるので、それ以上のディレクトリー<code>b</code>下の列挙が中止され、親ディレクトリーであるカレントディレクトリーに戻る。</p>
<h3 id="recursion_pending-現在のディレクトリーの再帰をスキップ">recursion_pending : 現在のディレクトリーの再帰をスキップ</h3>
<p><code>disable_recursion_pending</code>は現在のディレクトリーの下を再帰的に列挙することをスキップする機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    <span class="dt">bool</span> recursion_pending() <span class="at">const</span> ;
    <span class="dt">void</span> disable_recursion_pending() ;
} ;</code></pre></div>
<p><code>recursion_pending()</code>は、直前のイテレーターのインクリメント操作の後に<code>disable_recursion_pending()</code>が呼ばれていない場合、<code>true</code>を返す。そうでない場合は<code>false</code>を返す。</p>
<p>言い換えれば、<code>disable_recursion_pending()</code>を呼んだ直後で、まだイテレーターのインクリメント操作をしていない場合、<code>recursion_pneding()</code>は<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;
    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = iter.recursion_pending() ;

    iter.disable_recursion_pending() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = iter.recursion_pending() ;

    ++iter ;
    <span class="co">//  true</span>
    <span class="dt">bool</span> b3 = iter.recursion_pending() ;


    iter.disable_recursion_pending() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b4 = iter.recursion_pending() ;
}</code></pre></div>
<p>現在<code>recursive_directory_iterator</code>が指しているファイルパスがディレクトリーである場合、そのイテレーターをインクリメントすると、そのディレクトリー下を再帰的に列挙することになる。しかし、<code>recursion_pending()</code>が<code>false</code>を返す場合、ディレクトリーの最適的な列挙はスキップされる。インクリメント操作が行われた後は<code>recursion_pending()</code>の結果は<code>true</code>に戻る。</p>
<p>つまり、<code>disable_recursion_pending</code>は、現在指しているディレクトリー下を再帰的に列挙することをスキップする機能を提供する。</p>
<p>たとえば、カレントディレクトリーが以下のようなディレクトリーツリーで、イテレーターが以下に書かれた順番でファイルを列挙する環境の場合、</p>
<pre><code>a
b
b/a
b/c
b/d
c
d</code></pre>
<p>以下のようなプログラムを実行すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem ;

    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="kw">auto</span> <span class="at">const</span> p = canonical(<span class="st">&quot;b/a&quot;</span>) ;

    <span class="cf">for</span> ( ; iter != end ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

        <span class="cf">if</span> ( iter-&gt;is_directory() )
            iter.disable_recursion_pending() ;
    }
}</code></pre></div>
<p>標準出力が指すファイルとその順番は以下のようになる。</p>
<pre><code>a
b
c
d</code></pre>
<p>このプログラムはディレクトリーであれば必ず<code>disable_recursion_pending()</code>が呼ばれるので、サブディレクトリーの再帰的な列挙は行われず、結果的に動作は<code>directory_iterator</code>と同じになる。</p>
<p><code>disable_recursion_pending</code>を呼び出すことによって、選択的にディレクトリーの再帰的な列挙をスキップさせることができる。</p>
<h2 id="ファイルシステム操作関数">ファイルシステム操作関数</h2>
<h3 id="ファイルパス取得">ファイルパス取得</h3>
<h4 id="current_path">current_path</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path current_path();
path current_path(error_code&amp; ec);</code></pre></div>
<p>カレント・ワーキング・ディレクトリー（current working directory）への絶対パスを返す。</p>
<h4 id="temp_directory_path">temp_directory_path</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path temp_directory_path();
path temp_directory_path(error_code&amp; ec);</code></pre></div>
<p>一時ファイルを作成するのに最適な一時ディレクトリー（temporary directory）へのファイルパスを返す。</p>
<h3 id="ファイルパス操作">ファイルパス操作</h3>
<h4 id="absolute">absolute</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path absolute(<span class="at">const</span> path&amp; p);
path absolute(<span class="at">const</span> path&amp; p, error_code&amp; ec);</code></pre></div>
<p><code>p</code>への絶対パスを返す。<code>p</code>の指すファイルが存在しない場合の挙動は未規定。</p>
<h4 id="canonical">canonical</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path canonical(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base = current_path());
path canonical(<span class="at">const</span> path&amp; p, error_code&amp; ec);
path canonical(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base, error_code&amp; ec);</code></pre></div>
<p>存在するファイルへのファイルパス<code>p</code>への、シンボリックリンク、カレントディレクトリー（<code>.</code>）、親ディレクトリー（<code>..</code>）の存在しない絶対パスを返す。</p>
<h4 id="weakly_canonical">weakly_canonical</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path weakly_canonical(<span class="at">const</span> path&amp; p);
path weakly_canonical(<span class="at">const</span> path&amp; p, error_code&amp; ec);</code></pre></div>
<p>ファイルパス<code>p</code>のシンボリックリンクが解決され、正規化されたパスを返す。ファイルパスの正規化についての定義は長くなるので省略。</p>
<h4 id="relative">relative</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path relative(<span class="at">const</span> path&amp; p, error_code&amp; ec);
path relative(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base = current_path());
path relative(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base, error_code&amp; ec);</code></pre></div>
<p>ファイルパス<code>base</code>からファイルパス<code>p</code>に対する相対パスを返す。</p>
<h4 id="proximate">proximate</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path proximate(<span class="at">const</span> path&amp; p, error_code&amp; ec);
path proximate(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base = current_path());
path proximate(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base, error_code&amp; ec);</code></pre></div>
<p>ファイルパス<code>base</code>からのファイルパス<code>p</code>に対する相対パスが空パスでなければ相対パスを返す。相対パスが空パスならば<code>p</code>が返る。</p>
<h3 id="作成">作成</h3>
<h4 id="create_directory">create_directory</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> create_directory(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> create_directory(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>p</code>の指すディレクトリーを1つ作成する。新しいディレクトリーが作成できた場合は<code>true</code>を、作成できなかった場合は<code>false</code>を返す。<code>p</code>が既存のディレクトリーを指していて新しいディレクトリーが作成できなかった場合はエラーにはならない。単に<code>false</code>が返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> create_directory(
    <span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; existing_p);

<span class="dt">bool</span> create_directory(
    <span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; existing_p,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>新しく作成するディレクトリー<code>p</code>のアトリビュートを既存のディレクトリー<code>existing_p</code>と同じものにする。</p>
<h4 id="create_directories">create_directories</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> create_directories(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> create_directories(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>p</code>の中のディレクトリーで存在しないものをすべて作成する。</p>
<p>以下のプログラムは、カレントディレクトリーの下のディレクトリー<code>a</code>の下のディレクトリー<code>b</code>の下にディレクトリー<code>c</code>を作成する。もし、途中のディレクトリーである<code>a</code>, <code>b</code>が存在しない場合、それも作成する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;
    create_directories(<span class="st">&quot;./a/b/c&quot;</span>) ;
}</code></pre></div>
<p>戻り値は、ディレクトリーを作成した場合<code>true</code>, そうでない場合<code>false</code>。</p>
<h4 id="create_directory_symlink">create_directory_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> create_directory_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink);
<span class="dt">void</span> create_directory_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ディレクトリー<code>to</code>に解決されるシンボリックリンク<code>new_symlink</code>を作成する。</p>
<p>一部のOSでは、ディレクトリーへのシンボリックリンクとファイルへのシンボリックリンクを作成時に明示的に区別する必要がある。ポータブルなコードはディレクトリーへのシンボリックリンクを作成するときには<code>create_symlink</code>ではなく<code>create_directory_symlink</code>を使うべきである。</p>
<p>一部のOSはシンボリックリンクをサポートしていない。ポータブルなコードでは注意すべきである。</p>
<h4 id="create_symlink">create_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> create_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink);
<span class="dt">void</span> create_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>to</code>に解決されるシンボリックリンク<code>new_symlink</code>を作成する。</p>
<h4 id="create_hard_link">create_hard_link</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> create_hard_link(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_hard_link);
<span class="dt">void</span> create_hard_link(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_hard_link,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>to</code>に解決されるハードリンク<code>new_hard_link</code>を作成する。</p>
<h3 id="コピー">コピー</h3>
<h4 id="copy_file">copy_file</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to);
<span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
                error_code&amp; ec) <span class="kw">noexcept</span>;
<span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
                copy_options options);
<span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
                copy_options options,
                error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>from</code>のファイルをファイルパス<code>to</code>にコピーする。</p>
<p><code>copy_options</code>はコピーの挙動を変えるビットマスクの<code>enum</code>型で、以下の<code>enum</code>値がサポートされている。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>none</code></td>
<td align="left">デフォルト、ファイルがすでに存在する場合はエラー</td>
</tr>
<tr class="even">
<td align="left"><code>skip_existing</code></td>
<td align="left">既存のファイルを上書きしない。スキップはエラーとして報告しない</td>
</tr>
<tr class="odd">
<td align="left"><code>overwrite_existing</code></td>
<td align="left">既存のファイルを上書きする</td>
</tr>
<tr class="even">
<td align="left"><code>update_existing</code></td>
<td align="left">既存のファイルが上書きしようとするファイルより古ければ上書きする</td>
</tr>
</tbody>
</table>
<h4 id="copy">copy</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to);
<span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
            error_code&amp; ec) <span class="kw">noexcept</span>;
<span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
            copy_options options);
<span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
            copy_options options,
            error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>from</code>のファイルをファイルパス<code>to</code>にコピーする。</p>
<p><code>copy_options</code>はコピーの挙動を変えるビットマスク型の<code>enum</code>型で、以下の<code>enum</code>値がサポートされている。</p>
<ul>
<li>サブディレクトリーに関する指定</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>none</code></td>
<td align="left">デフォルト、サブディレクトリーはコピーしない</td>
</tr>
<tr class="even">
<td align="left"><code>recursive</code></td>
<td align="left">サブディレクトリーとその中身もコピーする</td>
</tr>
</tbody>
</table>
<ul>
<li>シンボリックリンクに関する指定</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>none</code></td>
<td align="left">デフォルト、シンボリックリンクをフォローする</td>
</tr>
<tr class="even">
<td align="left"><code>copy_symlinks</code></td>
<td align="left">シンボリックリンクをシンボリックリンクとしてコピーする。シンボリックリンクが指すファイルを直接コピーしない</td>
</tr>
<tr class="odd">
<td align="left"><code>skip_symlinks</code></td>
<td align="left">シンボリックリンクを無視する</td>
</tr>
</tbody>
</table>
<ul>
<li>コピー方法に関する指定</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>none</code></td>
<td align="left">デフォルト、ディレクトリー下の中身をコピーする</td>
</tr>
<tr class="even">
<td align="left"><code>directories_only</code></td>
<td align="left">ディレクトリー構造のみをコピーする。非ディレクトリーファイルはコピーしない</td>
</tr>
<tr class="odd">
<td align="left"><code>create_symlinks</code></td>
<td align="left">ファイルをコピーするのではなく、シンボリックリンクを作成する。コピー先がカレントディレクトリーではない場合、コピー元のファイルパスは絶対パスでなければならない</td>
</tr>
<tr class="even">
<td align="left"><code>create_hard_links</code></td>
<td align="left">ファイルをコピーするのではなく、ハードリンクを作成する</td>
</tr>
</tbody>
</table>
<h4 id="copy_symlink">copy_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> copy_symlink(  <span class="at">const</span> path&amp; existing_symlink,
                    <span class="at">const</span> path&amp; new_symlink);
<span class="dt">void</span> copy_symlink(  <span class="at">const</span> path&amp; existing_symlink,
                    <span class="at">const</span> path&amp; new_symlink,
                    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>existing_symlink</code>を<code>new_symlink</code>にコピーする。</p>
<h3 id="削除">削除</h3>
<h4 id="remove">remove</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> remove(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> remove(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>p</code>の指すファイルが存在するのであれば削除する。ファイルがシンボリックリンクの場合、シンボリックリンクファイルが削除される。フォロー先は削除されない。</p>
<p>戻り値として、ファイルが存在しない場合<code>false</code>を返す。それ以外の場合<code>true</code>を返す。<code>error_code</code>でエラー通知を受け取る関数オーバーロードでは、エラーならば<code>false</code>が返る。</p>
<h4 id="remove_all">remove_all</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">uintmax_t</span> remove_all(<span class="at">const</span> path&amp; p);
<span class="dt">uintmax_t</span> remove_all(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>p</code>の下の存在するファイルをすべて削除した後、<code>p</code>の指すファイルも削除する。</p>
<p>つまり、<code>p</code>がディレクトリーファイルを指していて、そのディレクトリー下にサブディレクトリーやファイルが存在する場合、それらがすべて削除され、ディレクトリー<code>p</code>も削除される。</p>
<p><code>p</code>がディレクトリーではないファイルを指す場合、<code>p</code>が削除される。</p>
<p>戻り値として、削除したファイルの個数が返る。<code>error_code</code>でエラー通知を受け取る関数オーバーロードの場合、エラーならば<code>static_cast&lt;uintmax_t&gt;(-1)</code>が返る。</p>
<h3 id="変更">変更</h3>
<h4 id="permissions">permissions</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> permissions(   <span class="at">const</span> path&amp; p, perms prms,
                    perm_options opts=perm_options::replace);
<span class="dt">void</span> permissions(   <span class="at">const</span> path&amp; p, perms prms,
                    error_code&amp; ec) <span class="kw">noexcept</span>;
<span class="dt">void</span> permissions(   <span class="at">const</span> path&amp; p, perms prms,
                    perm_options opts,
                    error_code&amp; ec);</code></pre></div>
<p>ファイルパス<code>p</code>のパーミッションを変更する。</p>
<p><code>opts</code>は<code>perm_options</code>型の<code>enum</code>値、<code>replace</code>, <code>add</code>, <code>remove</code>のうちいずれか1つと、別途<code>nofollow</code>を指定することができる。省略した場合は<code>replace</code>になる。</p>
<p>カレントディレクトリーに存在するファイル<code>foo</code>を、すべてのユーザーに対して実行権限を付加するには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    permissions( <span class="st">&quot;./foo&quot;</span>, perms(<span class="bn">0111</span>), perm_options::add ) ;
}</code></pre></div>
<p><code>perm_options</code>は以下のような<code>enum</code>値を持つ。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>replace</code></td>
<td align="left">ファイルのパーミッションを<code>prms</code>で置き換える</td>
</tr>
<tr class="even">
<td align="left"><code>add</code></td>
<td align="left">ファイルのパーミッションに<code>prms</code>で指定されたものを追加する</td>
</tr>
<tr class="odd">
<td align="left"><code>remove</code></td>
<td align="left">ファイルのパーミッションから<code>prms</code>で指定されたものを取り除く</td>
</tr>
<tr class="even">
<td align="left"><code>nofollow</code></td>
<td align="left">ファイルがシンボリックリンクの場合、シンボリックリンクのフォロー先のファイルではなく、シンボリックリンクそのもののパーミッションを変更する</td>
</tr>
</tbody>
</table>
<p>たとえば、パーミッションを置き換えつつ、シンボリックリンクそのもののパーミッションを書き換えたい場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">perm_options opts = perm_options::replace | perm_options::nofollow ;</code></pre></div>
<p>と書く。</p>
<h4 id="rename">rename</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rename(<span class="at">const</span> path&amp; old_p, <span class="at">const</span> path&amp; new_p);
<span class="dt">void</span> rename(<span class="at">const</span> path&amp; old_p, <span class="at">const</span> path&amp; new_p,
            error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイル<code>old_p</code>をファイル<code>new_p</code>にリネームする。</p>
<p><code>old_p</code>と<code>new_p</code>が同じ存在するファイルを指す場合、何もしない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std:filesystem ;

    <span class="co">// 何もしない</span>
    rename(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;foo&quot;</span>) ;
}</code></pre></div>
<p>それ以外の場合、リネームに伴って以下のような挙動も発生する。</p>
<p>もし、リネーム前に<code>new_p</code>が既存のファイルを指していた場合、リネームに伴って<code>new_p</code>は削除される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;

    {
        <span class="bu">std::</span>ofstream old_p(<span class="st">&quot;old_p&quot;</span>), new_p(<span class="st">&quot;new_p&quot;</span>) ;

        old_p &lt;&lt; <span class="st">&quot;old_p&quot;</span> ;
        new_p &lt;&lt; <span class="st">&quot;new_p&quot;</span> ;
    }

    <span class="co">// ファイルold_pの内容は&quot;old_p&quot;</span>
    <span class="co">// ファイルnew_pの内容は&quot;new_p&quot;</span>

    <span class="co">// ファイルold_pをnew_pにリネーム</span>
    <span class="co">// もともとのnew_pは削除される</span>
    rename(<span class="st">&quot;old_p&quot;</span>, <span class="st">&quot;new_p&quot;</span>) ;

    <span class="bu">std::</span>ifstream new_p(<span class="st">&quot;new_p&quot;</span>) ;

    <span class="bu">std::</span>string text ;
    new_p &gt;&gt; text ;

    <span class="co">// &quot;old_p&quot;</span>
    <span class="bu">std::</span>cout &lt;&lt; text ;
}</code></pre></div>
<p>もし、<code>new_p</code>が既存の空ディレクトリーを指していた場合、POSIX準拠OSであれば、リネームに伴って<code>new_p</code>は削除される。他のOSではエラーになるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;

    create_directory(<span class="st">&quot;old_p&quot;</span>) ;
    create_directory(<span class="st">&quot;new_p&quot;</span>) ;

    <span class="co">// POSIX準拠環境であればエラーにならないことが保証される</span>
    rename(<span class="st">&quot;old_p&quot;</span>, <span class="st">&quot;new_p&quot;</span>) ;
}</code></pre></div>
<p><code>old_p</code>がシンボリックリンクの場合、フォロー先ではなくシンボリックリンクファイルがリネームされる。</p>
<h4 id="resize_file">resize_file</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> resize_file(   <span class="at">const</span> path&amp; p, <span class="dt">uintmax_t</span> new_size);
<span class="dt">void</span> resize_file(   <span class="at">const</span> path&amp; p, <span class="dt">uintmax_t</span> new_size,
                    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>path</code>の指すファイルのファイルサイズを<code>new_size</code>にする。</p>
<p>リサイズはPOSIXの<code>truncate()</code>で行われたかのように振る舞う。つまり、ファイルを小さくリサイズした場合、余計なデータは捨てられる。ファイルを大きくリサイズした場合、増えたデータは<code>null</code>バイト（<code>\0</code>）でパディングされる。ファイルの最終アクセス日時も更新される。</p>
<h3 id="情報取得">情報取得</h3>
<h4 id="ファイルタイプの判定">ファイルタイプの判定</h4>
<p>ファイルタイプを表現する<code>file_type</code>型の<code>enum</code>があり、その<code>enum</code>値は以下のようになっている。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>none</code></td>
<td align="left">ファイルタイプが決定できないかエラー</td>
</tr>
<tr class="even">
<td align="left"><code>not_found</code></td>
<td align="left">ファイルが発見できなかったことを示す疑似ファイルタイプ</td>
</tr>
<tr class="odd">
<td align="left"><code>regular</code></td>
<td align="left">通常のファイル</td>
</tr>
<tr class="even">
<td align="left"><code>directory</code></td>
<td align="left">ディレクトリーファイル</td>
</tr>
<tr class="odd">
<td align="left"><code>symlink</code></td>
<td align="left">シンボリックリンクファイル</td>
</tr>
<tr class="even">
<td align="left"><code>block</code></td>
<td align="left">ブロックスペシャルファイル</td>
</tr>
<tr class="odd">
<td align="left"><code>fifo</code></td>
<td align="left">FIFOもしくはパイプファイル</td>
</tr>
<tr class="even">
<td align="left"><code>socket</code></td>
<td align="left">ソケットファイル</td>
</tr>
<tr class="odd">
<td align="left"><code>unknown</code></td>
<td align="left">ファイルは存在するがファイルタイプは決定できない</td>
</tr>
</tbody>
</table>
<p>この他に、実装依存のファイルタイプが追加されている可能性がある。</p>
<p>ファイルタイプを調べるには、<code>file_status</code>のメンバー関数<code>type</code>の戻り値を調べればよい。</p>
<p>以下のプログラムは、カレントディレクトリーに存在するファイル<code>foo</code>がディレクトリーかどうかを調べるコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="kw">auto</span> s = status(<span class="st">&quot;./foo&quot;</span>) ;
    <span class="dt">bool</span> b = s.type() == <span class="dt">file_type</span>::directory ;
}</code></pre></div>
<p>また、<code>status</code>もしくは<code>path</code>からファイルタイプがディレクトリーであるかどうかを判定できる<code>is_directory</code>も用意されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="dt">bool</span> b1 = is_directory(<span class="st">&quot;./foo&quot;</span>) ;

    <span class="kw">auto</span> s = status(<span class="st">&quot;./foo&quot;</span>) ;
    <span class="dt">bool</span> b2 = is_directory(s) ;
}</code></pre></div>
<p><code>file_status</code>はファイル情報をキャッシュするので、物理ファイルシステムに変更を加えない状態で、同じファイルに対して何度もファイル情報を取得する場合は、<code>file_status</code>を使ったほうがよい。</p>
<p>このような<code>is_x</code>という形式のフリー関数は、いずれも以下の形式を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> is_x(file_status s) <span class="kw">noexcept</span>;
<span class="dt">bool</span> is_x(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> is_x(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>以下はフリー関数の名前と、どのファイルタイプであるかを判定する表だ。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>is_regular_file</code></td>
<td align="left">通常のファイル</td>
</tr>
<tr class="even">
<td align="left"><code>is_directory</code></td>
<td align="left">ディレクトリーファイル</td>
</tr>
<tr class="odd">
<td align="left"><code>is_symlink</code></td>
<td align="left">シンボリックリンクファイル</td>
</tr>
<tr class="even">
<td align="left"><code>is_block</code></td>
<td align="left">ブロックスペシャルファイル</td>
</tr>
<tr class="odd">
<td align="left"><code>is_fifo</code></td>
<td align="left">FIFOもしくはパイプファイル</td>
</tr>
<tr class="even">
<td align="left"><code>is_socket</code></td>
<td align="left">ソケットファイル</td>
</tr>
</tbody>
</table>
<p>また、単一のファイルタイプを調べるのではない以下のような名前のフリー関数が存在する。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>is_other</code></td>
<td align="left">ファイルが存在し、通常のファイルでもディレクトリーでもシンボリックリンクでもないタイプ</td>
</tr>
<tr class="even">
<td align="left"><code>is_empty</code></td>
<td align="left">ファイルがディレクトリーの場合、ディレクトリー下が空であれば<code>true</code>を返す。<br>ファイルが非ディレクトリーの場合、ファイルサイズが0であれば<code>true</code>を返す。</td>
</tr>
</tbody>
</table>
<h4 id="status">status</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">file_status status(<span class="at">const</span> path&amp; p);
file_status status(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>p</code>のファイルの情報を格納する<code>file_status</code>を返す。</p>
<p><code>p</code>がシンボリックリンクの場合、フォロー先のファイルの<code>file_status</code>を返す。</p>
<h4 id="status_known">status_known</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> status_known(file_status s) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>s.type() != file_type::none</code>を返す。</p>
<h4 id="symlink_status">symlink_status</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">file_status symlink_status(<span class="at">const</span> path&amp; p);
file_status symlink_status(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>status</code>と同じだが、<code>p</code>がシンボリックリンクの場合、そのシンボリックリンクファイルの<code>status</code>を返す。</p>
<h4 id="equivalent">equivalent</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> equivalent(<span class="at">const</span> path&amp; p1, <span class="at">const</span> path&amp; p2);
<span class="dt">bool</span> equivalent(<span class="at">const</span> path&amp; p1, <span class="at">const</span> path&amp; p2,
                error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>p1</code>と<code>p2</code>が物理ファイルシステム上、同一のファイルである場合、<code>true</code>を返す。そうでない場合<code>false</code>を返す。</p>
<h4 id="exists">exists</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> exists(file_status s) <span class="kw">noexcept</span>;
<span class="dt">bool</span> exists(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> exists(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>s</code>, <code>p</code>が指すファイルが存在するのであれば<code>true</code>を返す。そうでない場合<code>false</code>を返す。</p>
<h4 id="file_size">file_size</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">uintmax_t</span> file_size(<span class="at">const</span> path&amp; p);
<span class="dt">uintmax_t</span> file_size(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>p</code>の指すファイルのファイルサイズを返す。</p>
<p>ファイルが存在しない場合エラーとなる。ファイルが通常のファイルの場合、ファイルサイズを返す。それ以外の場合、挙動は実装依存となる。</p>
<p>エラー通知を<code>error_code</code>で受け取る関数オーバーロードでエラーのとき、戻り値は<code>static_cast&lt;uintmax_t&gt;(-1)</code>となる。</p>
<h4 id="hard_link_count">hard_link_count</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">uintmax_t</span> hard_link_count(<span class="at">const</span> path&amp; p);
<span class="dt">uintmax_t</span> hard_link_count(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>p</code>の指すファイルのハードリンク数を返す。</p>
<p>エラー通知を<code>error_code</code>で受け取る関数オーバーロードでエラーのとき、戻り値は<code>static_cast&lt;uintmax_t&gt;(-1)</code>となる。</p>
<h4 id="last_write_time">last_write_time</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">file_time_type</span> last_write_time( <span class="at">const</span> path&amp; p);
<span class="dt">file_time_type</span> last_write_time( <span class="at">const</span> path&amp; p,
                                error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>p</code>の指すファイルの最終更新日時を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> last_write_time(   <span class="at">const</span> path&amp; p, <span class="dt">file_time_type</span> new_time);
<span class="dt">void</span> last_write_time(   <span class="at">const</span> path&amp; p, <span class="dt">file_time_type</span> new_time,
                        error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p><code>p</code>の指すファイルの最終更新日時を<code>new_time</code>にする。</p>
<p><code>last_write_time(p, new_time)</code>を呼び出した後に、<code>last_write_time(p) == new_time</code>である保証はない。なぜならば、物理ファイルシステムの実装に起因する時刻の分解能や品質の問題があるからだ。</p>
<p><code>file_time_type</code>は、<code>std::chrono_time_point</code>の特殊化で以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>filesystem {
    <span class="kw">using</span> file_time_time = <span class="bu">std::</span>chrono<span class="bu">::</span>time_point&lt; trivial-clock &gt; ;
}</code></pre></div>
<p><code>trivial-clock</code>とは、クロック（より正確にはTrivialClock）の要件を満たすクロックで、ファイルシステムのタイムスタンプの値を正確に表現できるものとされている。クロックの具体的な型は実装依存なので、完全にポータブルなコードではファイルシステムで時間を扱うのは極めて困難になる。せいぜい現在時刻を設定するとか、差分の時間を設定するぐらいしかできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono ;
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// 最終更新日時を取得</span>
    <span class="kw">auto</span> timestamp = last_write_time( <span class="st">&quot;foo&quot;</span> ) ;

    <span class="co">// 時刻を1時間進める</span>
    timestamp += <span class="er">1h</span> ;
    <span class="co">// 更新</span>
    last_write_time( <span class="st">&quot;foo&quot;</span>, timestamp ) ;


    <span class="co">// 現在時刻を取得</span>
    <span class="kw">auto</span> now = <span class="dt">file_time_type</span>::clock::now() ;

    last_write_time( <span class="st">&quot;foo&quot;</span>, now ) ;
}</code></pre></div>
<p>ただし、多くの実装では<code>file_time_type</code>として、<code>time_point&lt;std::chrono::system_clock&gt;</code>が使われている。<code>file_time_type::clock</code>が<code>system_clock</code>であれば、<code>system_clock::to_time_t</code>と<code>system_clock::from_time_t</code>によって<code>time_t</code>型との相互変換ができるために、いくぶんマシになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// file_time_type::clockがsystem_clockである場合</span>

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono ;

    <span class="co">// 最終更新日時を文字列で得る</span>
    <span class="kw">auto</span> time_point_value = last_write_time( <span class="st">&quot;foo&quot;</span> ) ;
    <span class="dt">time_t</span> time_t_value =
        system_clock::<span class="dt">to_time_t</span>( time_point_value ) ;
    <span class="bu">std::</span>cout &lt;&lt; ctime( &amp;time_t_value ) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

   
    <span class="co">// 最終更新日時を2017-10-12 19:02:58に設定</span>
    tm struct_tm{} ;
    struct_tm.tm_year = <span class="dv">2017</span> - <span class="dv">1900</span> ;
    struct_tm.tm_mon = <span class="dv">10</span> ;
    struct_tm.tm_mday = <span class="dv">12</span> ;
    struct_tm.tm_hour = <span class="dv">19</span> ;
    struct_tm.tm_min = <span class="dv">2</span> ;
    struct_tm.tm_sec = <span class="dv">58</span> ;

    <span class="dt">time_t</span> timestamp = <span class="bu">std::</span>mktime( &amp;struct_tm ) ;
    <span class="kw">auto</span> tp = system_clock::<span class="dt">from_time_t</span>( timestamp ) ;

    last_write_time( <span class="st">&quot;foo&quot;</span>, tp ) ;
}</code></pre></div>
<p>あまりマシになっていないように見えるのは、C++では現在<code>&lt;chrono&gt;</code>から利用できるC++風のモダンなカレンダーライブラリがないからだ。この問題は将来の規格改定で改善されるだろう。</p>
<h4 id="read_symlink">read_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path read_symlink(<span class="at">const</span> path&amp; p);
path read_symlink(<span class="at">const</span> path&amp; p, error_code&amp; ec);</code></pre></div>
<p>シンボリックリンク<code>p</code>の解決される先のファイルパスを返す。</p>
<p><code>p</code>がシンボリックリンクではない場合はエラーになる。</p>
<h4 id="space">space</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">space_info space(<span class="at">const</span> path&amp; p);
space_info space(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパス<code>p</code>が指す先の容量を取得する。</p>
<p>クラス<code>space_info</code>は以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> space_info {
    <span class="dt">uintmax_t</span> capacity;
    <span class="dt">uintmax_t</span> free;
    <span class="dt">uintmax_t</span> available;
};</code></pre></div>
<p>この関数は、POSIXの<code>statvfs</code>関数を呼び出した結果の<code>struct statvfs</code>の<code>f_blocks</code>, <code>f_bfree</code>, <code>f_bavail</code>メンバーを、それぞれ<code>f_frsize</code>で乗じて、<code>space_info</code>のメンバー<code>capacity</code>, <code>free</code>, <code>available</code>として返す。値の決定できないメンバーには<code>static_cast&lt;uintmax_t&gt;(-1)</code>が代入される。</p>
<p>エラー通知を<code>error_code</code>で返す関数オーバーロードがエラーの場合、<code>space_info</code>のメンバーにはすべて<code>static_cast&lt;uintmax_t&gt;(-1)</code>が代入される。</p>
<p><code>space_info</code>のメンバーの意味をわかりやすく説明すると、以下の表のようになる。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>capacity</code></td>
<td align="left">総容量</td>
</tr>
<tr class="even">
<td align="left"><code>free</code></td>
<td align="left">空き容量</td>
</tr>
<tr class="odd">
<td align="left"><code>available</code></td>
<td align="left">権限のないユーザーが使える空き容量</td>
</tr>
</tbody>
</table>
</body>
</html>
