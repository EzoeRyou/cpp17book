<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2017-02-28" />
  <title>C++17の新機能</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">C++17の新機能</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2017-02-28</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a><ul>
<li><a href="#cの規格">C++の規格</a><ul>
<li><a href="#c98">C++98</a></li>
<li><a href="#c03">C++03</a></li>
<li><a href="#c11">C++11</a></li>
<li><a href="#c14">C++14</a></li>
<li><a href="#c17">C++17</a></li>
</ul></li>
<li><a href="#cの将来の規格">C++の将来の規格</a><ul>
<li><a href="#c20">C++20</a></li>
</ul></li>
<li><a href="#コア言語とライブラリ">コア言語とライブラリ</a></li>
</ul></li>
<li><a href="#sd-6-cのための機能テスト推奨">SD-6 C++のための機能テスト推奨</a><ul>
<li><a href="#機能テストマクロ">機能テストマクロ</a></li>
<li><a href="#has_include式-ヘッダーファイルの存在を判定する">__has_include式 : ヘッダーファイルの存在を判定する</a></li>
<li><a href="#has_cpp_attribute式">__has_cpp_attribute式</a></li>
</ul></li>
<li><a href="#c14のコア言語の新機能">C++14のコア言語の新機能</a><ul>
<li><a href="#二進数リテラル">二進数リテラル</a></li>
<li><a href="#数値区切り文字">数値区切り文字</a></li>
<li><a href="#deprecated属性">[[deprecated]]属性</a></li>
<li><a href="#通常の関数の戻り値の型推定">通常の関数の戻り値の型推定</a></li>
<li><a href="#decltypeauto-厳格なauto">decltype(auto): 厳格なauto</a></li>
<li><a href="#ジェネリックラムダ">ジェネリックラムダ</a></li>
<li><a href="#初期化ラムダキャプチャー">初期化ラムダキャプチャー</a></li>
<li><a href="#変数テンプレート">変数テンプレート</a><ul>
<li><a href="#意味は同じだが型が違う定数">意味は同じだが型が違う定数</a></li>
<li><a href="#traitsのラッパー">traitsのラッパー</a></li>
</ul></li>
<li><a href="#constexpr関数の制限緩和">constexpr関数の制限緩和</a></li>
<li><a href="#メンバー初期化子とアグリゲート初期化の組み合わせ">メンバー初期化子とアグリゲート初期化の組み合わせ</a></li>
<li><a href="#サイズ付き解放関数">サイズ付き解放関数</a></li>
</ul></li>
<li><a href="#c17のコア言語の新機能">C++17のコア言語の新機能</a><ul>
<li><a href="#トライグラフの廃止">トライグラフの廃止</a></li>
<li><a href="#進数浮動小数点数リテラル">16進数浮動小数点数リテラル</a></li>
<li><a href="#utf-8文字リテラル">UTF-8文字リテラル</a></li>
<li><a href="#関数型としての例外指定">関数型としての例外指定</a></li>
<li><a href="#fold式">fold式</a></li>
<li><a href="#ラムダ式でthisのコピーキャプチャー">ラムダ式で*thisのコピーキャプチャー</a></li>
<li><a href="#constexprラムダ式">constexprラムダ式</a></li>
<li><a href="#文字列なしstatic_assert">文字列なしstatic_assert</a></li>
<li><a href="#ネストされた名前空間定義">ネストされた名前空間定義</a></li>
<li><a href="#fallthrough属性">[[fallthrough]]属性</a></li>
<li><a href="#nodiscard属性">[[nodiscard]]属性</a></li>
<li><a href="#maybe_unused属性">[[maybe_unused]]属性</a></li>
<li><a href="#演算子のオペランドの評価順序の固定">演算子のオペランドの評価順序の固定</a></li>
<li><a href="#constexpr-if文-コンパイル時条件分岐">constexpr if文 : コンパイル時条件分岐</a><ul>
<li><a href="#実行時の条件分岐">実行時の条件分岐</a></li>
<li><a href="#プリプロセス時の条件分岐">プリプロセス時の条件分岐</a></li>
<li><a href="#コンパイル時の条件分岐">コンパイル時の条件分岐</a></li>
<li><a href="#超上級者向け解説">超上級者向け解説</a></li>
<li><a href="#constexpr-ifでは解決できない問題">constexpr ifでは解決できない問題</a></li>
<li><a href="#constexpr-ifで解決できる問題">constexpr ifで解決できる問題</a></li>
</ul></li>
<li><a href="#初期化文つき条件文">初期化文つき条件文</a></li>
<li><a href="#クラステンプレートのコンストラクターからの実引数推定">クラステンプレートのコンストラクターからの実引数推定</a><ul>
<li><a href="#推定ガイド">推定ガイド</a></li>
</ul></li>
<li><a href="#autoによる非型テンプレートパラメーターの宣言">autoによる非型テンプレートパラメーターの宣言</a></li>
<li><a href="#using属性名前空間">using属性名前空間</a></li>
<li><a href="#非標準属性の無視">非標準属性の無視</a></li>
<li><a href="#構造化束縛">構造化束縛</a><ul>
<li><a href="#超上級者向け解説-1">超上級者向け解説</a></li>
<li><a href="#構造化束縛宣言の仕様">構造化束縛宣言の仕様</a></li>
<li><a href="#初期化子の型が配列の場合">初期化子の型が配列の場合</a></li>
<li><a href="#初期化子の型が配列ではなくstdtuple_sizeeが完全形の名前である場合">初期化子の型が配列ではなく、std::tuple_size&lt;E&gt;が完全形の名前である場合</a></li>
<li><a href="#上記以外の場合">上記以外の場合</a></li>
</ul></li>
<li><a href="#inline変数">inline変数</a><ul>
<li><a href="#inlineの歴史的な意味">inlineの歴史的な意味</a></li>
<li><a href="#現代のinlineの意味">現代のinlineの意味</a></li>
<li><a href="#inline変数の意味">inline変数の意味</a></li>
</ul></li>
<li><a href="#可変長using宣言">可変長using宣言</a></li>
<li><a href="#std.byte">std::byte バイトを表現する型</a></li>
</ul></li>
<li><a href="#c17の型安全な値を格納するライブラリ">C++17の型安全な値を格納するライブラリ</a><ul>
<li><a href="#variant-型安全なunion">variant : 型安全なunion</a><ul>
<li><a href="#使い方">使い方</a></li>
<li><a href="#型非安全な古典的union">型非安全な古典的union</a></li>
<li><a href="#variantの宣言">variantの宣言</a></li>
<li><a href="#variantの初期化">variantの初期化</a><ul>
<li><a href="#デフォルト初期化">デフォルト初期化</a></li>
<li><a href="#コピー初期化">コピー初期化</a></li>
<li><a href="#variantのコンストラクターに値を渡した場合">variantのコンストラクターに値を渡した場合</a></li>
<li><a href="#in_place_typeによるemplace構築">in_place_typeによるemplace構築</a></li>
</ul></li>
<li><a href="#variantの破棄">variantの破棄</a></li>
<li><a href="#variantの代入">variantの代入</a></li>
<li><a href="#variantのemplace">variantのemplace</a></li>
<li><a href="#variantに値が入っているかどうかの確認">variantに値が入っているかどうかの確認</a><ul>
<li><a href="#valueless_by_exceptionメンバー関数">valueless_by_exceptionメンバー関数</a></li>
<li><a href="#indexメンバー関数">indexメンバー関数</a></li>
</ul></li>
<li><a href="#swap">swap</a></li>
<li><a href="#variant_sizet-variantが保持できる型の数を取得">variant_size&lt;T&gt; : variantが保持できる型の数を取得</a></li>
<li><a href="#variant_alternativei-t-インデックスから型を返す">variant_alternative&lt;I, T&gt; : インデックスから型を返す</a></li>
<li><a href="#holds_alternative-variantが指定した型の値を保持しているかどうかの確認">holds_alternative : variantが指定した型の値を保持しているかどうかの確認</a></li>
<li><a href="#getiv-インデックスから値の取得">get&lt;I&gt;(v) : インデックスから値の取得</a></li>
<li><a href="#gettv-型から値の取得">get&lt;T&gt;(v) : 型から値の取得</a></li>
<li><a href="#get_if-値を保持している場合に取得">get_if : 値を保持している場合に取得</a></li>
<li><a href="#variantの比較">variantの比較</a><ul>
<li><a href="#同一性の比較">同一性の比較</a></li>
<li><a href="#大小比較">大小比較</a></li>
</ul></li>
<li><a href="#visit-variantが保持している値を受け取る">visit : variantが保持している値を受け取る。</a></li>
</ul></li>
<li><a href="#any-どんな型の値でも保持できるクラス">any : どんな型の値でも保持できるクラス</a><ul>
<li><a href="#使い方-1">使い方</a></li>
<li><a href="#anyの構築と破棄">anyの構築と破棄</a></li>
<li><a href="#in_place_typeコンストラクター">in_place_typeコンストラクター</a></li>
<li><a href="#anyへの代入">anyへの代入</a></li>
<li><a href="#anyのメンバー関数">anyのメンバー関数</a><ul>
<li><a href="#emplace">emplace</a></li>
<li><a href="#reset-値の破棄">reset : 値の破棄</a></li>
<li><a href="#swap-スワップ">swap : スワップ</a></li>
<li><a href="#has_value-値を保持しているかどうか調べる">has_value : 値を保持しているかどうか調べる</a></li>
<li><a href="#type-保持している型のtype_infoを得る">type : 保持している型のtype_infoを得る</a></li>
</ul></li>
<li><a href="#anyのフリー関数">anyのフリー関数</a><ul>
<li><a href="#make_anyt-t型のanyを作る">make_any&lt;T&gt; : T型のanyを作る</a></li>
<li><a href="#any_cast-保持している値の取り出し">any_cast : 保持している値の取り出し</a></li>
</ul></li>
</ul></li>
<li><a href="#optional-値を保有しているかしていないクラス">optional : 値を保有しているか、していないクラス</a><ul>
<li><a href="#使い方-2">使い方</a></li>
<li><a href="#optionalのテンプレート実引数">optionalのテンプレート実引数</a></li>
<li><a href="#optionalの構築">optionalの構築</a></li>
<li><a href="#optionalの代入">optionalの代入</a></li>
<li><a href="#optionalの破棄">optionalの破棄</a></li>
<li><a href="#swap-1">swap</a></li>
<li><a href="#has_value-値を保持しているかどうか確認する">has_value : 値を保持しているかどうか確認する</a></li>
<li><a href="#operator-bool-値を保持しているかどうか確認する">operator bool : 値を保持しているかどうか確認する</a></li>
<li><a href="#value-保持している値を取得">value : 保持している値を取得</a></li>
<li><a href="#value_or-値もしくはデフォルト値を返す">value_or : 値もしくはデフォルト値を返す</a></li>
<li><a href="#reset-保持している値を破棄する">reset : 保持している値を破棄する</a></li>
<li><a href="#optional同士の比較">optional同士の比較</a><ul>
<li><a href="#同一性の比較-1">同一性の比較</a></li>
<li><a href="#大小比較-1">大小比較</a></li>
</ul></li>
<li><a href="#optionalとstdnulloptとの比較">optionalとstd::nulloptとの比較</a></li>
<li><a href="#optionaltとtの比較">optional&lt;T&gt;とTの比較</a></li>
<li><a href="#make_optionalt-optionaltを返す">make_optional&lt;T&gt; : optional&lt;T&gt;を返す</a></li>
<li><a href="#make_optionalt-args-...-optionaltをin_place_type構築して返す">make_optional&lt;T, Args ... &gt; : optional&lt;T&gt;をin_place_type構築して返す</a></li>
</ul></li>
</ul></li>
<li><a href="#string_view-文字列ラッパー">string_view : 文字列ラッパー</a><ul>
<li><a href="#使い方-3">使い方</a></li>
<li><a href="#basic_string_view">basic_string_view</a></li>
<li><a href="#文字列の所有非所有">文字列の所有、非所有</a></li>
<li><a href="#string_viewの構築">string_viewの構築</a><ul>
<li><a href="#デフォルト構築">デフォルト構築</a></li>
<li><a href="#null終端された文字型の配列へのポインター">null終端された文字型の配列へのポインター</a></li>
<li><a href="#文字型へのポインターと文字数">文字型へのポインターと文字数</a></li>
</ul></li>
<li><a href="#文字列クラスからの変換関数">文字列クラスからの変換関数</a></li>
<li><a href="#string_viewの操作">string_viewの操作</a><ul>
<li><a href="#remove_prefixremove_suffix-先頭末尾の要素の削除">remove_prefix/remove_suffix : 先頭、末尾の要素の削除</a></li>
</ul></li>
<li><a href="#ユーザー定義リテラル">ユーザー定義リテラル</a></li>
</ul></li>
<li><a href="#メモリーリソース-動的ストレージ確保ライブラリ">メモリーリソース : 動的ストレージ確保ライブラリ</a><ul>
<li><a href="#メモリーリソース">メモリーリソース</a><ul>
<li><a href="#メモリーリソースの使い方">メモリーリソースの使い方</a></li>
<li><a href="#メモリーリソースの作り方">メモリーリソースの作り方</a></li>
</ul></li>
<li><a href="#polymorphic_allocator-動的ポリモーフィズムを実現するアロケーター">polymorphic_allocator : 動的ポリモーフィズムを実現するアロケーター</a><ul>
<li><a href="#コンストラクター">コンストラクター</a></li>
</ul></li>
<li><a href="#プログラム全体で使われるメモリーリソースの取得">プログラム全体で使われるメモリーリソースの取得</a><ul>
<li><a href="#new_delete_resource">new_delete_resource()</a></li>
<li><a href="#null_memory_resource">null_memory_resource()</a></li>
<li><a href="#デフォルトリソース">デフォルトリソース</a></li>
</ul></li>
<li><a href="#標準ライブラリのメモリーリソース">標準ライブラリのメモリーリソース</a></li>
<li><a href="#プールリソース">プールリソース</a><ul>
<li><a href="#アルゴリズム">アルゴリズム</a></li>
<li><a href="#synchronizedunsynchronized_pool_resource">synchronized/unsynchronized_pool_resource</a></li>
<li><a href="#pool_options">pool_options</a></li>
<li><a href="#プールリソースのコンストラクター">プールリソースのコンストラクター</a></li>
<li><a href="#プールリソースのメンバー関数">プールリソースのメンバー関数</a><ul>
<li><a href="#release">release()</a></li>
<li><a href="#upstream_resource">upstream_resource()</a></li>
<li><a href="#options">options()</a></li>
</ul></li>
</ul></li>
<li><a href="#モノトニックバッファーリソース">モノトニックバッファーリソース</a><ul>
<li><a href="#アルゴリズム-1">アルゴリズム</a></li>
<li><a href="#コンストラクター-1">コンストラクター</a></li>
<li><a href="#その他の操作">その他の操作</a><ul>
<li><a href="#release-1">release()</a></li>
<li><a href="#upstream_resource-1">upstream_resource()</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#並列アルゴリズム">並列アルゴリズム</a><ul>
<li><a href="#並列実行について">並列実行について</a></li>
<li><a href="#使い方-4">使い方</a></li>
<li><a href="#並列アルゴリズム詳細">並列アルゴリズム詳細</a><ul>
<li><a href="#並列アルゴリズム-1">並列アルゴリズム</a></li>
<li><a href="#ユーザー提供する関数オブジェクトの制約">ユーザー提供する関数オブジェクトの制約</a><ul>
<li><a href="#実引数で与えられたオブジェクトを直接間接に変更してはならない">実引数で与えられたオブジェクトを直接、間接に変更してはならない</a></li>
<li><a href="#実引数で与えられたオブジェクトの一意性に依存してはならない">実引数で与えられたオブジェクトの一意性に依存してはならない</a></li>
<li><a href="#データ競合と同期">データ競合と同期</a></li>
</ul></li>
<li><a href="#例外">例外</a></li>
<li><a href="#実行ポリシー">実行ポリシー</a><ul>
<li><a href="#is_execution_policy-traits">is_execution_policy traits</a></li>
<li><a href="#シーケンス実行ポリシー">シーケンス実行ポリシー</a></li>
<li><a href="#パラレル実行ポリシー">パラレル実行ポリシー</a></li>
<li><a href="#パラレル非シーケンス実行ポリシー">パラレル非シーケンス実行ポリシー</a></li>
<li><a href="#実行ポリシーオブジェクト">実行ポリシーオブジェクト</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数学の特殊関数群">数学の特殊関数群</a><ul>
<li><a href="#ラゲール多項式laguerre-polynomials">ラゲール多項式(Laguerre polynomials)</a></li>
<li><a href="#ラゲール陪多項式associated-laguerre-polynomials">ラゲール陪多項式(Associated Laguerre polynomials)</a></li>
<li><a href="#ルジャンドル多項式legendre-polynomials">ルジャンドル多項式(Legendre polynomials)</a></li>
<li><a href="#sf.cmath.assoc_legendre">ルジャンドル陪関数(Associated Legendre functions)</a></li>
<li><a href="#球面ルジャンドル陪関数spherical-associated-legendre-functions">球面ルジャンドル陪関数(Spherical associated Legendre functions)</a></li>
<li><a href="#エルミート多項式hermite-polynomials">エルミート多項式(Hermite polynomials)</a></li>
<li><a href="#ベータ関数beta-function">ベータ関数(Beta function)</a></li>
<li><a href="#第1種完全楕円積分complete-elliptic-integral-of-the-first-kind">第1種完全楕円積分(Complete elliptic integral of the first kind)</a></li>
<li><a href="#第2種完全楕円積分complete-elliptic-integral-of-the-second-kind">第2種完全楕円積分(Complete elliptic integral of the second kind)</a></li>
<li><a href="#第3種完全楕円積分complete-elliptic-integral-of-the-third-kind">第3種完全楕円積分(Complete elliptic integral of the third kind)</a></li>
<li><a href="#sf.cmath.ellint_1">第1種不完全楕円積分(Incomplete elliptic integral of the first kind)</a></li>
<li><a href="#sf.cmath.ellint_2">第2種不完全楕円積分(Incomplete elliptic integroal of the second kind)</a></li>
<li><a href="#sf.cmath.ellint_3">第3種不完全楕円積分(Incomplete elliptic integral of the third kind)</a></li>
<li><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数(Cylindrical Bessel functions of the first kind)</a></li>
<li><a href="#sf.cmath.cyl_neumann">ノイマン関数(Cylindrical Neumann functions)</a></li>
<li><a href="#sf.cmath.cyl_bessel_i">第1種変形ベッセル関数(Regular modified cylindrical Bessel functions)</a></li>
<li><a href="#第2種変形ベッセル関数irregular-modified-cylindrical-bessel-functions">第2種変形ベッセル関数(Irregular modified cylindrical Bessel functions)</a></li>
<li><a href="#第1種球ベッセル関数spherical-bessel-functions-of-the-first-kind">第1種球ベッセル関数(Spherical Bessel functions of the first kind)</a></li>
<li><a href="#球ノイマン関数spherical-neumann-functions">球ノイマン関数(Spherical Neumann functions)</a></li>
<li><a href="#指数積分exponential-integral">指数積分(Exponential integral)</a></li>
<li><a href="#リーマンゼータ関数riemann-zeta-function">リーマンゼータ関数(Riemann zeta function)</a></li>
</ul></li>
<li><a href="#その他の標準ライブラリ">その他の標準ライブラリ</a><ul>
<li><a href="#ハードウェア干渉サイズキャッシュライン">ハードウェア干渉サイズ(キャッシュライン)</a></li>
<li><a href="#stduncaught_exceptions">std::uncaught_exceptions</a></li>
<li><a href="#apply-tupleの要素を実引数に関数を呼び出す">apply: tupleの要素を実引数に関数を呼び出す</a></li>
<li><a href="#searcher-検索">Searcher : 検索</a><ul>
<li><a href="#default_searcher">default_searcher</a></li>
<li><a href="#boyer_moore_searcher">boyer_moore_searcher</a></li>
<li><a href="#boyer_moore_horspool_searcher">boyer_moore_horspool_searcher</a></li>
</ul></li>
<li><a href="#sample-乱択アルゴリズム">sample: 乱択アルゴリズム</a><ul>
<li><a href="#乱択アルゴリズム">乱択アルゴリズム</a></li>
<li><a href="#アルゴリズムs選択標本要素数が分かっている集合からの標本の選択">アルゴリズムS：選択標本、要素数が分かっている集合からの標本の選択</a></li>
<li><a href="#アルゴリズムr保管標本要素数がわからない集合からの標本の選択">アルゴリズムR：保管標本、要素数がわからない集合からの標本の選択</a></li>
<li><a href="#cのsample">C++のsample</a></li>
</ul></li>
<li><a href="#shared_ptrt-配列に対するshared_ptr">shared_ptr&lt;T[]&gt; : 配列に対するshared_ptr</a></li>
<li><a href="#as_const-const性の付与">as_const: const性の付与</a></li>
<li><a href="#make_from_tuple-tupleの要素を実引数にコンストラクターを呼び出す">make_from_tuple : tupleの要素を実引数にコンストラクターを呼び出す</a></li>
<li><a href="#invoke-指定した関数を指定した実引数で呼び出す">invoke : 指定した関数を指定した実引数で呼び出す</a></li>
<li><a href="#not_fn-戻り値の否定ラッパー">not_fn : 戻り値の否定ラッパー</a></li>
<li><a href="#メモリー管理アルゴリズム">メモリー管理アルゴリズム</a><ul>
<li><a href="#addressof">addressof</a></li>
<li><a href="#uninitialized_default_construct">uninitialized_default_construct</a></li>
<li><a href="#uninitialized_value_construct">uninitialized_value_construct</a></li>
<li><a href="#uninitialized_copy">uninitialized_copy</a></li>
<li><a href="#uninitialized_move">uninitialized_move</a></li>
<li><a href="#uninitialized_fill">uninitialized_fill</a></li>
<li><a href="#destory">destory</a></li>
</ul></li>
<li><a href="#shared_ptrweak_type">shared_ptr::weak_type</a></li>
<li><a href="#void_t">void_t</a></li>
<li><a href="#bool_constant">bool_constant</a></li>
<li><a href="#type_traits">type_traits</a><ul>
<li><a href="#変数テンプレート版traits">変数テンプレート版traits</a></li>
<li><a href="#論理演算traits">論理演算traits</a><ul>
<li><a href="#conjunction-論理積">conjunction : 論理積</a></li>
<li><a href="#disjunction-論理和">disjunction: 論理和</a></li>
</ul></li>
<li><a href="#negation-否定">negation: 否定</a></li>
<li><a href="#is_invocable-呼び出し可能か確認するtraits">is_invocable: 呼び出し可能か確認するtraits</a></li>
<li><a href="#has_unique_object_representations-同値の内部表現が同一か確認するtraits">has_unique_object_representations : 同値の内部表現が同一か確認するtraits</a></li>
<li><a href="#is_nothrow_swappable-無例外swap可能か確認するtraits">is_nothrow_swappable: 無例外swap可能か確認するtraits</a></li>
</ul></li>
<li><a href="#コンテナーで不完全型のサポート">コンテナーで不完全型のサポート</a></li>
<li><a href="#emplaceの戻り値">emplaceの戻り値</a></li>
<li><a href="#mapとunordered_mapの変更">mapとunordered_mapの変更</a><ul>
<li><a href="#try_emplace">try_emplace</a></li>
<li><a href="#insert_or_assign">insert_or_assign</a></li>
</ul></li>
<li><a href="#連想コンテナーへのsplice操作">連想コンテナーへのsplice操作</a><ul>
<li><a href="#merge">merge</a></li>
<li><a href="#ノードハンドル">ノードハンドル</a></li>
<li><a href="#extract-ノードハンドルの取得">extract : ノードハンドルの取得</a></li>
<li><a href="#insert-ノードハンドルから要素の追加">insert : ノードハンドルから要素の追加</a></li>
<li><a href="#ノードハンドルの利用例">ノードハンドルの利用例</a><ul>
<li><a href="#ストレージの再確保なしにコンテナーの一部の要素だけ別のコンテナーに移す">ストレージの再確保なしに、コンテナーの一部の要素だけ別のコンテナーに移す</a></li>
<li><a href="#コンテナーの寿命を超えて要素を存続させる">コンテナーの寿命を超えて要素を存続させる</a></li>
<li><a href="#mapのキーを変更する">mapのキーを変更する</a></li>
</ul></li>
</ul></li>
<li><a href="#コンテナーアクセス関数">コンテナーアクセス関数</a></li>
<li><a href="#clamp">clamp</a></li>
<li><a href="#次元hypot">3次元hypot</a></li>
<li><a href="#atomictis_always_lock_free">atomic&lt;T&gt;::is_always_lock_free</a></li>
<li><a href="#scoped_lock-可変長引数lock_guard">scoped_lock : 可変長引数lock_guard</a></li>
<li><a href="#stdbyte">std::byte</a></li>
<li><a href="#最大公約数gcdと最小公倍数lcm">最大公約数(gcd)と最小公倍数(lcm)</a><ul>
<li><a href="#gcd-最大公約数">gcd : 最大公約数</a></li>
<li><a href="#lcm-最小公倍数">lcm : 最小公倍数</a></li>
</ul></li>
</ul></li>
<li><a href="#ファイルシステム">ファイルシステム</a><ul>
<li><a href="#名前空間">名前空間</a></li>
<li><a href="#posix準拠">POSIX準拠</a></li>
<li><a href="#ファイルシステムの全体像">ファイルシステムの全体像</a></li>
<li><a href="#エラー処理">エラー処理</a><ul>
<li><a href="#例外-1">例外</a></li>
<li><a href="#非例外">非例外</a></li>
</ul></li>
<li><a href="#path-ファイルパス文字列クラス">path : ファイルパス文字列クラス</a><ul>
<li><a href="#ファイルパスの文字列">ファイルパスの文字列</a></li>
<li><a href="#ファイルパスの操作">ファイルパスの操作</a></li>
</ul></li>
<li><a href="#file_status">file_status</a></li>
<li><a href="#directory_entry">directory_entry</a></li>
<li><a href="#directory_iterator">directory_iterator</a><ul>
<li><a href="#エラー処理-1">エラー処理</a></li>
</ul></li>
<li><a href="#recursive_directory_iterator">recursive_directory_iterator</a><ul>
<li><a href="#オプション">オプション</a></li>
<li><a href="#depth-深さ取得">depth : 深さ取得</a></li>
<li><a href="#pop-現在のディレクトリーの列挙中止">pop : 現在のディレクトリーの列挙中止</a></li>
<li><a href="#recursion_pending-現在のディレクトリーの再帰をスキップ">recursion_pending : 現在のディレクトリーの再帰をスキップ</a></li>
</ul></li>
<li><a href="#ファイルシステム操作関数">ファイルシステム操作関数</a><ul>
<li><a href="#ファイルパス取得">ファイルパス取得</a><ul>
<li><a href="#current_path">current_path</a></li>
<li><a href="#temp_directory_path">temp_directory_path</a></li>
</ul></li>
<li><a href="#ファイルパス操作">ファイルパス操作</a><ul>
<li><a href="#absolute">absolute</a></li>
<li><a href="#canonical">canonical</a></li>
<li><a href="#wealky_canonical">wealky_canonical</a></li>
<li><a href="#relative">relative</a></li>
<li><a href="#proximate">proximate</a></li>
</ul></li>
<li><a href="#作成">作成</a><ul>
<li><a href="#create_directory">create_directory</a></li>
<li><a href="#create_directories">create_directories</a></li>
<li><a href="#create_directory_symlink">create_directory_symlink</a></li>
<li><a href="#create_symlink">create_symlink</a></li>
<li><a href="#create_hard_link">create_hard_link</a></li>
</ul></li>
<li><a href="#コピー">コピー</a><ul>
<li><a href="#copy_file">copy_file</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#copy_symlink">copy_symlink</a></li>
</ul></li>
<li><a href="#削除">削除</a><ul>
<li><a href="#remove">remove</a></li>
<li><a href="#remove_all">remove_all</a></li>
</ul></li>
<li><a href="#変更">変更</a><ul>
<li><a href="#permissions">permissions</a></li>
<li><a href="#rename">rename</a></li>
<li><a href="#resize_file">resize_file</a></li>
</ul></li>
<li><a href="#情報取得">情報取得</a><ul>
<li><a href="#ファイルタイプの判定">ファイルタイプの判定</a></li>
<li><a href="#status">status</a></li>
<li><a href="#status_known">status_known</a></li>
<li><a href="#symlink_status">symlink_status</a></li>
<li><a href="#equivalent">equivalent</a></li>
<li><a href="#exists">exists</a></li>
<li><a href="#file_size">file_size</a></li>
<li><a href="#hard_link_count">hard_link_count</a></li>
<li><a href="#last_write_time">last_write_time</a></li>
<li><a href="#read_symlink">read_symlink</a></li>
<li><a href="#space">space</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="序">序</h1>
<p>この本はアスキードワンゴで紙書籍として出版される予定のC++17の新機能をほぼすべて解説している。本書に誤りを見つけたならば、Pull Requestを送る先は<a href="https://github.com/EzoeRyou/cpp17book" class="uri">https://github.com/EzoeRyou/cpp17book</a>だ。</p>
<p>江添亮</p>
<h2 id="cの規格">C++の規格</h2>
<p>プログラミング言語C++はISOの傘下で国際規格ISO/IEC 14882として制定されている。この規格は数年おきに改定されている。一般にC++の規格を参照するときは、規格が制定した西暦の下二桁をとって、C++98(1998年発行)とかC++11(2011年発行)と呼ばれている。現在発行されているC++の規格は以下の通り。</p>
<h3 id="c98">C++98</h3>
<p>C++98は1998年に制定された最初のC++の規格である。本来ならば1994年か1995年には制定させる予定が大幅にずれて、1998年となった。</p>
<h3 id="c03">C++03</h3>
<p>C++03はC++98の文面の曖昧な点を修正したマイナーアップデートとして2003年に制定された。新機能の追加はほとんどない。</p>
<h3 id="c11">C++11</h3>
<p>C++11は制定途中のドラフト段階では元C++0xと呼ばれていた。これは、200x年までに規格が制定される予定だったからだ。予定は大幅に遅れ、ようやく規格が制定された時にはすでに2011年の年末になっていた。C++11ではとても多くの新機能が追加された。</p>
<h3 id="c14">C++14</h3>
<p>C++14は2014年に制定された。C++11の文面の誤りを修正した他、すこし新機能が追加された。本書で解説する。</p>
<h3 id="c17">C++17</h3>
<p>C++17は2017年に制定されることが予定されている最新のC++規格で、本書で解説する。</p>
<h2 id="cの将来の規格">C++の将来の規格</h2>
<h3 id="c20">C++20</h3>
<p>C++20は2020年に制定されることが予定されている次のC++規格だ。この規格では、モジュール、コンセプト、レンジ、ネットワークに注力することが予定されている。</p>
<h2 id="コア言語とライブラリ">コア言語とライブラリ</h2>
<p>C++の標準規格は、大きく分けて、Cプリプロセッサーとコア言語とライブラリからなる。</p>
<p>Cプリプロセッサーとは、C++がC言語から受け継いだ機能だ。ソースファイルをトークン列単位で分割して、トークン列の置換ができる。</p>
<p>コア言語とは、ソースファイルに書かれたトークン列の文法とその意味のことだ。</p>
<p>ライブラリとは、コア言語機能を使って実装されたもので、標準に提供されているものだ。標準ライブラリには、純粋にコア言語の機能のみで実装できるものと、それ以外の実装依存の方法やコンパイラーマジックが必要なものとがある。</p>
<h1 id="sd-6-cのための機能テスト推奨">SD-6 C++のための機能テスト推奨</h1>
<p>C++17には機能テストのためのCプリプロセッサー機能が追加された。</p>
<h2 id="機能テストマクロ">機能テストマクロ</h2>
<p>機能テストというのは、C++の実装(C++コンパイラー)が特定の機能をサポートしているかどうかをコンパイル時に判断できる機能だ。本来、C++17の規格に準拠したC++実装は、C++17の機能をすべてサポートしているべきだ。しかし、残念ながら現実のC++コンパイラーの開発はそのようには行われていない。C++17に対応途中のC++コンパイラーは将来的にはすべての機能を実装することを目標としつつも、現時点では一部の機能しか実装していないという状態になる。</p>
<p>例えば、C++11で追加されたrvalueリファレンスという機能に現実のC++コンパイラーが対応しているかどうかをコンパイル時に判定するコードは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef __USE_RVALUE_REFERENCES</span>
  <span class="pp">#if (</span><span class="ot">__GNUC__</span><span class="pp"> &gt; 4 || </span><span class="ot">__GNUC__</span><span class="pp"> == 4 &amp;&amp; </span><span class="ot">__GNUC_MINOR__</span><span class="pp"> &gt;= 3) || \</span>
<span class="pp">      _MSC_VER &gt;= 1600</span>
    <span class="pp">#if __EDG_VERSION__ &gt; 0</span>
      <span class="pp">#define __USE_RVALUE_REFERENCES (__EDG_VERSION__ &gt;= 410)</span>
    <span class="pp">#else</span>
      <span class="pp">#define __USE_RVALUE_REFERENCES 1</span>
    <span class="pp">#endif</span>
  <span class="pp">#elif __clang__</span>
    <span class="pp">#define __USE_RVALUE_REFERENCES __has_feature(cxx_rvalue_references)</span>
  <span class="pp">#else</span>
    <span class="pp">#define __USE_RVALUE_REFERENCES 0</span>
  <span class="pp">#endif</span>
<span class="pp">#endif</span></code></pre></div>
<p>このそびえ立つクソのようなコードは現実に書かれている。このコードはGCCとMSVCとEDGとClangという現実に使われている主要な4つのC++コンパイラーに対応したrvalueリファレンスが実装されているかどうかを判定する機能テストコードだ。</p>
<p>この複雑なプリプロセッサーを解釈した結果、__USE_RVALUE_REFERENCESというプリプロセッサーマクロの値が、もしC++コンパイラーがrvalueリファレンスをサポートしているならば1、そうでなければ0となる。あとは、このプリプロセッサーマクロで#ifガードしたコードを書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 文字列を処理する関数</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string <span class="at">const</span> &amp; str ) ;

<span class="pp">#if __USE_RVALUE_REFERENCES == 1</span>
<span class="co">// 文字列をムーブして処理してよい実装の関数</span>
<span class="co">// C++コンパイラーがrvalueリファレンスを実装していない場合はコンパイルされない</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string &amp;&amp; str ) ;
<span class="pp">#endif</span></code></pre></div>
<p>C++17では、上のようなそびえ立つクソのようなコードを書かなくてもすむように、標準の機能テストマクロが用意された。C++実装が特定の機能をサポートしている場合、対応する機能テストマクロが定義される。機能テストマクロの値は、その機能がC++標準に採択された年と月を合わせた6桁の整数で表現される。</p>
<p>例えばrvalueリファレンスの場合、機能テストマクロの名前は__cpp_rvalue_referencesとなっている。rvalueリファレンスは2006年10月に採択されたので、機能テストマクロの値は200610という値になっている。将来rvalueリファレンスの機能が変更された時は機能テストマクロの値も変更される。この値を調べることによって使っているC++コンパイラーはいつの時代のC++標準の機能をサポートしているか調べることもできる。</p>
<p>この機能テストマクロを使うと、上のコードの判定は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 文字列を処理する関数</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string <span class="at">const</span> &amp; str ) ;

<span class="pp">#ifdef __cpp_rvalue_references</span>
<span class="co">// 文字列をムーブして処理してよい実装の関数</span>
<span class="co">// C++コンパイラーがrvalueリファレンスを実装していない場合はコンパイルされない</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string &amp;&amp; str ) ;
<span class="pp">#endif</span></code></pre></div>
<p>機能テストマクロの値は通常は気にする必要がない。機能テストマクロが存在するかどうかで機能の有無を確認できるので、通常は#ifdefを使えばよい。</p>
<h2 id="has_include式-ヘッダーファイルの存在を判定する">__has_include式 : ヘッダーファイルの存在を判定する</h2>
<p>__has_include式は、ヘッダーファイルが存在するかどうかを調べるための機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include( ヘッダー名 )</code></pre></div>
<p>__has_include式はヘッダー名が存在する場合1に、存在しない場合0に置換される。</p>
<p>例えば、C++17の標準ライブラリにはファイルシステムが入る。そのヘッダー名は&lt;filesystem&gt;だ。C++コンパイラーがファイルシステムライブラリをサポートしているかどうかを調べるには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if __has_include(&lt;filesystem&gt;) </span>
<span class="co">// ファイルシステムをサポートしている</span>
<span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span>
<span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem ;
<span class="pp">#else</span>
<span class="co">// 実験的な実装を使う</span>
<span class="pp">#include </span><span class="im">&lt;experimental/filesystem&gt;</span>
<span class="kw">namespace</span> fs = <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
<span class="pp">#endif</span></code></pre></div>
<p>C++実装が__has_includeをサポートしているかどうかは、__has_includeの存在をプリプロセッサーマクロのように#ifdefで調べることによって判定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef __has_include</span>
<span class="co">// __has_includeをサポートしている</span>
<span class="pp">#else</span>
<span class="co">// __has_includeをサポートしていない</span>
<span class="pp">#endif</span></code></pre></div>
<p>__has_include式は#ifと#elifの中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    <span class="cf">if</span> ( __has_include(&lt;vector&gt;) )
    { }
}</code></pre></div>
<h2 id="has_cpp_attribute式">__has_cpp_attribute式</h2>
<p>C++実装が特定の属性トークンをサポートしているかどうかを調べるには、__has_cpp_attribute式が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_cpp_attribute( 属性トークン )</code></pre></div>
<p>__has_cpp_attribute式は、属性トークンが存在する場合は属性トークンが標準規格に採択された年と月を表す数値に、存在しない場合は0に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[nodiscard]]がサポートされている場合は使う</span>
<span class="pp">#if __has_cpp_attribute(nodiscard)</span>
[[<span class="at">nodiscard</span>]]
<span class="pp">#endif</span>
<span class="dt">void</span> * allocate_memory( <span class="bu">std::</span>size_t size ) ;</code></pre></div>
<p>__has_include式と同じく、__has_cpp_attribute式も#ifか#elifの中でしか使えない。#ifdefで__has_cpp_attribute式の存在の有無を判定できる。</p>
<h1 id="c14のコア言語の新機能">C++14のコア言語の新機能</h1>
<p>C++14で追加された新機能は少ない。C++14はC++03と同じくマイナーアップデートという位置づけで積極的な新機能の追加は見送られたからだ。</p>
<h2 id="二進数リテラル">二進数リテラル</h2>
<p>二進数リテラルは整数リテラルを二進数で記述する機能だ。整数リテラルのプレフィクスに0Bもしくは0bを書くと、二進数リテラルになる。整数を表現する文字は0と1しか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="bn">0b0</span> ; <span class="co">// 0</span>
    <span class="dt">int</span> x2 = <span class="bn">0b1</span> ; <span class="co">// 1</span>
    <span class="dt">int</span> x3 = <span class="bn">0b10</span> ; <span class="co">// 2</span>
    <span class="dt">int</span> x4 = <span class="bn">0b11001100</span> ; <span class="co">// 204</span>
}</code></pre></div>
<p>二進数リテラルは浮動小数点数リテラルには使えない。</p>
<p>機能テストマクロは__cpp_binary_literals。値は201304。</p>
<h2 id="数値区切り文字">数値区切り文字</h2>
<p>数値区切り文字は、整数リテラルと浮動小数点数リテラルの数値をシングルクオート文字で区切ることができる機能だ。区切り桁は何桁でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="dv">123&#39;456&#39;789</span> ;
    <span class="dt">int</span> x2 = <span class="dv">1&#39;2&#39;3&#39;4&#39;5&#39;6&#39;7&#39;8&#39;9</span> ; 
    <span class="dt">int</span> x3 = <span class="dv">1&#39;2345&#39;6789</span> ;
    <span class="dt">int</span> x4 = <span class="dv">1&#39;23&#39;456&#39;789</span> ;

    <span class="dt">double</span> x5 = <span class="fl">3.14159</span><span class="st">&#39;26535&#39;</span><span class="dv">89793</span> ;
}</code></pre></div>
<p>大きな数値を扱うとき、ソースファイルに100000000と1000000000と書かれていた場合、どちらが大きいのか人間の目にはわかりにくい。人間が読んでわかりにくいコードは間違いの元だ。数値区切りを使うと、100'000'000と1'000'000'000のように書くことができる。これはわかりやすい。</p>
<p>他には、1バイト単位で見やすいように区切ることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">unsigned</span> <span class="dt">int</span> x1 = <span class="bn">0xde&#39;ad&#39;be&#39;ef</span> ;
    <span class="dt">unsigned</span> <span class="dt">int</span> x2 = <span class="bn">0b11011110&#39;10101101&#39;10111110&#39;11101111</span> ;
}</code></pre></div>
<p>数値区切りはソースファイルを人間が読みやすくするための機能で、数値に影響を与えない。</p>
<h2 id="deprecated属性">[[deprecated]]属性</h2>
<p>[[deprecated]]属性は名前とエンティティが、まだ使えるものの利用は推奨されない状態であることを示すのに使える。deprecated属性が指定できる名前とエンティティは、クラス、typedef名、変数、非staticデータメンバー、関数、名前空間、enum、enumerator、テンプレートの特殊化だ。</p>
<p>それぞれ以下のように指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 変数</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">deprecated</span>]] <span class="dt">int</span> variable_name1 { } ;
<span class="dt">int</span> variable_name2 [[<span class="at">deprecated</span>]] { } ;

<span class="co">// typedef名</span>
[[<span class="at">deprecated</span>]] <span class="kw">typedef</span> <span class="dt">int</span> typedef_name1 ;
<span class="kw">typedef</span> <span class="dt">int</span> typedef_name2 [[<span class="at">deprecated</span>]] ;
<span class="kw">using</span> typedef_name3 [[<span class="at">deprecated</span>]] = <span class="dt">int</span> ;

<span class="co">// 関数</span>
<span class="co">// メンバー関数も同じ文法</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">deprecated</span>]] <span class="dt">void</span> function_name1() { }
<span class="dt">void</span> function_name2 [[<span class="at">deprecated</span>]] () { }


<span class="co">// クラス</span>
<span class="co">// unionも同じ</span>
<span class="kw">class</span> [[<span class="at">deprecated</span>]] clas<span class="va">s_name</span>
{
<span class="co">// 非staticデータメンバー</span>
[[<span class="at">deprecated</span>]] <span class="dt">int</span> non_static_data_member_name ;
} ;

<span class="co">// enum</span>
<span class="kw">enum</span> <span class="kw">class</span> [[<span class="at">deprecated</span>]] enu<span class="va">m_name</span>
{
<span class="co">// enumerator</span>
enumerator_name [[<span class="at">deprecated</span>]] = <span class="dv">42</span>
} ;


<span class="co">// 名前空間</span>
<span class="kw">namespace</span> [[<span class="at">deprecated</span>]] namespace_name { <span class="dt">int</span> x ; }

<span class="co">// テンプレートの特殊化</span>

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> template_name { } ;

<span class="kw">template</span> &lt; &gt;
<span class="kw">class</span> [[<span class="at">deprecated</span>]] template_name&lt;<span class="dt">void</span>&gt; { } ;</code></pre></div>
<p>deprecated属性が指定された名前やエンティティを使うと、C++コンパイラーは警告メッセージを出す。</p>
<p>deprecated属性には、文字列を付け加えることができる。これはC++実装によっては警告メッセージに含まれるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">deprecated</span>(<span class="st">&quot;Use of f() is deprecated. Use f(int option) instead.&quot;</span>)]]
<span class="dt">void</span> f() ;

<span class="dt">void</span> f( <span class="dt">int</span> option ) ;</code></pre></div>
<p>機能テストマクロは__has_cpp_attribute(deprecated)。値は201309。</p>
<h2 id="通常の関数の戻り値の型推定">通常の関数の戻り値の型推定</h2>
<p>関数の戻り値の型としてautoを指定すると、戻り値の型をreturn文から推定してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ()</span>
<span class="kw">auto</span> a(){ <span class="cf">return</span> <span class="dv">0</span> ; }
<span class="co">// double ()</span>
<span class="kw">auto</span> b(){ <span class="cf">return</span> <span class="fl">0.0</span> ; }

<span class="co">// T(T)</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">auto</span> c(T t){ <span class="cf">return</span> t ; }</code></pre></div>
<p>return文の型が一致していないとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f()
{
    <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// エラー、一致してない</span>
    <span class="cf">return</span> <span class="fl">0.0</span> ; <span class="co">// エラー、一致していない</span>
}</code></pre></div>
<p>すでに型が決定できるreturn文が存在する場合、関数の戻り値の型を参照するコードも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a()
{
    &amp;a ; <span class="co">// エラー、aの戻り値の型が決定していない</span>
    <span class="cf">return</span> <span class="dv">0</span> ;
}

<span class="kw">auto</span> b()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
    &amp;b ; <span class="co">// OK、戻り値の型はint</span>
}</code></pre></div>
<p>関数aへのポインターを使うには関数aの型が決定していなければならないが、return文の前に型は決定できないので関数aはエラーになる。関数bはreturn文が現れた後なので戻り値の型が決定できる。</p>
<p>再帰関数も書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sum( <span class="dt">unsigned</span> <span class="dt">int</span> i )
{
    <span class="cf">if</span> ( i == <span class="dv">0</span> )
        <span class="cf">return</span> i ; <span class="co">// 戻り値の型はunsigned int</span>
    <span class="cf">else</span>
        <span class="cf">return</span> sum(i<span class="dv">-1</span>)+i ; <span class="co">// OK</span>
}</code></pre></div>
<p>このコードも、return文の順番を逆にすると戻り値の型が決定できずエラーとなるので注意。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sum( <span class="dt">unsigned</span> <span class="dt">int</span> i )
{
    <span class="cf">if</span> ( i != <span class="dv">0</span> )
        <span class="cf">return</span> sum(i<span class="dv">-1</span>)+i ; <span class="co">// エラー</span>
    <span class="cf">else</span>
        <span class="cf">return</span> i ;
}</code></pre></div>
<p>機能テストマクロは__cpp_return_type_deduction。値は201304。</p>
<h2 id="decltypeauto-厳格なauto">decltype(auto): 厳格なauto</h2>
<p>警告：この項目はC++規格の詳細な知識を解説しているため極めて難解になっている。平均的なC++プログラマーはこの知識を得てもよりよいコードが書けるようにはならない。この項目は読み飛ばすべきである。</p>
<p>decltype(auto)はauto指定子の代わりに使える厳格なautoだ。利用にはC++の規格の厳格な理解が求められる。</p>
<p>autoとdecltype(auto)は型指定子と呼ばれる文法の一種で、プレイスホルダー型として使う。</p>
<p>わかりやすく言うと、具体的な型を式から決定する機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// aはint</span>
<span class="kw">auto</span> a = <span class="dv">0</span> ;
<span class="co">// bはint </span>
<span class="kw">auto</span> b() { <span class="cf">return</span> <span class="dv">0</span> ; } </code></pre></div>
<p>変数宣言にプレイスホルダー型を使う場合、型を決定するための式は初期化子と呼ばれる部分に書かれる式を使う。関数の戻り値の型推定にプレイスホルダー型を使う場合、return文の式を使う。</p>
<p>decltype(auto)はautoの代わりに使うことができる。decltype(auto)も型を式から決定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// aはint</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="dv">0</span> ;
<span class="co">// bはint</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) b() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>一見するとautoとdecltype(auto)は同じようだ。しかし、この2つは式から型を決定する方法が違う。どちらもC++の規格の極めて難しい規則に基づいて決定される。習得には熟練の魔法使いであることが要求される。</p>
<p>autoが式から型を決定するには、autoキーワードをテンプレートパラメーター名で置き換えた関数テンプレートの仮引数に、式を実引数として渡してテンプレート実引数推定を行わせた場合に推定される型が使われる。</p>
<p>例えば</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> x = <span class="dv">0</span> ;</code></pre></div>
<p>の場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T u ) ;</code></pre></div>
<p>のような関数テンプレートに対して、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f(<span class="dv">0</span>) ;</code></pre></div>
<p>と実引数を渡した時にuの型として推定される型と同じ型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i ;
<span class="kw">auto</span> <span class="at">const</span> * x = &amp;i ;</code></pre></div>
<p>の場合には、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="at">const</span> * u ) ;</code></pre></div>
<p>のような関数テンプレートに</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f(&amp;i) ;</code></pre></div>
<p>と実引数を渡した時にuの型として推定される型と同じ型になる。この場合はint const *になる。</p>
<p>ここまでがautoの説明だ。decltype(auto)の説明は簡単だ。</p>
<p>decltype(auto)の型は、autoを式で置き換えたdecltypeの型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="dv">0</span> ;

<span class="co">// int</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) f() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>上のコードは、下のコードと同じ意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">decltype</span>(<span class="dv">0</span>) a = <span class="dv">0</span> ;
<span class="kw">decltype</span>(<span class="dv">0</span>) f() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>ここまでは簡単だ。そして、これ以降は黒魔術のようなC++の規格の知識が必要になってくる。</p>
<p>autoとdecltype(auto)は一見すると同じように見える。型を決定する方法として、autoは関数テンプレートの実引数推定を使い、decltype(auto)はdecltypeを使う。どちらも式を評価した結果の型になる。一体何が違うというのか。</p>
<p>主な違いは、autoは関数呼び出しを使うということだ。関数呼び出しの際には様々な暗黙の型変換が行われる。</p>
<p>例えば、配列を関数に渡すと、暗黙の型変換の結果、配列の先頭要素へのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T u ) {}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> array[<span class="dv">5</span>] ;
    <span class="co">// Tはint *</span>
    f( array ) ;
}</code></pre></div>
<p>ではautoとdecltype(auto)を使うとどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> array[<span class="dv">5</span>] ;
<span class="co">// int *</span>
<span class="kw">auto</span> x1 = array ;
<span class="co">// エラー、配列は配列で初期化できない</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = array ;</code></pre></div>
<p>このコードは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> array[<span class="dv">5</span>] ;
<span class="co">// int *</span>
<span class="dt">int</span> * x1 = array ;
<span class="co">// エラー、配列は配列で初期化できない</span>
<span class="dt">int</span> x2[<span class="dv">5</span>] = array ;</code></pre></div>
<p>autoの場合、型はint *となる。配列は配列の先頭要素へのポインターへと暗黙に変換できるので、結果のコードは正しい。</p>
<p>decltype(auto)の場合、型はint [5]となる。配列は配列で初期化、代入ができないので、このコードはエラーになる。</p>
<p>関数型も暗黙の型変換により関数へのポインター型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() ;

<span class="co">// 型はvoid(*)()</span>
<span class="kw">auto</span> x1 = f ;
<span class="co">// エラー、関数型は変数にできない</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f ;</code></pre></div>
<p>autoはトップレベルのリファレンス修飾子を消すが、decltype(auto)は保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp; f()
{
    <span class="at">static</span> <span class="dt">int</span> x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="co">// int</span>
    <span class="kw">auto</span> x1 = f() ;
    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f() ;
}</code></pre></div>
<p>リスト初期化はautoではstd::initializer_listだが、decltype(auto)では式ではないためエラー</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::initializer_list&lt;int&gt;</span>
    <span class="kw">auto</span> x1 = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
    <span class="co">// エラー、decltype({1,2,3})はできない</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
}</code></pre></div>
<p>decltype(auto)は単体で使わなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
<span class="kw">auto</span> <span class="at">const</span> x1 = <span class="dv">0</span> ; 
<span class="co">// エラー</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) <span class="at">const</span> x2 = <span class="dv">0</span> ;</code></pre></div>
<p>この他にもautoとdecltype(auto)には様々な違いがある。すべての違いを列挙するのは煩雑なので省略するが、decltype(auto)は式の型を直接使う。autoは大抵の場合は便利な型の変換が入る。</p>
<p>autoは便利で大抵の場合はうまく行くが暗黙の型の変換が入るため、意図通りの推定をしてくれないことがある。</p>
<p>例えば、引数でリファレンスを受け取り、戻り値でそのリファレンスを返す関数を書くとする。以下のように書くのは間違いだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ( int &amp; )</span>
<span class="kw">auto</span> f( <span class="dt">int</span> &amp; ref )
{ <span class="cf">return</span> ref ; }</code></pre></div>
<p>なぜならば、戻り値の型は式の型から変化してintになってしまうからだ。ここでdecltype(auto)を使うと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int &amp; ( int &amp; )</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) f( <span class="dt">int</span> &amp; ref )
{ <span class="cf">return</span> ref ; }</code></pre></div>
<p>式の型をそのまま使ってくれる。</p>
<p>ラムダ式にdelctype(auto)を使う場合は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]() -&gt; <span class="kw">decltype</span>(<span class="kw">auto</span>) { <span class="cf">return</span> <span class="dv">0</span> ; } ;</code></pre></div>
<p>decltype(auto)は主に関数の戻り値の型推定で式の型をそのまま推定してくれるようにするために追加された機能だ。その利用にはC++の型システムの深い理解が必要になる。</p>
<p>機能テストマクロは__cpp_decltype_auto, 値は201304。</p>
<h2 id="ジェネリックラムダ">ジェネリックラムダ</h2>
<p>ジェネリックラムダはラムダ式の引数の型を書かなくてもすむようにする機能だ。</p>
<p>通常のラムダ式は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    []( <span class="dt">int</span> i, <span class="dt">double</span> d, <span class="bu">std::</span>string s ) { } ;
}</code></pre></div>
<p>ラムダ式の引数には型が必要だ。しかし、クロージャーオブジェクトのoperator ()に渡す型はコンパイル時にわかる。コンパイル時にわかるということはわざわざ人間が指定する必要はない。ジェネリックラムダを使えば、引数の型を書くべき場所にautoキーワードを書くだけで型を推定してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    []( <span class="kw">auto</span> i, <span class="kw">auto</span> d, <span class="kw">auto</span> s ) { } ;
}</code></pre></div>
<p>ジェネリックラムダ式の結果のクロージャー型には呼出しごとに違う型を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ; } ;

    f( <span class="dv">123</span> ) ; <span class="co">// int</span>
    f( <span class="fl">12.3</span> ) ; <span class="co">// double</span>
    f( <span class="st">&quot;hello&quot;</span> ) ; <span class="co">// char const *</span>
}</code></pre></div>
<p>仕組みは簡単で、以下のようなメンバーテンプレートのoperator ()を持ったクロージャーオブジェクトが生成されているだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> closure_object
{
    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
    <span class="kw">auto</span> <span class="kw">operator</span> () ( T x )
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
} ;</code></pre></div>
<p>機能テストマクロは__cpp_generic_lambdas, 値は201304。</p>
<h2 id="初期化ラムダキャプチャー">初期化ラムダキャプチャー</h2>
<p>初期化ラムダキャプチャーはラムダキャプチャーする変数の名前と式を書くことができる機能だ。</p>
<p>ラムダ式は書かれた場所から見えるスコープの変数をキャプチャーする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> x ; } ;
    f() ;
}</code></pre></div>
<p>初期化ラムダキャプチャーはラムダキャプチャーに初期化子を書くことができる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [ x = x, y = x, &amp;ref = x, x2 = x * <span class="dv">2</span> ]
    {<span class="co">// キャプチャーされた変数を使う</span>
        x ;
        y ;
        ref ;
        x2 ;
    } ;
}</code></pre></div>
<p>初期化ラムダキャプチャーは、&quot;識別子 = expr&quot; という文法でラムダ導入子[]の中に書く。するとあたかも&quot;auto 識別子 = expr ;&quot;と書いたかのように変数が作られる。これによりキャプチャーする変数の名前を変えたり、まったく新しい変数を宣言することができる。</p>
<p>初期化ラムダキャプチャーの識別子の前に&amp;をつけると、リファレンスキャプチャー扱いになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [ &amp;ref = x ]()
    {
        ref = <span class="dv">1</span> ;
    }() ;

    <span class="co">// xは1</span>
}</code></pre></div>
<p>初期化ラムダキャプチャーが追加された理由には変数の名前を変えたり全く新しい変数を導入したいという目的の他に、非staticデータメンバーをコピーキャプチャーするという目的がある。</p>
<p>以下のコードには問題があるが、わかるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data = <span class="dv">42</span> ;

    <span class="kw">auto</span> get_closure_object()
    {
        <span class="cf">return</span> [=]{ <span class="cf">return</span> data ; } ;
    }
} ;


<span class="dt">int</span> main()
{
    <span class="bu">std::</span>function&lt; <span class="dt">int</span>() &gt; f ;

    {
        X x ;
        f = x.get_closure_object() ;
    }

    <span class="bu">std::</span>cout &lt;&lt; f() &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>X::get_closure_objectはX::dataを返すクロージャーオブジェクトを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [=]{ <span class="cf">return</span> data ; } ;
}</code></pre></div>
<p>これを見ると、コピーキャプチャである[=]を使っているので、dataはクロージャーオブジェクト内にコピーされているように思える。しかし、ラムダ式は非staticデータメンバーをキャプチャーしてはいない。ラムダ式がキャプチャーしているのはthisポインターだ。上のコードと下のコードは同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [<span class="kw">this</span>]{ <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
}</code></pre></div>
<p>さて、main関数をもう一度見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// クロージャーオブジェクトを代入するための変数</span>
    <span class="bu">std::</span>function&lt; <span class="dt">int</span>() &gt; f ;

    {
        X x ; <span class="co">// xが構築される</span>
        f = x.get_closure_object() ;
        <span class="co">// xが破棄される</span>
    }

    <span class="co">// すでにxは破棄された</span>
    <span class="co">// return &amp;x-&gt;dataで破棄されたxを参照する</span>
    <span class="bu">std::</span>cout &lt;&lt; f() &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>なんと、すでに破棄されたオブジェクトへのリファレンスを参照してしまっている。これは未定義の動作だ。</p>
<p>初期化ラムダキャプチャーを使えば、非staticデータメンバーもコピーキャプチャーできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [data=data]{ <span class="cf">return</span> data ; } ;
}</code></pre></div>
<p>なお、ムーブキャプチャーは存在しない。ムーブというのは特殊なコピーなので初期化ラムダキャプチャーがあれば実現できるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f()
{
    <span class="bu">std::</span>string str ;
    <span class="bu">std::</span>cin &gt;&gt; str ;
    <span class="co">// ムーブ</span>
    <span class="cf">return</span> [str = <span class="bu">std::</span>move(str)]{ <span class="cf">return</span> str ; } ;
}</code></pre></div>
<p>機能テストマクロは__cpp_init_captures, 値は201304。</p>
<h2 id="変数テンプレート">変数テンプレート</h2>
<p>変数テンプレートとは変数宣言をテンプレート宣言にできる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T variable { } ;

<span class="dt">int</span> main()
{
    variable&lt;<span class="dt">int</span>&gt; = <span class="dv">42</span> ;
    variable&lt;<span class="dt">double</span>&gt; = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>これだけではわからないだろうから、順を追って説明する。</p>
<p>C++ではクラスを宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X
{
    <span class="dt">int</span> member ;
} ;</code></pre></div>
<p>C++ではクラスをテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> X
{
<span class="kw">public</span> :
    T member ;
} ;

<span class="dt">int</span> main()
{
    X&lt;<span class="dt">int</span>&gt; i ;
    i.member = <span class="dv">42</span> ; <span class="co">// int</span>

    X&lt;<span class="dt">double</span>&gt; d ;
    d.member = <span class="fl">1.0</span> ; <span class="co">// double</span>
}</code></pre></div>
<p>C++では関数を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x )
{ <span class="cf">return</span> x ; }</code></pre></div>
<p>C++では関数をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T x )
{ <span class="cf">return</span> x ; }

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> i = f( <span class="dv">42</span> ) ; <span class="co">// int</span>
    <span class="kw">auto</span> d = f( <span class="fl">1.0</span> ) ; <span class="co">// double</span>
}</code></pre></div>
<p>C++11ではtypedef名を宣言するためにエイリアス宣言ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> ;</code></pre></div>
<p>C++11ではエイリアス宣言をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">using</span> type = T ;

<span class="dt">int</span> main()
{
    type&lt;<span class="dt">int</span>&gt; i = <span class="dv">42</span> ; <span class="co">// int</span>
    type&lt;<span class="dt">double</span>&gt; d = <span class="fl">1.0</span> ; <span class="co">// double</span>
}</code></pre></div>
<p>そろそろパターンが見えてきたのではないだろうか。C++では一部の宣言はテンプレート宣言できるということだ。このパターンを踏まえて以下を考えてみよう。</p>
<p>C++では変数を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> variable{} ;</code></pre></div>
<p>C++14では変数宣言をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T variable { } ;

<span class="dt">int</span> main()
{
    variable&lt;<span class="dt">int</span>&gt; = <span class="dv">42</span> ;
    variable&lt;<span class="dt">double</span>&gt; = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>変数テンプレートは名前通り変数宣言をテンプレート宣言できる機能だ。変数テンプレートはテンプレート宣言なので、名前空間スコープとクラススコープの中にしか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// これはグローバル名前空間スコープという特別な名前空間スコープ</span>

<span class="kw">namespace</span> ns {
<span class="co">// 名前空間スコープ</span>
}

<span class="kw">class</span>
{
<span class="co">// クラススコープ</span>
} ;</code></pre></div>
<p>変数テンプレートの使い道は主に2つある。</p>
<h3 id="意味は同じだが型が違う定数">意味は同じだが型が違う定数</h3>
<p>プログラムでマジックナンバーを変数化しておくのは良い作法であるとされている。例えば円周率を3.14...などと書くよりもpiという変数名で扱ったほうがわかりやすい。変数化すると、円周率の値が後で変わった時にプログラムを変更するのも楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">double</span> pi = <span class="fl">3.1415926535</span> ;</code></pre></div>
<p>しかし、円周率を表現する型が複数ある場合どうすればいいのか。よくあるのは名前を分ける方法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">float</span> pi_f = <span class="fl">3.1415</span> ;
<span class="kw">constexpr</span> <span class="dt">double</span> pi_d = <span class="fl">3.1415926535</span> ;
<span class="kw">constexpr</span> <span class="dt">int</span> pi_i = <span class="dv">3</span> ;
<span class="co">// 任意の精度の実数を表現できるクラスとする</span>
<span class="at">const</span> Real pi_r(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;</code></pre></div>
<p>しかしこれは、使う側で型によって名前を変えなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 円の面積を計算する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="co">// Tの型によって使うべき名前が変わる</span>
    <span class="cf">return</span> r * r * ??? ;
}</code></pre></div>
<p>関数テンプレートを使うという手がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> T pi()
{
    <span class="cf">return</span> <span class="kw">static_cast</span>&lt;T&gt;(<span class="fl">3.1415926535</span>) ;
}

<span class="kw">template</span> &lt; &gt;
Real pi()
{
    <span class="cf">return</span> Real(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;
}


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="cf">return</span> r * r * pi&lt;T&gt;() ;
}</code></pre></div>
<p>しかし、この場合引数は何もないのに関数呼び出しのための()が必要だ。</p>
<p>変数テンプレートを使うと以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> T pi = <span class="kw">static_cast</span>&lt;T&gt;(<span class="fl">3.1415926535</span>) ;

<span class="kw">template</span> &lt; &gt;
Real pi&lt;Real&gt;(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="cf">return</span> r * r * pi&lt;T&gt; ;
}</code></pre></div>
<h3 id="traitsのラッパー">traitsのラッパー</h3>
<p>値を返すtraitsで値を得るには::valueと書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>is_pointer&lt;<span class="dt">int</span>&gt;::value ;
<span class="bu">std::</span>is_same&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt;::value ;</code></pre></div>
<p>C++14ではstd::integral_constantにconstexpr operator boolが追加されたので、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>is_pointer&lt;<span class="dt">int</span>&gt;{} ;
<span class="bu">std::</span>is_same&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt;{} ;</code></pre></div>
<p>しかしまだ面倒だ。変数テンプレートを使うとtraitsの記述が楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_pointer_v = <span class="bu">std::</span>is_pointer&lt;T&gt;::value ;
<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> U &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v = <span class="bu">std::</span>is_same&lt;T, U&gt;::value ;

is_pointer_v&lt;<span class="dt">int</span>&gt; ;
is_same_v&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; ;</code></pre></div>
<p>C++の標準ライブラリでは従来のtraitsライブラリを変数テンプレートでラップした_v版を用意している。</p>
<p>機能テストマクロは__cpp_variable_templates, 値は201304。</p>
<h2 id="constexpr関数の制限緩和">constexpr関数の制限緩和</h2>
<p>C++11で追加されたconstexpr関数はとても制限が強い。constexpr関数の本体には実質return文一つしか書けない。</p>
<p>C++14では、ほとんど何でも書けるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f( <span class="dt">int</span> x )
{
    <span class="co">// 変数を宣言できる。</span>
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="co">// 繰り返し文を書ける。</span>
    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt; x ; ++i )
    {
        <span class="co">// 変数を変更できる</span>
        sum += i ;
    }

    <span class="cf">return</span> sum ;
}</code></pre></div>
<p>機能テストマクロは__cpp_constexpr, 値は201304。</p>
<p>C++11のconstexpr関数に対応しているがC++14のconstexpr関数に対応していないC++実装では、__cpp_constexprマクロの値は200704になる。</p>
<h2 id="メンバー初期化子とアグリゲート初期化の組み合わせ">メンバー初期化子とアグリゲート初期化の組み合わせ</h2>
<p>C++14ではメンバー初期化子とアグリゲート初期化が組み合わせられるようになった。</p>
<p>メンバー初期化子とはクラスの非staticデータメンバーを=で初期化できるC++11の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// メンバー初期化子</span>
    <span class="dt">int</span> data = <span class="dv">123</span> ;
} ;</code></pre></div>
<p>アグリゲート初期化とはアグリゲートの条件を満たす型をリスト初期化で初期化できるC++11の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x, y, z ;
} ;

S s = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="co">// s.x == 1, s.y == 2, s.z == 3</span></code></pre></div>
<p>C++11ではメンバー初期化子を持つクラスはアグリゲート型の条件を満たさないのでアグリゲート初期化ができない。</p>
<p>C++14では、この制限が緩和された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x, y=<span class="dv">1</span>, z ;
} ;

S s1 = { <span class="dv">1</span> } ;
<span class="co">// s1.x == 1, s1.y == 1, s1.z == 0</span>

S s2{ <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="co">// s2.x == 1, s2.y == 2, s2.z == 3</span></code></pre></div>
<p>アグリゲート初期化で、メンバー初期化子をもつ非staticデータメンバーに対応する値がある場合はアグリゲート初期化が優先される。省略された場合はメンバー初期化子で初期化される。アグリゲート初期化でもメンバー初期化子でも明示的に初期化されていない非staticデータメンバーは空の初期化リストで初期化された場合と同じになる。</p>
<p>機能テストマクロは__cpp_aggregate_nsdmi, 値は201304。</p>
<h2 id="サイズ付き解放関数">サイズ付き解放関数</h2>
<p>C++14ではoperator deleteのオーバーロードに、解放すべきストレージのサイズを取得できるオーバーロードが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>    ( <span class="dt">void</span> *, <span class="bu">std::</span>size_t ) <span class="kw">noexcept</span> ;
<span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>[]  ( <span class="dt">void</span> *, <span class="bu">std::</span>size_t ) <span class="kw">noexcept</span> ;</code></pre></div>
<p>第二引数はstd::size_t型で、第一引数で指定されたポインターが指す解放すべきストレージのサイズが与えられる。</p>
<p>例えば以下のように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * <span class="kw">operator</span> <span class="kw">new</span> ( <span class="bu">std::</span>size_t size )
{
    <span class="dt">void</span> * ptr =  <span class="bu">std::</span>malloc( size ) ;

    <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )
        <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc() ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;allocated storage of size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    <span class="cf">return</span> ptr ;
}

<span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span> ( <span class="dt">void</span> * ptr, <span class="bu">std::</span>size_t size ) <span class="kw">noexcept</span>
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;deallocated storage of size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    <span class="bu">std::</span>free( ptr ) ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> u1 = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="kw">auto</span> u2 = <span class="bu">std::</span>make_unique&lt;<span class="dt">double</span>&gt;(<span class="fl">0.0</span>) ;
}</code></pre></div>
<p>機能テストマクロは__cpp_sized_deallocation, 値は201309。</p>
<h1 id="c17のコア言語の新機能">C++17のコア言語の新機能</h1>
<p>C++14の新機能のおさらいが終わったところで、いよいよC++17のコア言語の新機能を解説していく。</p>
<p>C++17のコア言語の新機能には、C++11ほどの大きなものはない。</p>
<h2 id="トライグラフの廃止">トライグラフの廃止</h2>
<p>C++17ではトライグラフが廃止された。</p>
<p>トライグラフを知らない読者はこの変更を気にする必要はない。トライグラフを知っている読者はなおさら気にする必要はない。</p>
<h2 id="進数浮動小数点数リテラル">16進数浮動小数点数リテラル</h2>
<p>C++17では浮動小数点数リテラルに16進数を使うことができるようになった。</p>
<p>16進数浮動小数点数リテラルは、プレフィクス0xに続いて仮数部を16進数(0123456789abcdefABCDEF)で書き、pもしくはPに続けて指数部を10進数で書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d1 = <span class="er">0x1p0</span> ; <span class="co">// 1</span>
<span class="dt">double</span> d2 = <span class="bn">0x1</span><span class="fl">.0</span>p0 ; <span class="co">// 1</span>
<span class="dt">double</span> d3 = <span class="er">0x10p0</span> ; <span class="co">// 16</span>
<span class="dt">double</span> d4 = <span class="er">0xabcp0</span> ; <span class="co">// 2748</span></code></pre></div>
<p>指数部はeではなくpかPを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d1 = <span class="er">0x1p0</span> ;
<span class="dt">double</span> d2 = <span class="er">0x1P0</span> ;</code></pre></div>
<p>16進数浮動小数点数リテラルでは、指数部を省略できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="bn">0x1</span> ; <span class="co">// 整数リテラル</span>
<span class="bn">0x1</span><span class="fl">.0</span> ; <span class="co">// エラー、指数部がない</span></code></pre></div>
<p>指数部は10進数で記述する。16進数浮動小数点数リテラルは仮数部に2の指数部乗を掛けた値になる。つまり、</p>
<p>0xNpM</p>
<p>という浮動小数点数リテラルの値は</p>
<p><span class="math inline">\(N \times 2^M\)</span></p>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">0x1p0</span> ; <span class="co">// 1</span>
<span class="er">0x1p1</span> ; <span class="co">// 2</span>
<span class="er">0x1p2</span> ; <span class="co">// 4</span>
<span class="er">0x10p0</span> ; <span class="co">// 16</span>
<span class="er">0x10p1</span> ; <span class="co">// 32</span>
<span class="er">0x1p</span><span class="dv">-1</span> ; <span class="co">// 0.5</span>
<span class="er">0x1p</span><span class="dv">-2</span> ; <span class="co">// 0.25</span></code></pre></div>
<p>16進数浮動小数点数リテラルには浮動小数点数サフィックスを記述できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a = <span class="er">0x1p0f</span> ; <span class="co">// float</span>
<span class="kw">auto</span> b = <span class="er">0x1p0l</span> ; <span class="co">// long double</span></code></pre></div>
<p>16進数浮動小数点数リテラルは、浮動小数点数が表現方法の詳細を知っている環境(例えばIEEE-754)で、正確な浮動小数点数の表現が記述できるようになる。</p>
<p>機能テストマクロは__cpp_hex_float, 値は201603。</p>
<h2 id="utf-8文字リテラル">UTF-8文字リテラル</h2>
<p>C++17ではUTF-8文字リテラルが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = u8<span class="st">&#39;a&#39;</span> ;</code></pre></div>
<p>UTF-8文字リテラルは文字リテラルにプレフィクスu8をつける。UTF-8文字リテラルはUTF-8のコード単位一つで表現できる文字を扱うことができる。UCSの規格としては、C0制御文字と基本ラテン文字Unicodeブロックが該当する。UTF-8文字リテラルに書かれた文字が複数のUTF-8コード単位を必要とする場合はエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="co">// U+3042はUTF-8は0xE3, 0x81, 0x82という3つのコード単位で表現する必要があるため</span>
u8<span class="st">&#39;あ&#39;</span> ;</code></pre></div>
<p>機能テストマクロはない。</p>
<h2 id="関数型としての例外指定">関数型としての例外指定</h2>
<p>C++17では例外指定が関数型に組み込まれた。</p>
<p>例外指定とはnoexceptのことだ。noexceptとnoexcept(true)が指定された関数は例外を外に投げない。</p>
<p>C++14ではこの例外指定は型システムに入っていなかった。そのため、無例外指定のついた関数へのポインター型は型システムで無例外を保証することができなかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// C++14のコード</span>
<span class="dt">void</span> f()
{
    <span class="cf">throw</span> <span class="dv">0</span> ; 
}

<span class="dt">int</span> main()
{
    <span class="co">// 無例外指定のついたポインター</span>
    <span class="dt">void</span> (*p)() <span class="kw">noexcept</span> = &amp;f ;

    <span class="co">// 無例外指定があるにもかかわらず例外を投げる</span>
    p() ;
}</code></pre></div>
<p>C++17では例外指定が型システムに組み込まれた。例外指定のある関数型を例外指定のない関数へのポインター型に変換することはできる。逆はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 型はvoid()</span>
<span class="dt">void</span> f() { }
<span class="co">// 型はvoid() noexcept</span>
<span class="dt">void</span> g() <span class="kw">noexcept</span> { }

<span class="co">// OK</span>
<span class="co">// p1, &amp;fは例外指定のない関数へのポインター型</span>
<span class="dt">void</span> (*p1)() = &amp;f ;
<span class="co">// OK</span>
<span class="co">// 例外指定のある関数へのポインター型&amp;gを例外指定のない関数へのポインター型p2に変換できる</span>
<span class="dt">void</span> (*p2)() = &amp;g ; <span class="co">// OK</span>

<span class="co">// エラー</span>
<span class="co">// 例外指定のない関数へのポインター型&amp;fは例外指定のある関数へのポインター型p3に変換できない</span>
<span class="dt">void</span> (*p3)() <span class="kw">noexcept</span> = &amp;f ;

<span class="co">// OK</span>
<span class="co">// p4, &amp;fは例外指定のある関数へのポインター型</span>
<span class="dt">void</span> (*p4)() <span class="kw">noexcept</span> = &amp;f ;</code></pre></div>
<p>機能テストマクロは__cpp_noexcept_function_type, 値は201510。</p>
<h2 id="fold式">fold式</h2>
<p>C++17にはfold式が入った。foldは元は数学の概念で畳み込みとも呼ばれている。</p>
<p>C++におけるfold式とはパラメーターパックの中身に二項演算子を適用するための式だ。</p>
<p>今、可変長テンプレートを使って受け取った値をすべて加算した合計を返す関数sumを書きたいとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( T x, Types ... args ) ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>) ; <span class="co">// 45</span>
}</code></pre></div>
<p>このような関数テンプレートsumは以下のように実装することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">auto</span> sum( T x )
{
    <span class="cf">return</span> x ;
}

<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( T x, Types ... args )
{
    <span class="cf">return</span> x + sum( args... )  ;
}</code></pre></div>
<p>sum(x, args)は1番目の引数をxで、残りをパラメーターパックargsで受け取る。そして、x + sum( args ... )を返す。すると、sum( args ... )はまたsum(x, args)に渡されて、1番目の引数、つまり最初から見て2番目の引数がxに入り、またsumが呼ばれる。このような再帰的な処理を繰り返していく。</p>
<p>そして、引数がひとつだけになると、可変長テンプレートではないsumが呼ばれる。これは重要だ。なぜならば可変長テンプレートは0個の引数を取ることができるので、そのまま可変長テンプレート版のsumが呼ばれてしまうと、次のsumの呼び出しができずにエラーとなる。これを回避するために、また再帰の終了条件のために、引数がひとつのsumのオーバーロード関数を書いておく。</p>
<p>可変長テンプレートでは任意個の引数に対応するために、このような再帰的なコードが必須になる。</p>
<p>しかし、ここで実現したいこととはN個あるパラメーターパックargsの中身に対して、仮にN番目をargs#Nとする表記を使うと、args#0 + args#1 + ... + args#N-1のような展開をしたいだけだ。C++17のfold式はパラメーターパックに対して二項演算子を適用する展開を行う機能だ。</p>
<p>fold式を使うとsumは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( Types ... args )
{
    <span class="cf">return</span> ( ... + args )  ;
}</code></pre></div>
<p>( ... + args )は、args#0 + args#1 + ... + args#N-1のように展開される。</p>
<p>fold式には、単項fold式と二項fold式がある。そして、演算子の結合順序に合わせて左foldと右foldがある。</p>
<p>fold式は必ず括弧で囲まなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( Types ... args )
{
    <span class="co">// fold式</span>
    ( ... + args )  ;
    <span class="co">// エラー、括弧がない</span>
    ... + args ;
}</code></pre></div>
<p>単項fold式の文法は以下のいずれかになる。</p>
<pre><code>単項右fold
( cast-expression fold-operator ... )
単項左fold
( ... fold-operator cast-expression )</code></pre>
<p>例</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> f( Types ... args )
{
    <span class="co">// 単項左fold</span>
    ( ... + args )  ;
    <span class="co">// 単項右fold</span>
    ( args + ... ) ;
}</code></pre></div>
<p>cast-expressionには未展開のパラメーターパックが入っていなければならない。</p>
<p>例：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T x ) { <span class="cf">return</span> x ; }

<span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> g( Types ... args )
{
    <span class="co">// f(args#0) + f(args#1) + ... + f(args#N-1)</span>
    <span class="cf">return</span> ( ... + f(args) )  ;
}</code></pre></div>
<p>これはf(args)というパターンが展開される。</p>
<p>fold-operatorには以下のいずれかの二項演算子を使うことができる。</p>
<pre><code>+   -   *   /   %   ^   &amp;   |   &lt;&lt;  &gt;&gt;
+=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;= &gt;&gt;+ =
==  !=  &lt;   &gt;   &lt;=  &gt;=  &amp;&amp;  ||  ,   .*  -&gt;*</code></pre>
<p>fold式には左foldと右foldがある。</p>
<p>左fold式の( ... op pack )では、展開結果は((( pack#0 op pack#1 ) op pack#2 ) ... op pack#N-1 )となる。右fold式の( pack op ... )では、展開結果は( pack#0 op ( pack#1 op ( pack#2 op ( ... op pack#N-1 ))))となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> sum( Types ... args )
{
    <span class="co">// 左fold</span>
    <span class="co">// ((((1+2)+3)+4)+5)</span>
    <span class="kw">auto</span> left = ( ... + args ) ;
    <span class="co">// 右fold</span>
    <span class="co">// (1+(2+(3+(4+5))))</span>
    <span class="kw">auto</span> right = ( args + ... ) ;
}

<span class="dt">int</span> main()
{
    sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) ;
}</code></pre></div>
<p>浮動小数点数のような交換法則を満たさない型にfold式を適用する際には注意が必要だ。</p>
<p>二項fold式の文法は以下のいずれかになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">( cast-expression fold-<span class="kw">operator</span> ... fold-<span class="kw">operator</span> cast-expression )</code></pre></div>
<p>左右のcast-expressionのどちらか片方だけに未展開のパラメーターパックが入っていなければならない。2つのfold-operatorは同じ演算子でなければならない。</p>
<p>( e1 op1 ... op2 e2 )という二項fold式があったとき、e1にパラメーターパックがある場合は二項右fold式、e2にパラメーターパックがある場合は二項左fold式になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> sum( Types ... args )
{
    <span class="co">// 左fold</span>
    <span class="co">// (((((0+1)+2)+3)+4)+5)</span>
    <span class="kw">auto</span> left = ( <span class="dv">0</span> + ... + args ) ;
    <span class="co">// 右fold</span>
    <span class="co">// (0+(1+(2+(3+(4+5)))))</span>
    <span class="kw">auto</span> right = ( args + ... + <span class="dv">0</span> ) ;
}

<span class="dt">int</span> main()
{
    sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) ;
}</code></pre></div>
<p>fold式はパラメーターパックのそれぞれに二項演算子を適用したい時にわざわざ複雑な再帰的テンプレートを書かずにすむ方法を提供してくれる。</p>
<p>機能テストマクロは__cpp_fold_expressions, 値は201603。</p>
<h2 id="ラムダ式でthisのコピーキャプチャー">ラムダ式で*thisのコピーキャプチャー</h2>
<p>C++17ではラムダ式で*thisをコピーキャプチャーできるようになった。*thisをコピーキャプチャーするには、ラムダキャプチャーに*thisと書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">42</span> ;
   <span class="kw">auto</span> get()
   {
       <span class="cf">return</span> [*<span class="kw">this</span>]() { <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
   }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>function &lt; <span class="dt">int</span> () &gt; f ;
    {
        X x ;
        f = x.get() ;
    }<span class="co">// xの寿命はここまで</span>
    
    <span class="co">// コピーされているので問題ない</span>
    <span class="dt">int</span> data = f() ;
}</code></pre></div>
<p>コピーキャプチャーする*thisはlambda式が書かれた場所の*thisだ。</p>
<p>また、以下のようなコードで挙動の違いをみるとわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">0</span> ;
   <span class="dt">void</span> f()
   {
        <span class="co">// thisはポインターのキャプチャー</span>
        <span class="co">// dataはthisポインターを辿る。</span>
        [<span class="kw">this</span>]{ data = <span class="dv">1</span> ; }() ;

        <span class="co">// this-&gt;dataは1</span>

        <span class="co">// エラー、*thisはコピーされている</span>
        <span class="co">// クロージャーオブジェクトのコピーキャプチャされた変数はデフォルトで変更できない</span>
        [*<span class="kw">this</span>]{ data = <span class="dv">2</span> ; } () ;

        <span class="co">// OK、mutableを使っている</span>

        [*<span class="kw">this</span>]() <span class="at">mutable</span> { data = <span class="dv">2</span> ; } () ;

        <span class="co">// this-&gt;dataは1</span>
        <span class="co">// 変更されたのはコピーされたクロージャーオブジェクト内の*this        </span>
   }
} ;</code></pre></div>
<p>最初のラムダ式で生成されるクロージャーオブジェクトは以下のようなものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X * this_ptr ;

<span class="kw">public</span> :
    closure_object( X * this_ptr )
        : this_ptr(this_ptr) { }

    <span class="dt">void</span> <span class="kw">operator</span> () () <span class="at">const</span>
    {
        this_ptr-&gt;data = <span class="dv">1</span> ;
    }
} ;</code></pre></div>
<p>二番目のラムダ式では以下のようなクロージャーオブジェクトが生成される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X this_obj ;
    X <span class="at">const</span> * this_ptr = &amp;this_obj ;

<span class="kw">public</span> :
    closure_object( X <span class="at">const</span> &amp; this_obj )
        : this_obj(this_obj) { }

    <span class="dt">void</span> <span class="kw">operator</span> () () <span class="at">const</span>
    {
        this_ptr-&gt;data = <span class="dv">2</span> ;
    }
} ;</code></pre></div>
<p>これはC++の文法に従っていないのでやや苦しいコード例だが、コピーキャプチャーされた値を変更しようとしているためエラーとなる。</p>
<p>三番目のラムダ式では以下のようなクロージャーオブジェクトが生成される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X this_obj ;
    X * this_ptr = &amp;this_obj ;

<span class="kw">public</span> :
    closure_object( X <span class="at">const</span> &amp; this_obj )
        : this_obj(this_obj) { }

    <span class="dt">void</span> <span class="kw">operator</span> () ()
    {
        this_ptr-&gt;data = <span class="dv">2</span> ;
    }
} ;</code></pre></div>
<p>ラムダ式にmutableが付いているのでコピーキャプチャーされた値も変更できる。</p>
<p>*thisをコピーキャプチャーした場合、thisキーワードはコピーされたオブジェクトへのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">42</span> ;
   <span class="dt">void</span> f()
   {
        <span class="co">// thisはこのメンバー関数fを呼び出したオブジェクトへのアドレス</span>
        <span class="bu">std::</span>printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">this</span>) ;

        <span class="co">// thisはコピーされた別のオブジェクトへのアドレス</span>
        [*<span class="kw">this</span>](){  <span class="bu">std::</span>printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">this</span>) ;  }() ;
   }
} ;

<span class="dt">int</span> main()
{
    X x ;
    x.f() ;
}</code></pre></div>
<p>この場合、出力される2つのポインターの値は異なる。</p>
<p>ラムダ式での*thisのコピーキャプチャーは名前通り*thisのコピーキャプチャーを提供する提案だ。同等の機能は初期化キャプチャーでも可能だが、表記が冗長で間違いの元だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data ;

    <span class="kw">auto</span> f()
    {
        <span class="cf">return</span> [ tmp = *<span class="kw">this</span> ] { <span class="cf">return</span> tmp.data ; } ;
    }
} ;</code></pre></div>
<p>機能テストマクロは__cpp_capture_star_this, 値は201603。</p>
<h2 id="constexprラムダ式">constexprラムダ式</h2>
<p>C++17ではラムダ式がconstexprになった。より正確に説明すると、ラムダ式のクロージャーオブジェクトのoperator ()は条件を満たす場合constexprになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []{ <span class="cf">return</span> <span class="dv">42</span> ; } ;

    <span class="kw">constexpr</span> <span class="dt">int</span> value = f() ; <span class="co">// OK</span>
}</code></pre></div>
<p>constexprの条件を満たすラムダ式はコンパイル時定数を必要とする場所で使うことができる。例えばconstexpr変数や配列の添字やstatic_assertなどだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []{ <span class="cf">return</span> <span class="dv">42</span> ; } ;

    <span class="dt">int</span> a[f()] ;
    <span class="kw">static_assert</span>( f() == <span class="dv">42</span> ) ;
    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, f()&gt; b ;
}</code></pre></div>
<p>constexprの条件を満たすのであれば、キャプチャーもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">0</span> ; <span class="co">// 実行時の値</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> b = <span class="dv">0</span> ; <span class="co">// コンパイル時定数 </span>

    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> a ; } ;
    <span class="kw">auto</span> g = [=]{ <span class="cf">return</span> b ; } ;

    <span class="co">// エラー、constexprの条件を満たさない</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> c = f() ;

    <span class="co">// OK、constexprの条件を満たす</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> d = g() ;
}</code></pre></div>
<p>以下の内容は上級者向けの解説であり、通常の読者は理解する必要がない。</p>
<p>constexprラムダ式はSFINAEの文脈で使うことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T,
    <span class="dt">bool</span> b = []{
        T t ;
        t.func() ;
        <span class="cf">return</span> <span class="kw">true</span> ;
    }() ; &gt;
<span class="dt">void</span> f()
{
    T t ;
    t.func() ;
}</code></pre></div>
<p>なぜならば、これを許してしまうとテンプレート仮引数に対して任意の式や文がテンプレートのSubstitutionに失敗するかどうかをチェックできてしまうからだ。</p>
<p>上級者向けの解説終わり。</p>
<p>機能テストマクロは__cpp_constexpr, 値は201603。</p>
<p>__cpp_constexprマクロの値は、C++11の時点で200704、C++14の時点で201304だ。</p>
<h2 id="文字列なしstatic_assert">文字列なしstatic_assert</h2>
<p>C++17ではstatic_assertに文字列リテラルをとらないものが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>( <span class="kw">true</span> ) ;</code></pre></div>
<p>C++11で追加されたstatic_assertには、文字列リテラルが必須だった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>( <span class="kw">true</span>, <span class="st">&quot;this shall not be asserted.&quot;</span> ) ;</code></pre></div>
<p>特に文字列を指定する必要がない場合もあるので、文字列リテラルを取らないstatic_assertが追加された。</p>
<p>機能テストマクロは__cpp_static_assert, 値は201411。</p>
<p>C++11の時点で__cpp_static_assertの値は200410。</p>
<h2 id="ネストされた名前空間定義">ネストされた名前空間定義</h2>
<p>C++17ではネストされた名前空間の定義を楽に書ける。</p>
<p>ネストされた名前空間とは、A::B::Cのように名前空間の中に名前空間が入っている名前空間のことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A {
    <span class="kw">namespace</span> B {
        <span class="kw">namespace</span> C {
        <span class="co">// ...</span>
        }
    }
} </code></pre></div>
<p>C++17では、上記のコードと同じことを以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
<span class="co">// ...</span>
}</code></pre></div>
<p>機能テストマクロは__cpp_nested_namespace_definitions, 値は201411。</p>
<h2 id="fallthrough属性">[[fallthrough]]属性</h2>
<p>[[fallthrough]]属性はswitch文の中のcaseラベルを突き抜けるというヒントを出すのに使える。</p>
<p>switch文では対応するcaseラベルに処理が移る。通常、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> x )
{
    <span class="cf">switch</span> ( x )
    {
    <span class="cf">case</span> <span class="dv">0</span> :
        <span class="co">// 処理0</span>
        <span class="cf">break</span> ;
    <span class="cf">case</span> <span class="dv">1</span> :
        <span class="co">// 処理1</span>
        <span class="cf">break</span> ;
    <span class="cf">case</span> <span class="dv">2</span> :
        <span class="co">// 処理2</span>
        <span class="cf">break</span> ;
    <span class="cf">default</span> :
        <span class="co">// xがいずれでもない場合の処理</span>
        <span class="cf">break</span> ;
    }
}</code></pre></div>
<p>この例を以下のように書くと</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">case</span> <span class="dv">1</span> :
    <span class="co">// 処理1</span>
<span class="cf">case</span> <span class="dv">2</span> :
    <span class="co">// 処理2</span>
    <span class="cf">break</span> ;</code></pre></div>
<p>xが1の時は処理1を実行した後に、処理2も実行される。switch文を書くときはこのような誤りを書いてしまうことがある。そのため、賢いC++コンパイラーはswitch文のcaseラベルでbreak文やreturn文などで処理が終わらず、次のcaseラベルやdefaultラベルに処理に突き抜けるコードを発見すると、警告メッセージを出す。</p>
<p>しかし、プログラマーの意図がまさに突き抜けて処理して欲しい場合、警告メッセージは誤った警告となってしまう。そのような警告メッセージを抑制するため、またコード中に処理が突き抜けるという意図をわかりやすく記述するために、[[fallthrough]]属性が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">case</span> <span class="dv">1</span> :
    <span class="co">// 処理1</span>
    [[<span class="at">fallthrough</span>]]
<span class="cf">case</span> <span class="dv">2</span> :
    <span class="co">// 処理2</span>
    <span class="cf">break</span> ;</code></pre></div>
<p>[[fallthrough]]属性を書くと、C++コンパイラーは処理がその先に突き抜けることがわかるので、誤った警告メッセージを抑制できる。また、他人がコードを読むときに意図が明らかになる。</p>
<p>機能テストマクロは__has_cpp_attribute(fallthrough), 値は201603。</p>
<h2 id="nodiscard属性">[[nodiscard]]属性</h2>
<p>[[nodiscard]]属性は関数の戻り値が無視されてほしくない時に使うことができる。[[nodiscard]]属性が付与された関数の戻り値を無視すると警告メッセージが表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">nodiscard</span>]] <span class="dt">int</span> f()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
}

<span class="dt">void</span> g( <span class="dt">int</span> ) { }

<span class="dt">int</span> main()
{
    <span class="co">// エラー、戻り値が無視されている</span>
    f() ;

    <span class="co">// OK、戻り値は無視されていない。</span>
    <span class="dt">int</span> result = f() ;
    g( f ) ;
    f() + <span class="dv">1</span> ;
    (<span class="dt">void</span>) f() ;
}</code></pre></div>
<p>戻り値を無視する、というのは万能ではない。上の例でも、意味的には戻り値は無視されていると言えるが、コンパイラーはこの場合に戻り値が無視されているとは考えない。</p>
<p>[[nodiscard]]の目的は、戻り値を無視してほしくない関数をユーザーが利用した時の初歩的な間違いを防ぐためにある。void型にキャストするような意図的な戻り値の無視まで防ぐようには作られていない。</p>
<p>[[nodiscard]]属性を使うべき関数は、戻り値を無視してほしくない関数だ。どのような関数が戻り値を無視してほしくないかというと大きく2つある。</p>
<p>戻り値をエラーなどのユーザーが確認しなければならない情報の通知に使う関数。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">struct</span> error_code
{
    no_error, some_operations_failed,  seriou<span class="va">s_error</span>
} ;

<span class="co">// 失敗するかもしれない処理</span>
error_code do_something_that_may_fail()
{
    <span class="co">// 処理</span>

    <span class="cf">if</span> ( is_error_condition() )
        <span class="cf">return</span> error_code::serious_error ;

    <span class="co">// 処理</span>

    <span class="cf">return</span> error_code::no_error ;
}

<span class="co">// エラーが一切発生しなかった時の処理</span>
<span class="dt">int</span> do_something_on_no_error() ;

<span class="dt">int</span> main()
{
    <span class="co">// エラーを確認していない</span>
    do_something_that_may_fail() ;

    <span class="co">// エラーがない前提で次の処理をしようとする</span>
    do_something_on_no_error() ;
}</code></pre></div>
<p>関数に[[nodiscard]]属性を付与しておけば、このようなユーザー側の初歩的なエラー確認の欠如に警告メッセージを出せる。</p>
<p>[[nodiscard]]属性は、クラスとenumにも付与することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> [[<span class="at">nodiscard</span>]] X { } ;
<span class="kw">enum</span> <span class="kw">class</span> [[<span class="at">nodiscard</span>]] Y { } ;</code></pre></div>
<p>[[nodiscard]]が付与されたクラスかenumが戻り値の型である関数は[[nodiscard]]が付与された扱いとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> [[<span class="at">nodiscard</span>]] X { } ;

X f() { <span class="cf">return</span> X{} ; } 

<span class="dt">int</span> main()
{
    <span class="co">// 警告、戻り値が無視されている</span>
    f() ;
}</code></pre></div>
<p>機能テストマクロは__has_cpp_attribute(nodiscard), 値は201603。</p>
<h2 id="maybe_unused属性">[[maybe_unused]]属性</h2>
<p>[[maybe_unused]]属性は名前やエンティティが意図的に使われないことを示すのに使える。</p>
<p>現実のC++のコードでは、宣言されているのにソースコードだけを考慮するとどこからも使われていないように見える名前やエンティティが存在する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_something( <span class="dt">int</span> *, <span class="dt">int</span> * ) ;

<span class="dt">void</span> f()
{
    <span class="dt">int</span> x[<span class="dv">5</span>] ;
    <span class="dt">char</span> reserved[<span class="dv">1024</span>] = { } ;
    <span class="dt">int</span> y[<span class="dv">5</span>] ;

    do_something( x, y ) ;
}</code></pre></div>
<p>ここではreservedという名前はどこからも使われていない。一見すると不必要な名前に見える。優秀なC++コンパイラーはこのようなどこからも使われていない名前に対して「どこからも使われていない」という警告メッセージを出す。</p>
<p>しかし、コンパイラーから見えているソースコードがプログラムの全てではない。様々な理由でreservedのような一見使われていない変数が必要になる。</p>
<p>例えば、reservedはスタック破壊を検出するための領域かもしれない。プログラムはC++以外の言語で書かれたコードとリンクしていて、そこで使われるのかもしれない。あるいはOSや外部デバイスが読み書きするメモリとして確保しているのかもしれない。</p>
<p>どのような理由にせよ、名前やエンティティが一見使われていないように見えるが存在が必要であるという意味を表すのに、[[maybe_unused]]属性を使うことができる。これにより、C++コンパイラーの「未使用の名前」という警告メッセージを抑制できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">maybe_unused</span>]] <span class="dt">char</span> reserved[<span class="dv">1024</span>] ;</code></pre></div>
<p>[[maybe_unused]]属性を適用できる名前とエンティティの宣言は、クラス、typedef名、変数、非staticデータメンバー、関数、enum、enumeratorだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// クラス</span>
<span class="kw">class</span> [[<span class="at">maybe_unused</span>]] clas<span class="va">s_name</span>
{
<span class="co">// 非staticデータメンバー</span>
    [[<span class="at">maybe_unused</span>]] <span class="dt">int</span> non_static_data_member ;

} ;

<span class="co">// typedef名</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="kw">typedef</span> <span class="dt">int</span> typedef_name1 ;
<span class="kw">typedef</span> <span class="dt">int</span> typedef_name2 [[<span class="at">maybe_unused</span>]] ;

<span class="co">// エイリアス宣言によるtypedef名</span>
<span class="kw">using</span> typedef_name3 [[<span class="at">maybe_unused</span>]] = <span class="dt">int</span> ;

<span class="co">// 変数</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="dt">int</span> variable_name1{};
<span class="dt">int</span> variable_name2 [[<span class="at">maybe_unused</span>]] { } ;

<span class="co">// 関数</span>
<span class="co">// メンバー関数も同じ文法</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="dt">void</span> function_name1() { }
<span class="dt">void</span> function_name2 [[<span class="at">maybe_unused</span>]] () { }

<span class="kw">enum</span> [[<span class="at">maybe_unused</span>]] enu<span class="va">m_name</span>
{
<span class="co">// enumerator</span>
    enumerator_name [[<span class="at">maybe_unused</span>]] = <span class="dv">0</span>
} ;</code></pre></div>
<p>機能テストマクロは__has_cpp_attribute(maybe_unused), 値は201603</p>
<h2 id="演算子のオペランドの評価順序の固定">演算子のオペランドの評価順序の固定</h2>
<p>C++17では演算子のオペランドの評価順序が固定された。</p>
<p>以下の式は、a, bの順番に評価されることが規格上保証される。@=の@には文法上許される任意の演算子が入る(+=, -=など)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a.b
a-&gt;b
a-&gt;*b
a(b1,b2,b3)
b <span class="er">@</span>= a
a[b]
a &lt;&lt; b
a &gt;&gt; b</code></pre></div>
<p>つまり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>* f() ;
<span class="dt">int</span> g() ;

<span class="dt">int</span> main()
{
   f()[g()] ; 
}</code></pre></div>
<p>と書いた場合、関数fがまず先に呼び出されて、次に関数gが呼び出されることが保証される。</p>
<p>関数呼び出しの実引数のオペランドb1, b2, b3の評価順序は未規定のままだ。</p>
<p>これにより、既存の未定義の動作となっていたコードの挙動が定まる。</p>
<h2 id="constexpr-if文-コンパイル時条件分岐">constexpr if文 : コンパイル時条件分岐</h2>
<p>constexpr if文はコンパイル時の条件分岐ができる機能だ。</p>
<p>constexpr if文は、通常のif文をif constexprで置き換える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// if文</span>
<span class="cf">if</span> ( expression )
    statement ;

<span class="co">// constexpr if文</span>
<span class="cf">if</span> <span class="kw">constexpr</span> ( expression )
    statement ;</code></pre></div>
<p>constexpr if文という名前だが、実際に記述するときはif constexprだ。</p>
<p>コンパイル時の条件分岐とは何を意味するのか。以下はconstexpr ifが<strong>行わないもの</strong>の一覧だ。</p>
<ul>
<li>最適化</li>
<li>非テンプレートコードにおける挙動の変化</li>
</ul>
<p>コンパイル時の条件分岐の機能を理解するには、まずC++の既存の条件分岐について理解する必要がある。</p>
<h3 id="実行時の条件分岐">実行時の条件分岐</h3>
<p>通常の実行時の条件分岐は、実行時の値を取り、実行に条件分岐を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( runtime_value )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ;
}</code></pre></div>
<p>この場合、runtime_valueがtrueの場合は関数do_true_thingが呼ばれ、falseの場合は関数do_false_thingが呼ばれる。</p>
<p>実行時の条件分岐の条件には、コンパイル時定数を指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="kw">true</span> )
    do_true_thing() ;
<span class="cf">else</span>
    do_false_thing() ;</code></pre></div>
<p>この場合、賢いコンパイラーは以下のように処理を最適化するかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">do_true_thing() ;</code></pre></div>
<p>なぜならば、条件は常にtrueだからだ。このような最適化は実行時の条件分岐でもコンパイル時に行える。コンパイル時の条件分岐はこのような最適化が目的ではない。</p>
<p>もう一度コード例に戻ろう。こんどは完全なコードをみてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( <span class="kw">true</span> )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>このコードはエラーになる。その理由は、do_false_thingという名前が宣言されていないからだ。C++コンパイラーは、コンパイル時にコードを以下の形に変形することで最適化することはできるが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_true_thing() ;

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    do_true_thing() ;
}</code></pre></div>
<p>最適化の結果失われたものも、依然としてコンパイル時にコードとして検証はされる。コードとして検証されるということは、コードとして誤りがあればエラーとなる。名前do_false_thingは宣言されていないのでエラーとなる。</p>
<h3 id="プリプロセス時の条件分岐">プリプロセス時の条件分岐</h3>
<p>C++がC言語から受け継いだCプリプロセッサーには、プリプロセス時の条件分岐の機能がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{

<span class="pp">#if true</span>
    do_true_thing() ;
<span class="pp">#else</span>
<span class="co">    do_false_thing() ;</span>
<span class="pp">#endif</span>
}</code></pre></div>
<p>このコードは、プリプロセスの結果、以下のように変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_true_thing() ;

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    do_true_thing() ;
}</code></pre></div>
<p>この結果、プリプロセス時の条件分岐では、選択されない分岐はコンパイルされないので、コンパイルエラーになるコードも書くことができる。</p>
<p>プリプロセス時の条件分岐は、条件が整数とかbool型のリテラルか、リテラルに比較演算子を適用した結果ではうまくいく。しかし、プリプロセス時とはコンパイル時ではないので、コンパイル時計算はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f()
{
    <span class="cf">return</span> <span class="dv">1</span> ;
}

<span class="dt">void</span> do_true_thing() ;

<span class="dt">int</span> main()
{
<span class="co">// エラー</span>
<span class="co">// 名前fはプリプロセッサーマクロではない。</span>
<span class="pp">#if f()</span>
    do_true_thing() ;
<span class="pp">#else</span>
    do_false_thing() ;
<span class="pp">#endif</span>
}</code></pre></div>
<h3 id="コンパイル時の条件分岐">コンパイル時の条件分岐</h3>
<p>コンパイル時の条件分岐とは、分岐の条件にコンパイル時計算の結果を使い、かつ、選択されない分岐にコンパイルエラーが含まれていても、使われないのでコンパイルエラーにはならない条件分岐のことだ。</p>
<p>たとえば、std::distanceという標準ライブラリを実装してみよう。std::distance(first, last)は、イテレーターfirstとlastの距離を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="cf">return</span> last - first ;
}</code></pre></div>
<p>残念ながら、この実装はIteratorがランダムアクセスイテレーターの場合にしか動かない。入力イテレーターに対応させるには、イテレーターを一つづつインクリメントしてlastと等しいかどうか比較する実装が必要になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

    <span class="cf">while</span> ( first != last )
    {
        ++n ;
        ++first ;
    }

    <span class="cf">return</span> n ;
}</code></pre></div>
<p>残念ながら、この実装はIteratorにランダムアクセスイテレーターを渡した時に効率が悪い。</p>
<p>ここで必要な実装は、Iteratorがランダムアクセスイテレーターならばlast - firstを使い、そうでなければ地道にインクリメントする遅い実装を使うことだ。Iteratorがランダムアクセスイテレーターかどうかは、以下のコードを使えば、is_random_access_iterator&lt;iterator&gt;で確認できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_random_access_iterator =
    <span class="bu">std::</span>is_same_v&lt;
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; 
            <span class="bu">std::</span>decay_t&lt;Iterator&gt; 
        &gt;::iterator_category,
        <span class="bu">std::</span>random_access_iterator_tag &gt; ;</code></pre></div>
<p>すると、distanceは以下のように書けるのではないか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ランダムアクセスイテレーターかどうかを判定するコード</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_random_access_iterator =
    <span class="bu">std::</span>is_same_v&lt;
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; 
            <span class="bu">std::</span>decay_t&lt;Iterator&gt;
        &gt;::iterator_category,
        <span class="bu">std::</span>random_access_iterator_tag &gt; ;

<span class="co">// distance</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="co">// ランダムアクセスイテレーターかどうか確認する</span>
    <span class="cf">if</span> ( is_random_access_iterator&lt;Iterator&gt; )
    {<span class="co">// ランダムアクセスイテレーターなので速い方法を使う</span>
        <span class="cf">return</span> last - first ;
    }
    <span class="cf">else</span>
    { <span class="co">// ランダムアクセスイテレーターではないので遅い方法を使う</span>
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

        <span class="cf">while</span> ( first != last )
        {
            ++n ;
            ++first ;
        }

        <span class="cf">return</span> n ;
    }
}</code></pre></div>
<p>残念ながら、このコードは動かない。ランダムアクセスイテレーターではないイテレーターを渡すと、last - firstというコードがコンパイルされるので、コンパイルエラーになる。コンパイラーは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( is_random_access_iterator&lt;Iterator&gt; )</code></pre></div>
<p>という部分について、is_random_access_iterator&lt;Iterator&gt;の値はコンパイル時に計算できるので、最終的なコード生成の結果としては、if (true)かif (false)なると判断できる。したがってコンパイラーは選択されない分岐のコード生成を行わないことはできる。しかしコンパイルはするので、コンパイルエラーになる。</p>
<p>constexpr ifを使うと、選択されない部分の分岐はコンパイルエラーであってもコンパイルエラーとはならなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// distance</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="co">// ランダムアクセスイテレーターかどうか確認する</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( is_random_access_iterator&lt;Iterator&gt; )
    {<span class="co">// ランダムアクセスイテレーターなので速い方法を使う</span>
        <span class="cf">return</span> last - first ;
    }
    <span class="cf">else</span>
    { <span class="co">// ランダムアクセスイテレーターではないので遅い方法を使う</span>
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

        <span class="cf">while</span> ( first != last )
        {
            ++n ;
            ++first ;
        }

        <span class="cf">return</span> n ;
    }
}</code></pre></div>
<h3 id="超上級者向け解説">超上級者向け解説</h3>
<p>constexpr ifは、実はコンパイル時条件分岐ではない。テンプレートの実体化時に、選択されないブランチのテンプレートの実体化の抑制を行う機能だ。</p>
<p>constexpr ifによって選択されない文はdiscarded statementとなる。discarded statementはテンプレートの実体化の際に実体化されなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> get() { <span class="cf">return</span> <span class="dv">0</span> ; } 
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">int</span> f(T x)
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt; <span class="bu">std::</span>decay_t&lt;T&gt;, X &gt; )
        <span class="cf">return</span> x.get() ;
    <span class="cf">else</span>
        <span class="cf">return</span> x ;

}

<span class="dt">int</span> main()
{
    X x ;
    f( x ) ; <span class="co">// return x.get() </span>
    f( <span class="dv">0</span> ) ; <span class="co">// return x</span>
}</code></pre></div>
<p>f(x)では、return xがdiscarded statementとなるため実体化されない。Xはint型に暗黙に変換できないが問題がなくなる。f(0)ではreturn x.get()がdiscarded statementとなるため実体化されない。int型にはメンバー関数getはないが問題はなくなる。</p>
<p>discarded statementは実体化されないだけで、もちろんテンプレートのエンティティの一部だ。discarded statementがテンプレートのコードとして文法的、意味的に正しくない場合は、もちろんコンパイルエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T x )
{
    <span class="co">// エラー、名前gは宣言されていない</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">false</span> )
        g() ; 

    <span class="co">// エラー、文法違反</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">false</span> )
        !<span class="er">#$</span>%^&amp;*()_+ ;
}</code></pre></div>
<p>何度も説明しているように、constexpr ifはテンプレートの実体化を条件付きで抑制するだけだ。条件付きコンパイルではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; )
    {
        <span class="co">// 常にコンパイルエラー</span>
        <span class="kw">static_assert</span>( <span class="kw">false</span> ) ;
    }
}</code></pre></div>
<p>このコードは常にコンパイルエラーになる。なぜならば、static_assert( false ) はテンプレートに依存しておらず、テンプレートの宣言を解釈するときに、依存名ではないから、そのまま解釈される。</p>
<p>このようなことをしたければ、最初からstatic_assertのオペランドに式を書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="kw">static_assert</span>( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; ) ;

    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; )
    {
    }
}</code></pre></div>
<p>もし、どうしてもconstexpr文の条件に合うときにだけstatic_assertが使いたい場合もある。これは、constexpr ifをネストしたりしていて、その内容を全部static_assertに書くのが冗長な場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( E1 )
        <span class="cf">if</span> <span class="kw">constexpr</span> ( E2 )
            <span class="cf">if</span> <span class="kw">constexpr</span> ( E3 )
            {
                <span class="co">// E1 &amp;&amp; E2 &amp;&amp; E3のときにコンパイルエラーにしたい</span>
                <span class="co">// 実際には常にコンパイルエラー</span>
                <span class="kw">static_assert</span>( <span class="kw">false</span> ) ;
            }
}</code></pre></div>
<p>現実には、E1, E2, E3は複雑な式なので、static_assert( E1 &amp;&amp; E2 &amp;&amp; E3 )と書くのは冗長だ。同じ内容を二度書くのは間違いの元だ。</p>
<p>このような場合、static_assertのオペランドをテンプレート引数に依存するようにすると、constexpr ifの条件に合うときにだけ発動するstatic_assertが書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>  &lt; <span class="kw">typename</span> ... &gt;
<span class="dt">bool</span> false_v = <span class="kw">false</span> ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( E1 )
        <span class="cf">if</span> <span class="kw">constexpr</span> ( E2 )
            <span class="cf">if</span> <span class="kw">constexpr</span> ( E3 )
            {
                <span class="kw">static_assert</span>( false_v&lt;T&gt; ) ;
            }
}</code></pre></div>
<p>このようにfalse_vを使うことで、static_assertをテンプレート引数Tに依存させる。その結果、static_assertの発動をテンプレートの実体化まで遅延させることができる。</p>
<p>constexpr ifは非テンプレートコードでも書くことができるが、その場合は普通のif文と同じだ。</p>
<h3 id="constexpr-ifでは解決できない問題">constexpr ifでは解決できない問題</h3>
<p>constexpr ifは条件付きコンパイルではなく、条件付きテンプレート実体化の抑制なので、最初の問題の解決には使えない。例えば以下のコードはエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">true</span> )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>理由は、名前do_false_thingは非依存名なのでテンプレートの宣言時に解決されるからだ。</p>
<h3 id="constexpr-ifで解決できる問題">constexpr ifで解決できる問題</h3>
<p>constexpr ifは依存名が関わる場合で、テンプレートの実体化がエラーになる場合に、実体化を抑制させることができる。</p>
<p>例えば、特定の型に対して特別な操作をしたい場合。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> get_value() ;
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f(T t)
{
    
    <span class="dt">int</span> value{} ;

    <span class="co">// Tの型がXならば特別な処理を行いたい</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same&lt;T, X&gt;{} )
    {
        value = t.get_value() ;
    }
    <span class="cf">else</span>
    {
        value = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(t) ;
    }
}</code></pre></div>
<p>もしconstexpr ifがなければ、Tの型がXではないときもt.get_value()という式が実体化され、エラーとなる。</p>
<p>再帰的なテンプレートの特殊化をやめさせたいとき</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// factorial&lt;N&gt;はNの階乗を返す</span>
<span class="kw">template</span> &lt; <span class="bu">std::</span>size_t I  &gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t factorial()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( I == <span class="dv">1</span> )
    { <span class="cf">return</span> <span class="dv">1</span> ; }
    <span class="cf">else</span>
    { <span class="cf">return</span> I * factorial&lt;I<span class="dv">-1</span>&gt;() ; }
}</code></pre></div>
<p>もしconstexpr ifがなければ、factorial&lt;N-1&gt;が永遠に実体化されコンパイル時ループが停止しない。</p>
<p>機能テストマクロは__cpp_if_constexpr, 値は201606。</p>
<h2 id="初期化文つき条件文">初期化文つき条件文</h2>
<p>C++17では、条件文に初期化文を記述できるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="dt">int</span> x = <span class="dv">1</span> ; x )
     <span class="co">/*...*/</span> ;

<span class="cf">switch</span>( <span class="dt">int</span> x = <span class="dv">1</span> ; x )
{
    <span class="cf">case</span> <span class="dv">1</span> :
        <span class="co">/*... */</span>;
}</code></pre></div>
<p>これは、以下のコードと同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="cf">if</span> ( x ) ;
}

{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="cf">switch</span>( x )
    {
        <span class="cf">case</span> <span class="dv">1</span> : ;
    }
}</code></pre></div>
<p>なぜこのような機能が追加されたかというと、変数を宣言し、if文の条件に変数を使い、if文を実行後は変数を使用しない、というパターンは現実のコードで頻出するからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc(<span class="dv">10</span>) ;
<span class="cf">if</span> ( ptr != <span class="kw">nullptr</span> )
{
    <span class="co">// 処理</span>
    <span class="bu">std::</span>free(ptr) ;
}
<span class="co">// これ以降ptrは使わない</span>

FILE * file = <span class="bu">std::</span>fopen(<span class="st">&quot;text.txt&quot;</span>, <span class="st">&quot;r&quot;</span>) ;
<span class="cf">if</span> ( file != <span class="kw">nullptr</span> )
{
    <span class="co">// 処理</span>
    <span class="bu">std::</span>fclose( file ) ;
}
<span class="co">// これ以降fileは使わない</span>

<span class="kw">auto</span> int_ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
<span class="cf">if</span> ( ptr )
{
    <span class="co">// 処理</span>
}
<span class="co">// これ以降int_ptrは使わない</span></code></pre></div>
<p>上記のコードには問題がある。これ以降変数は使わないが、変数自体は使えるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
<span class="cf">if</span> ( ptr )
{
    <span class="co">// 処理</span>
}
<span class="co">// これ以降ptrは使わない</span>

<span class="co">// でも使える</span>
<span class="dt">int</span> value = *ptr ;</code></pre></div>
<p>変数を使えないようにするには、ブロックスコープで囲むことで、変数をスコープから外してやればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="kw">auto</span> int_ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
    <span class="cf">if</span> ( ptr )
    {
        <span class="co">// 処理</span>
    }
    <span class="co">// ptrは破棄される</span>
}
<span class="co">// これ以降ptrは使わないし使えない</span></code></pre></div>
<p>このようなパターンは頻出するので、初期化文つきの条件文が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ; ptr )
{
    <span class="co">// 処理</span>
}</code></pre></div>
<h2 id="クラステンプレートのコンストラクターからの実引数推定">クラステンプレートのコンストラクターからの実引数推定</h2>
<p>C++17ではクラステンプレートのコンストラクターの実引数からテンプレート実引数の推定が行えるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> X
{
    X( T t ) { }
} ;

<span class="dt">int</span> main()
{
    X x1(<span class="dv">0</span>) ; <span class="co">// X&lt;int&gt;</span>
    X x2(<span class="fl">0.0</span>) ; <span class="co">// X&lt;double&gt;</span>
    X x3(<span class="st">&quot;hello&quot;</span>) ; <span class="co">// X&lt;char const *&gt;</span>
}</code></pre></div>
<p>これは関数テンプレートが実引数からテンプレート実引数の推定が行えるのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T t ) { }

<span class="dt">int</span> main()
{
    f( <span class="dv">0</span> ) ; <span class="co">// f&lt;int&gt;</span>
    f( <span class="fl">0.0</span> ) ; <span class="co">// f&lt;double&gt;</span>
    f( <span class="st">&quot;hello&quot;</span> ) ; <span class="co">// f&lt;char const *&gt;</span>
}</code></pre></div>
<h3 id="推定ガイド">推定ガイド</h3>
<p>クラステンプレートのコンストラクターからの実引数は便利だが、クラスのコンストラクターはクラステンプレートのテンプレートパラメーターに一致しない場合もある。そのような場合はそのままでは実引数推定ができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// コンテナー風のクラス</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> Container
{
    <span class="bu">std::</span>vector&lt;T&gt; c ;
<span class="kw">public</span> :
    <span class="co">// 初期化にイテレーターのペアを取る。</span>
    <span class="co">// IteratorはTではない。</span>
    <span class="co">// Tは推定できない</span>
    <span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
    Container( Iterator first, Iterator last )
        : c( first, last )
    { }
} ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="co">// エラー</span>
    <span class="co">// Tを推定できない</span>
    Container c( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a) ) ;
}</code></pre></div>
<p>このため、C++17には推定ガイドという機能が提供されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">テンプレート名( 引数リスト ) -&gt; テンプレートid ;</code></pre></div>
<p>これを使うと、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
Container( Iterator, Iterator )
-&gt; Container&lt; <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; Iterator &gt;::<span class="dt">value_type</span> &gt; ;</code></pre></div>
<p>C++コンパイラーはこの推定ガイドを使って、Container&lt;T&gt;::Container(Iterator, Iterator)からは、Tをstd::iterator_traits&lt;Iterator&gt;::value_typeとして推定すればいいのだと判断できる。</p>
<p>例えば、初期化リストに対応するには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> Container
{
    <span class="bu">std::</span>vector&lt;T&gt; c ;
<span class="kw">public</span> :

    Container( <span class="bu">std::</span>initializer_list&lt;T&gt; init )
        : c( init )
    { }
} ;


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
Container( <span class="bu">std::</span>initializer_list&lt;T&gt; ) -&gt; Container&lt;T&gt; ;


<span class="dt">int</span> main()
{
    Container c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
}</code></pre></div>
<p>C++コンパイラーはこの推定ガイドから、Container&lt;T&gt;::Container( std::initializer_list&lt;T&gt; )の場合はTをTとして推定すればよいことがわかる。</p>
<p>機能テストマクロは__cpp_deduction_guides, 値は201606。</p>
<h2 id="autoによる非型テンプレートパラメーターの宣言">autoによる非型テンプレートパラメーターの宣言</h2>
<p>C++17では非型テンプレートパラメーターの宣言にautoを使うことができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">auto</span> x &gt;
<span class="kw">struct</span> X { } ;

<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    X&lt;<span class="dv">0</span>&gt; x1 ;
    X&lt;<span class="dv">0l</span>&gt; x2 ;
    X&lt;&amp;f&gt; x3 ;
}</code></pre></div>
<p>これはC++14までであれば、以下のように書かなければならなかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, T x &gt;
<span class="kw">struct</span> X { } ;

<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    X&lt;<span class="dt">int</span>, <span class="dv">0</span>&gt; x1 ;
    X&lt;<span class="dt">long</span>, <span class="dv">0l</span>&gt; x2 ;
    X&lt;<span class="dt">void</span>(*)(), &amp;f&gt; x3 ;
}</code></pre></div>
<p>機能テストマクロは__cpp_template_auto, 値は201606。</p>
<h2 id="using属性名前空間">using属性名前空間</h2>
<p>C++17では、属性名前空間にusingディレクティブのような記述ができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// [[extention::foo, extention::bar]]と同じ</span>
[[ <span class="at">using</span> <span class="at">extention</span> <span class="at">:</span> <span class="at">foo</span>, <span class="at">bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>属性トークンには、属性名前空間をつけることができる。これにより、独自拡張の属性トークンの名前の衝突を避けることができる。</p>
<p>例えば、あるC++コンパイラーには独自拡張としてfoo, barという属性トークンがあり、別のC++コンパイラーも同じく独自拡張としてfoo, barという属性トークンを持っているが、それぞれ意味が違っている場合、コードの意味も違ってしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[ <span class="at">foo</span>, <span class="at">bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>このため、C++には属性名前空間という文法が用意されている。注意深いC++コンパイラーは独自拡張の属性トークンには属性名前空間を設定していることだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[ <span class="at">extention::foo</span>, <span class="at">extention::bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>問題は、これをいちいち記述するのは面倒だということだ。</p>
<p>C++17では、using属性名前空間という機能により、usingディレクティブのような名前空間の省略が可能になった。文法はusingディレクティブと似ていて、属性の中でusing name : ...と書くことで、コロンに続く属性トークンに、属性名前空間nameをつけたものと同じ効果が得られる。</p>
<h2 id="非標準属性の無視">非標準属性の無視</h2>
<p>C++17では、非標準の属性トークンは無視される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK、無視される</span>
[[ <span class="at">wefapiaofeaofjaopfij</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>属性はC++コンパイラーによる独自拡張をC++の規格に準拠する形で穏便に追加するための機能だ。その属性のためにコンパイルエラーになった場合、結局Cプリプロセッサーを使うか、煩わしさから独自の文法が使われてしまう。そのためこの機能は必須だ。</p>
<h2 id="構造化束縛">構造化束縛</h2>
<p>C++17で追加された構造化束縛は多値を分解して受け取るための変数宣言の文法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
    <span class="kw">auto</span> [b,c,d] = a ;

    <span class="co">// b == 1</span>
    <span class="co">// c == 2</span>
    <span class="co">// d == 3</span>
}</code></pre></div>
<p>C++では、様々な方法で多値を扱うことができる。例えば配列、クラス、tuple, pairだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="kw">struct</span> B
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> b ;
    <span class="bu">std::</span>string c ;
} ;

B b{ <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

<span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; c { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

<span class="bu">std::</span>pair&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; d{ <span class="dv">1</span>, <span class="dv">2</span> } ;</code></pre></div>
<p>C++の関数は配列以外の多値を返すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}</code></pre></div>
<p>多値を受け取るには、これまでは多値を塊として受け取るか、ライブラリで分解して受け取るしかなかった。</p>
<p>多値を塊で受け取るには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> result = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(result) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(result) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(result) &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>多値をライブラリで受け取るには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> b ;
    <span class="bu">std::</span>string c ;

    <span class="bu">std::</span>tie( a, b, c ) = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>構造化束縛を使うと、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> [a, b, c] = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>変数の型はそれぞれ対応する多値の型になる。この場合、a, b, cはそれぞれint, double, std::string型になる。</p>
<p>tupleだけではなく、pairも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; p( <span class="dv">1</span>, <span class="dv">2</span> ) ;

    <span class="kw">auto</span> [a,b] = p ;

    <span class="co">// aはint型、値は1</span>
    <span class="co">// bはint型、値は2</span>
}</code></pre></div>
<p>構造化束縛はif文とswitch文、for文でも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="cf">if</span> ( <span class="kw">auto</span>[a,b,c] = expr ; a )
    { }
    <span class="cf">switch</span>( <span class="kw">auto</span>[a,b,c] = expr ; a )
    { }
    <span class="cf">for</span> ( <span class="kw">auto</span>[a,b,c] = expr ; <span class="kw">false</span> ; ) 
    { }
}</code></pre></div>
<p>構造化束縛はrange-based for文にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="bu">std::</span>string, <span class="bu">std::</span>string &gt; translation_table
    {
        {<span class="st">&quot;dog&quot;</span>, <span class="st">&quot;犬&quot;</span>},
        {<span class="st">&quot;cat&quot;</span>, <span class="st">&quot;猫&quot;</span>},
        {<span class="st">&quot;answer&quot;</span>, <span class="st">&quot;42&quot;</span>} 
    } ;
    
    <span class="cf">for</span> ( <span class="kw">auto</span> [key, value] : translation_table )
    {
        <span class="bu">std::</span>cout&lt;&lt;
            <span class="st">&quot;key=&quot;</span>&lt;&lt; key &lt;&lt;
            <span class="st">&quot;, value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<p>これは、mapの要素型std::pair&lt;const std::string, std::string&gt;を構造化束縛[key, value]で受けている。</p>
<p>構造化束縛は配列にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> values[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b,c] = values ;
}</code></pre></div>
<p>構造化束縛はクラスにも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Values
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string c ;
} ;

<span class="dt">int</span> main()
{
    Values values{ <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

    <span class="kw">auto</span> [a,b,c] = values ;
}</code></pre></div>
<p>構造化束縛でクラスを使う場合は、非staticデータメンバーはすべてひとつのクラスのpublicなメンバーでなければならない。</p>
<p>構造化束縛はconstexprにはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">constexpr</span> <span class="dt">int</span> expr[] = { <span class="dv">1</span>,<span class="dv">2</span> } ;

    <span class="co">// エラー</span>
    <span class="kw">constexpr</span> <span class="kw">auto</span> [a,b] = expr ;
}</code></pre></div>
<h3 id="超上級者向け解説-1">超上級者向け解説</h3>
<p>構造化束縛は、変数の宣言のうち、<strong>構造化束縛宣言(structured binding declaration)</strong>に分類される文法で記述する。構造化束縛宣言となる宣言は、単純宣言(simple-declaration)とfor-range宣言(for-range-declaration)のうち、[識別子リスト]があるものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">単純宣言:
    属性 <span class="kw">auto</span> CV修飾子(省略可) リファレンス修飾子(省略可) [ 識別子リスト ] 初期化子 ;

<span class="cf">for</span>-range宣言:
    属性 <span class="kw">auto</span> CV修飾子(省略可) リファレンス修飾子(省略可) [ 識別子リスト ] ;

識別子リスト:
    コンマで区切られた識別子

初期化子:
    = 式
    { 式 }
    ( 式 )</code></pre></div>
<p>以下は単純宣言のコード例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> e1[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">struct</span> { <span class="dt">int</span> a,b,c ; } e2{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> e3 = <span class="bu">std::</span>make_tuple(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) ;
    
    <span class="co">// &quot;= 式&quot;の例</span>
    <span class="kw">auto</span> [a,b,c] = e1 ;
    <span class="kw">auto</span> [d,e,f] = e2 ;
    <span class="kw">auto</span> [g,h,i] = e3 ;
    
    <span class="co">// &quot;{式}&quot;, &quot;(式)&quot;の例</span>
    <span class="kw">auto</span> [j,k,l]{e1} ;
    <span class="kw">auto</span> [m,n,o](e1) ;

    <span class="co">// CV修飾子とリファレンス修飾子を使う例</span>
    <span class="kw">auto</span> <span class="at">const</span> &amp; [p,q,r] = e1 ;
}</code></pre></div>
<p>以下はfor-range宣言の例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; pairs[] = { {<span class="dv">1</span>,<span class="dv">2</span>}, {<span class="dv">3</span>,<span class="dv">4</span>}, {<span class="dv">5</span>,<span class="dv">6</span>} } ;
    
    <span class="cf">for</span> ( <span class="kw">auto</span> [a, b] : pairs )
    {
        <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h3 id="構造化束縛宣言の仕様">構造化束縛宣言の仕様</h3>
<p>構造化束縛の構造化束縛宣言は以下のように解釈される。</p>
<p>構造化束縛宣言によって宣言される変数の数は、初期化子の多値の数と一致していなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 2個の値を持つ</span>
    <span class="dt">int</span> expr[] = {<span class="dv">1</span>,<span class="dv">2</span>} ;

    <span class="co">// エラー、変数が少なすぎる</span>
    <span class="kw">auto</span>[a] = expr ; 
    <span class="co">// エラー、変数が多すぎる</span>
    <span class="kw">auto</span>[b,c,d] = expr ;
}</code></pre></div>
<p>構造化束縛宣言で宣言されるそれぞれの変数名について、記述された通りの属性、CV修飾子、リファレンス修飾子の変数が宣言される。</p>
<h3 id="初期化子の型が配列の場合">初期化子の型が配列の場合</h3>
<p>初期化子が配列の場合、それぞれの変数はそれぞれの配列の要素で初期化される。</p>
<p>リファレンス修飾子がない場合、それぞれの変数はコピー初期化される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b,c] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> a = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> b = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> c = expr[<span class="dv">2</span>] ;
}</code></pre></div>
<p>リファレンス修飾子がある場合、変数はリファレンスとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> &amp; [a,b,c] = expr ;
    <span class="kw">auto</span> &amp;&amp; [d,e,f] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> &amp; a = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> &amp; b = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp; c = expr[<span class="dv">2</span>] ;

    <span class="dt">int</span> &amp;&amp; d = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> &amp;&amp; e = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp;&amp; f = expr[<span class="dv">2</span>] ;
}</code></pre></div>
<p>もし、変数の型が配列の場合、配列の要素はそれぞれ対応する配列の要素で初期化される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,<span class="dv">2</span>}} ;
    <span class="kw">auto</span> [a,b] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,<span class="dv">2</span>}} ;

    <span class="dt">int</span> a[<span class="dv">2</span>] = { expr[<span class="dv">0</span>][<span class="dv">0</span>], expr[<span class="dv">0</span>][<span class="dv">1</span>] } ;
    <span class="dt">int</span> b[<span class="dv">2</span>] = { expr[<span class="dv">1</span>][<span class="dv">0</span>], expr[<span class="dv">1</span>][<span class="dv">1</span>] } ;    
}</code></pre></div>
<h3 id="初期化子の型が配列ではなくstdtuple_sizeeが完全形の名前である場合">初期化子の型が配列ではなく、std::tuple_size&lt;E&gt;が完全形の名前である場合</h3>
<p>構造化束縛宣言の初期化子の型Eが配列ではない場合で、std::tuple_size&lt;E&gt;が完全形の名前である場合、</p>
<p>構造化束縛宣言の初期化子の型をE、その値をeとする。構造化束縛宣言で宣言されるひとつ目の変数を0, ふたつ目の変数を1...とインクリメントされていくインデックスをiとする。</p>
<p>std::tuple_size&lt;E&gt;::valueは整数のコンパイル時定数式で、その値は初期化子の値の数でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::tuple&lt; int, int, int &gt;</span>
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> [a,b,c] = e ;

    <span class="co">// std::tuple_size&lt;decltype(e)&gt;::sizeは3</span>
}</code></pre></div>
<p>それぞれの値を取得するために、非修飾名getが型Eのクラススコープから探される。getが見つかった場合、それぞれの変数の初期化子はe.get&lt;i&gt;()となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> [a,b,c] = e ;</code></pre></div>
<p>という構造化束縛宣言は、以下の意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">type a = e.get&lt;<span class="dv">0</span>&gt;() ;
type b = e.get&lt;<span class="dv">1</span>&gt;() ;
type c = e.get&lt;<span class="dv">2</span>&gt;() ;</code></pre></div>
<p>そのようなgetの宣言が見つからない場合、初期化子はget&lt;i&gt;(e)となる。この場合、getは連想名前空間から探される。通常の非修飾名前検索は行われない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ただし通常の非修飾名前検索は行われない。</span>
type a = get&lt;<span class="dv">0</span>&gt;(e) ;
type b = get&lt;<span class="dv">1</span>&gt;(e) ;
type c = get&lt;<span class="dv">2</span>&gt;(e) ;</code></pre></div>
<p>構造化束縛宣言で宣言される変数の型は以下のように決定される。</p>
<p>変数の型typeは&quot;std::tuple_element&lt;i, E&gt;::type&quot;となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type a = get&lt;<span class="dv">0</span>&gt;(e) ;
<span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type b = get&lt;<span class="dv">1</span>&gt;(e) ;
<span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type c = get&lt;<span class="dv">2</span>&gt;(e) ;</code></pre></div>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> [a,b,c] = e ;
}</code></pre></div>
<p>以下とほぼ同等の意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    
    <span class="kw">using</span> E = <span class="kw">decltype</span>(e) ;

    <span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type &amp; a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(e) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type &amp; b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(e) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type &amp; c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(e) ;
}</code></pre></div>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> &amp;&amp; [a,b,c] = <span class="bu">std::</span>move(e) ;
}</code></pre></div>
<p>以下のような意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    
    <span class="kw">using</span> E = <span class="kw">decltype</span>(e) ;

    <span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type &amp;&amp; a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(<span class="bu">std::</span>move(e)) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type &amp;&amp; b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(<span class="bu">std::</span>move(e)) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type &amp;&amp; c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(<span class="bu">std::</span>move(e)) ;
}</code></pre></div>
<h3 id="上記以外の場合">上記以外の場合</h3>
<p>上記以外の場合、構造化束縛宣言の初期化子の型Eはクラス型で、すべての非staticデータメンバーはpublicの直接のメンバーであるか、あるいは単一の曖昧ではないpublic基本クラスのメンバーである必要がある。Eに匿名unionメンバーがあってはならない。</p>
<p>以下は型Eとして適切なクラスの例である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A
{
    <span class="dt">int</span> a, b, c ;
} ;

<span class="kw">struct</span> B : A { } ;</code></pre></div>
<p>以下は型Eとして不適切なクラスの例である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// public以外の非staticデータメンバーがある</span>
<span class="kw">struct</span> A
{
<span class="kw">public</span> :
    <span class="dt">int</span> a ;
<span class="kw">private</span> :
    <span class="dt">int</span> b ;
} ;



<span class="kw">struct</span> B
{
    <span class="dt">int</span> a ;
} ;
<span class="co">// クラスにも基本クラスにも非staticデータメンバーがある。</span>
<span class="kw">struct</span> C : B
{
    <span class="dt">int</span> b ;
} ;

<span class="co">// 匿名unionメンバーがある</span>
<span class="kw">struct</span> D
{
    <span class="kw">union</span>
    {
        <span class="dt">int</span> i ;
        <span class="dt">double</span> d ;
    }
} ;</code></pre></div>
<p>型Eの非staticデータメンバーは宣言された順番で多値として認識される。</p>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">struct</span> { <span class="dt">int</span> x, y, z ; } e{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> [a,b,c] = e ;
}</code></pre></div>
<p>以下のコードと意味的に等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">struct</span> { <span class="dt">int</span> x, y, z ; } e{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> a = e.x ;
    <span class="dt">int</span> b = e.y ;
    <span class="dt">int</span> c = e.z ;
}</code></pre></div>
<p>構造化束縛はビットフィールドに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x : <span class="dv">2</span> ;
    <span class="dt">int</span> y : <span class="dv">4</span> ;
} ;

<span class="dt">int</span> main()
{
    S e{<span class="dv">1</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b] = e ;
}</code></pre></div>
<p>機能テストマクロは__cpp_structured_bindings, 値は201606。</p>
<h2 id="inline変数">inline変数</h2>
<p>C++17では変数にinlineキーワードを指定できるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">int</span> variable ;</code></pre></div>
<p>このような変数をinline変数と呼ぶ。その意味はinline関数と同じだ。</p>
<h3 id="inlineの歴史的な意味">inlineの歴史的な意味</h3>
<p>今は昔、本書執筆から30年以上は昔に、inlineキーワードがC++に追加された。</p>
<p>inlineの現在の意味は誤解されている。</p>
<p>inline関数の意味は、「関数を強制的にインライン展開させるための機能」<strong>ではない</strong>。</p>
<p>大事なことなのでもう一度書くが、inline関数の意味は、「関数を強制的にインライン展開させるための機能」<strong>ではない</strong>。</p>
<p>確かに、かつてinline関数の意味は、関数を強制的にインライン展開させるための機能だった。</p>
<p>関数のインライン展開とは、例えば以下のようなコードがあったとき、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> min( <span class="dt">int</span> a, <span class="dt">int</span> b )
{ <span class="cf">return</span> a &lt; b ? a : b ; }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;
    <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b ;

    <span class="co">// aとbのうち小さい方を選ぶ</span>
    <span class="dt">int</span> value = min( a, b ) ;
}</code></pre></div>
<p>この関数minは十分に小さく、関数呼び出しのコストは無視できないオーバーヘッドになるため、以下のような最適化が考えられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;
    <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b ;

    <span class="dt">int</span> value = a &lt; b ? a : b ;
}</code></pre></div>
<p>このように関数の中身を展開することを、関数のインライン展開という。</p>
<p>人間が関数のインライン展開を手で行うのは面倒だ。それにコードが読みにくい。&quot;min(a,b)&quot;と&quot;a&lt;b?a:b&quot;のどちらが読みやすいだろうか。</p>
<p>幸い、C++コンパイラーはインライン展開を自動的に行えるので人間が苦労する必要はない。</p>
<p>インライン展開は万能の最適化ではない。インライン展開をすると逆に遅くなる場合もある。</p>
<p>例えば、ある関数をコンパイルした結果のコードサイズが1KBあったとして、その関数を呼んでいる箇所がプログラム中に1000件ある場合、プログラム全体のサイズは1MB増える。コードサイズが増えるということは、CPUのキャッシュを圧迫する。</p>
<p>例えば、ある関数の実行時間が関数呼び出しの実行時間に比べて桁違いに長い時、関数呼び出しのコストを削減するのは意味がない。</p>
<p>したがって関数のインライン展開という最適化を適用すべきかどうかを決定するには、関数のコードサイズが十分に小さい時、関数の実行時間が十分に短い時、タイトなループの中など、様々な条件を考慮しなければならない。</p>
<p>昔のコンパイラー技術が未熟だった時代のC++コンパイラーは関数をインライン展開するべきかどうかの判断ができなかった。そのためinlineキーワードが追加された。インライン展開してほしい関数をinline関数にすることで、コンパイラーはその関数がインライン展開するべき関数だと認識する。</p>
<h3 id="現代のinlineの意味">現代のinlineの意味</h3>
<p>現代では、コンパイラー技術の発展によりC++コンパイラーは十分に賢くなったので、関数をインライン展開させる目的でinlineキーワードを使う必要はない。実際、現代のC++コンパイラーではinlineキーワードはインライン展開を強制しない。関数をインライン展開すべきかどうかはコンパイラーが判断できる。</p>
<p>inlineキーワードにはインライン展開以外に、もうひとつの意味がある。ODR(One Definition Rule、定義はひとつの原則)の回避だ。</p>
<p>C++では、定義はプログラム中にひとつしか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() ; <span class="co">// OK、宣言</span>
<span class="dt">void</span> f() ; <span class="co">// OK、再宣言</span>

<span class="dt">void</span> f() { } <span class="co">// OK、定義</span>

<span class="dt">void</span> f() { } <span class="co">// エラー、再定義</span></code></pre></div>
<p>通常は、関数を使う場合には宣言だけを書いて使う。定義はどこかひとつの翻訳単位に書いておけばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// f.h</span>

<span class="dt">void</span> f() ;

<span class="co">// f.cpp</span>

<span class="dt">void</span> f() { }

<span class="co">// main.cpp</span>

<span class="pp">#include </span><span class="im">&quot;f.h&quot;</span>

<span class="dt">int</span> main()
{
    f() ;
}</code></pre></div>
<p>しかし、関数のインライン展開をするには、コンパイラーの実装上の都合で、関数の定義が同じ翻訳単位になければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> f() ;

<span class="dt">int</span> main()
{
    <span class="co">// エラー、定義がない</span>
    f() ; 
}</code></pre></div>
<p>しかし、翻訳単位ごとに定義すると、定義が重複してODRに違反する。</p>
<p>C++ではこの問題を解決するために、inline関数は定義が同一であれば、複数の翻訳単位で定義されてもよいことにしている。つまりODRに違反しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a.cpp</span>

<span class="kw">inline</span> <span class="dt">void</span> f() { }

<span class="dt">void</span> a()
{
    f() ;
}

<span class="co">// b.cpp</span>

<span class="co">// OK、inline関数</span>
<span class="kw">inline</span> <span class="dt">void</span> f() { }

<span class="dt">void</span> b()
{
    f() ;
}</code></pre></div>
<p>これは例のために同一のinline関数を直接記述しているが、inline関数は定義を同一性を保証させるため、通常はヘッダーファイルに書いて#includeして使う。</p>
<h3 id="inline変数の意味">inline変数の意味</h3>
<p>inline変数は、ODRに違反せず変数の定義の重複を認める。同じ名前のinline変数は同じ変数を指す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">void</span> a() { ++data ; }

<span class="co">// b.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">void</span> b() { ++data ; }

<span class="co">// main.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">int</span> main()
{
    a() ;
    b() ;

    data ; <span class="co">// 2</span>
}</code></pre></div>
<p>この例で関数a, bの中の変数dataは同じ変数を指している。変数dataはstaticストレージ上に構築された変数なのでプログラムの開始時にゼロで初期化される。2回インクリメントされるので値は2となる。</p>
<p>これにより、クラスの非staticデータメンバーの定義を書かなくてすむようになる。</p>
<p>C++17以前のC++では、以下のように書かなければならなかったが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>

<span class="kw">struct</span> S
{
    <span class="at">static</span> <span class="dt">int</span> data ;
} ;

<span class="co">// S.cpp</span>

<span class="dt">int</span> S::data ;</code></pre></div>
<p>C++17では、以下のように書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>

<span class="kw">struct</span> S
{
    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> data ;
} ;</code></pre></div>
<p>S.cppに変数S::dataの定義を書く必要はない。</p>
<p>機能テストマクロは__cpp_inline_variables, 値は201606。</p>
<h2 id="可変長using宣言">可変長using宣言</h2>
<p>この機能は超上級者向けだ。</p>
<p>C++17ではusing宣言をカンマで区切ることができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x, y ;

<span class="dt">int</span> main()
{
    <span class="kw">using</span> ::x, ::y ;
}</code></pre></div>
<p>これは、C++14で</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> ::x ;
<span class="kw">using</span> ::y ;</code></pre></div>
<p>と書くのと等しい。</p>
<p>C++17では、using宣言でパック展開ができるようになった。この機能に正式な名前はついていないが、可変長using宣言(Variadic using declaration)と呼ぶのがわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">struct</span> S : Types ...
{
    <span class="kw">using</span> Types::<span class="kw">operator</span>() ... ;
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">long</span> ) { }
} ;


<span class="kw">struct</span> A
{
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">int</span> ) { }
} ;

<span class="kw">struct</span> B
{
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">double</span> ) { }
} ;

<span class="dt">int</span> main()
{
    S&lt;A, B&gt; s ;
    s(<span class="dv">0</span>) ; <span class="co">// A::operator()</span>
    s(<span class="dv">0L</span>) ; <span class="co">// S::operator()</span>
    s(<span class="fl">0.0</span>) ; <span class="co">// B::operator()</span>
}</code></pre></div>
<p>機能テストマクロは__cpp_variadic_using, 値は201611。</p>
<h2 id="std.byte">std::byte バイトを表現する型</h2>
<p>C++17では、バイトを表現する型が入った。ライブラリでもあるのだがコア言語で特別な型として扱われている。</p>
<p>バイトとはC++のメモリモデルにおけるストレージの単位で、C++においてユニークなアドレスが付与される最小単位だ。C++の規格は未だに1バイトが具体的に何ビットであるのかを規定していない。これは過去にバイトのサイズが8ビットではないアーキテクチャが存在したためだ。</p>
<p>バイトのビット数は&lt;climits&gt;で定義されているプリプロセッサーマクロ、CHAR_BITで知ることができる。</p>
<p>C++17では、1バイトはUTF-8の8ビットの1コード単位をすべて表現できると規定している。</p>
<p>std::byte型は、生のバイト列を表すための型として使うことができる。生の1バイトを表すにはunsigned char型が慣習的に使われてきたが、std::byte型は生の1バイトを表現する型として、新たにC++17で追加された。複数バイトが連続するストレージは、unsigned charの配列型、もしくはstd::byteの配列型として表現できる。</p>
<p>std::byte型は、&lt;cstddef&gt;で以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std
{
    <span class="kw">enum</span> <span class="kw">class</span> byte : <span class="dt">unsigned</span> <span class="dt">char</span> { } ;
}</code></pre></div>
<p>std::byteはライブラリとしてscoped enum型で定義されている。これにより、他の整数型からの暗黙の型変換が行えない。</p>
<p>値0x12のstd::byte型の変数は以下のように定義できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{<span class="bn">0x12</span>} ;
}</code></pre></div>
<p>std::byte型の値が欲しい場合は、以下のように書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{} ;

    b = <span class="bu">std::</span>byte( <span class="dv">1</span> ) ;
    b = <span class="bu">std::</span>byte{ <span class="dv">1</span> } ;
    b = <span class="kw">static_cast</span>&lt; <span class="bu">std::</span>byte &gt;( <span class="dv">1</span> ) ;
    b = <span class="kw">static_cast</span>&lt; <span class="bu">std::</span>byte &gt;( <span class="bn">0b11110000</span> ) ; <span class="co">// アルファベットの&#39;l&#39;</span>
}</code></pre></div>
<p>std::byte型は他の数値型からは暗黙に型変換できない。これによりうっかりと型を取り違えてバイト型と他の型を演算してしまうことを防ぐことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、()による初期化はint型からの暗黙の変換が入る</span>
    <span class="bu">std::</span>byte b1(<span class="dv">1</span>) ;

    <span class="co">// エラー、=による初期化はint型からの暗黙の変換が入る</span>
    <span class="bu">std::</span>byte b2 = <span class="dv">1</span> ;

    <span class="bu">std::</span>byte b{} ;

    <span class="co">// エラー、operator =によるint型の代入は暗黙の変換が入る</span>
    b = <span class="dv">1</span> ;
    <span class="co">// エラー、operator =によるdouble型の代入は暗黙の変換が入る</span>
    b = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>std::byte型は{}によって初期化するが、縮小変換を禁止するルールにより、std::byte型が表現できる値の範囲でなければエラーとなる。</p>
<p>例えば、今std::byteが8ビットで、最小値が0、最大値が255の環境だとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、表現できる値の範囲ではない</span>
    <span class="bu">std::</span>byte b1{<span class="dv">-1</span>} ;
    <span class="co">// エラー、表現できる値の範囲ではない</span>
    <span class="bu">std::</span>byte b2{<span class="dv">256</span>} ;
}</code></pre></div>
<p>std::byteは内部のストレージをバイト単位でアクセスできるようにするため、規格上charと同じ様な配慮が行われている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">42</span> ;

    <span class="bu">std::</span>byte * rep = <span class="kw">reinterpret_cast</span>&lt; <span class="bu">std::</span>byte * &gt;(&amp;x) ;
}</code></pre></div>
<p>std::byteは一部の演算子がオーバーロードされているので、通常の整数型のように使うことができる。ただし、バイトをビット列演算するのに使う一部の演算子だけだ。</p>
<p>具体的には、以下に示すシフト、ビットOR、ビット列AND、ビット列XOR、ビット列NOTだ。</p>
<pre><code>&lt;&lt;= &lt;&lt; 
&gt;&gt;= &gt;&gt;
|=  |
&amp;=  &amp;
^=  ^
~</code></pre>
<p>四則演算などの演算子はサポートしていない。</p>
<p>std::byteはstd::to_intenger&lt;IntType&gt;(std::byte)により、IntType型の整数型に変換できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{<span class="dv">42</span>} ;

    <span class="co">// int型の値は42</span>
    <span class="kw">auto</span> i = <span class="bu">std::</span>to_integer&lt;<span class="dt">int</span>&gt;(b) ;
}</code></pre></div>
<h1 id="c17の型安全な値を格納するライブラリ">C++17の型安全な値を格納するライブラリ</h1>
<p>C++17では型安全に値を格納するライブラリとして、variant, any, optionalが追加された。</p>
<h2 id="variant-型安全なunion">variant : 型安全なunion</h2>
<h3 id="使い方">使い方</h3>
<p>ヘッダーファイル&lt;variant&gt;で定義されているvariantは、型安全なunionとして使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;variant&gt;</span>

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// int, double, std::stringのいずれかを格納するvariant</span>
    <span class="co">// コンストラクターは最初の型をデフォルト構築</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; x ;

    x = <span class="dv">0</span> ;         <span class="co">// intを代入</span>
    x = <span class="fl">0.0</span> ;       <span class="co">// doubleを代入</span>
    x = <span class="st">&quot;hello&quot;</span>s ;  <span class="co">// std::stringを代入</span>

    <span class="co">// intが入っているか確認</span>
    <span class="co">// falseを返す</span>
    <span class="dt">bool</span> has_int = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">int</span>&gt;( x ) ;
    <span class="co">// std::stringが入っているか確認</span>
    <span class="co">// trueを返す</span>
    <span class="dt">bool</span> has_string = <span class="bu">std::</span>holds_alternative&lt;<span class="bu">std::</span>string&gt; ( x ) ;

    <span class="co">// 入っている値を得る</span>
    <span class="co">// &quot;hello&quot;</span>
    <span class="bu">std::</span>string str = <span class="bu">std::</span>get&lt;<span class="bu">std::</span>string&gt;(x) ;
}</code></pre></div>
<h3 id="型非安全な古典的union">型非安全な古典的union</h3>
<p>C++が従来から持っている古典的なunionは、複数の型のいずれかひとつだけの値を格納する型だ。unionのサイズはデータメンバーのいずれかの型をひとつ表現できるだけのサイズとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">union</span> U
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;
} ;

<span class="kw">struct</span> S
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;
}</code></pre></div>
<p>この場合、sizeof(U)は</p>
<p><span class="math display">\[\text{sizeof(U)} = \max \{ \text{sizeof(int)}, \text{sizeof(double)}, \text{sizeof(std::string)} \} + \text{パディングなど}\]</span></p>
<p>になる。sizeof(S)は、</p>
<p><span class="math display">\[\text{sizeof(S)} = \text{sizeof(int)} + \text{sizeof(double)} + \text{sizeof(std::string)} + \text{パディングなど}\]</span></p>
<p>になる。</p>
<p>unionはメモリ効率がよい。unionはvariantと違い型非安全だ。どの型の値を保持しているかという情報は保持しないので、利用者が適切に管理しなければならない。</p>
<p>試しに、冒頭のコードをunionで書くと、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">union</span> U
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;

    <span class="co">// コンストラクター</span>
    <span class="co">// int型をデフォルト初期化する</span>
    U() : i{} { }
    <span class="co">// デストラクター</span>
    <span class="co">// 何もしない。オブジェクトの破棄は利用者の責任に任せる</span>
    ~U() { }
} ;

<span class="co">// デストラクター呼び出し</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> destruct ( T &amp; x )
{
    x.~T() ;
}

<span class="dt">int</span> main()
{
    U u ;

    <span class="co">// 基本型はそのまま代入できる</span>
    <span class="co">// 破棄も考えなくて良い</span>
    u.i = <span class="dv">0</span> ;
    u.d = <span class="fl">0.0</span> ;

    <span class="co">// 非トリビアルなコンストラクターを持つ型</span>
    <span class="co">// placement newが必要</span>
    <span class="kw">new</span>(&amp;u.s) <span class="bu">std::</span>string(<span class="st">&quot;hello&quot;</span>) ;

    <span class="co">// 利用者はどの型を入れたか別に管理しておく必要がある</span>
    <span class="dt">bool</span> has_int = <span class="kw">false</span> ;
    <span class="dt">bool</span> has_string = <span class="kw">true</span> ;

    <span class="bu">std::</span>cout &lt;&lt; u.s &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

    <span class="co">// 非トリビアルなデストラクターを持つ型</span>
    <span class="co">// 破棄が必要</span>
    destruct( u.s ) ;
}</code></pre></div>
<p>このようなコードは書きたくない。variantを使えば、このような面倒で冗長なコードを書かずに、型安全にunionと同等機能を実現できる。</p>
<h3 id="variantの宣言">variantの宣言</h3>
<p>variantはテンプレート実引数で保持したい型を与える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>, <span class="dt">long</span> &gt; v1 ;
<span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v2 ;
<span class="bu">std::</span>variant&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;. <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; &gt; v3 ;</code></pre></div>
<h3 id="variantの初期化">variantの初期化</h3>
<h4 id="デフォルト初期化">デフォルト初期化</h4>
<p>variantはデフォルト構築すると、最初に与えた型の値をデフォルト構築して保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v1 ;
<span class="co">// double</span>
<span class="bu">std::</span>variant&lt; <span class="dt">double</span>, <span class="dt">int</span> &gt; v2 ;</code></pre></div>
<p>variantにデフォルト構築できない型を最初に与えると、variantもデフォルト構築できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// デフォルト構築できない型</span>
<span class="kw">struct</span> non_default_constructible
{
    non_default_constructible() = <span class="kw">delete</span> ;
} ;

<span class="co">// エラー</span>
<span class="co">// デフォルト構築できない</span>
<span class="bu">std::</span>variant&lt; non_default_constructible &gt; v ;</code></pre></div>
<p>デフォルト構築できない型だけを保持するvariantをデフォルト構築するためには、最初の型をデフォルト構築可能な型にすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A { A() = <span class="kw">delete</span> ; } ;
<span class="kw">struct</span> B { B() = <span class="kw">delete</span> ; } ;
<span class="kw">struct</span> C { C() = <span class="kw">delete</span> ; } ;

<span class="kw">struct</span> Empty { } ;


<span class="dt">int</span> main()
{
    <span class="co">// OK、Emptyを保持</span>
    <span class="bu">std::</span>variant&lt; Empty, A, B, C &gt; v ;
}</code></pre></div>
<p>このような場合に、Emptyのようなクラスをわざわざ独自に定義するのは面倒なので、標準ライブラリにはstd::monostateクラスが以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">struct</span> monostate { } ;
}</code></pre></div>
<p>したがって、上の例は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK、std::monostateを保持</span>
<span class="bu">std::</span>variant&lt; <span class="bu">std::</span>monostate, A, B, C &gt; v ;</code></pre></div>
<p>std::monostateはvariantの最初のテンプレート実引数として使うことでvariantをデフォルト構築可能にするための型だ。それ以上の意味はない。</p>
<h4 id="コピー初期化">コピー初期化</h4>
<p>variantに同じ型のvariantを渡すと、コピー/ムーブする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// コピー</span>
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; b ( a ) ;
}</code></pre></div>
<h4 id="variantのコンストラクターに値を渡した場合">variantのコンストラクターに値を渡した場合</h4>
<p>variantのコンストラクターに上記以外の値を渡した場合、variantのテンプレート実引数に指定した型の中から、オーバーロード解決により最適な型が選ばれ、その型の値に変換され、値を保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> val = <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; ;

<span class="dt">int</span> main()
{
    <span class="co">// int</span>
    val a(<span class="dv">42</span>) ;
    <span class="co">// double</span>
    val b( <span class="fl">0.0</span> ) ; 

    <span class="co">// std::string</span>
    <span class="co">// char const *型はstd::string型に変換される。</span>
    val c(<span class="st">&quot;hello&quot;</span>) ;

    <span class="co">// int</span>
    <span class="co">// char型はIntegral promotionによりint型に優先的に変換される</span>
    val d( <span class="st">&#39;a&#39;</span> ) ;
}</code></pre></div>
<h4 id="in_place_typeによるemplace構築">in_place_typeによるemplace構築</h4>
<p>variantのコンストラクターの第一引数にstd::in_place_type&lt;T&gt;を渡すことにより、T型の要素を構築するためにT型のコンストラクターに渡す実引数を指定できる。</p>
<p>ほとんどの型はコピーかムーブができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xを構築</span>
    X x( a, b, c ) ;
    <span class="co">// xをコピー</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( x ) ;
}</code></pre></div>
<p>しかし、もし型Xがコピーもムーブもできない型だったとしたら、上記のコードは動かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xを構築</span>
    X x( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// エラー、Xはコピーできない</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( x ) ;
}</code></pre></div>
<p>このような場合、variantが内部でXを構築する際に、構築に必要なコンストラクターの実引数を渡して、variantにXを構築させる必要がある。そのためにstd::in_place_type&lt;T&gt;が使える。Tに構築したい型を指定して第一引数とし、第二引数以降をTのコンストラクターに渡す値にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xの値を構築して保持</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
}</code></pre></div>
<h3 id="variantの破棄">variantの破棄</h3>
<p>variantのデストラクターは、そのときに保持している値を適切に破棄してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; l ;
    <span class="bu">std::</span>deque&lt;<span class="dt">int</span>&gt; d ;
    <span class="bu">std::</span>variant&lt; 
        <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;, 
        <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt;,
        <span class="bu">std::</span>deque&lt;<span class="dt">int</span>&gt;
    &gt; val ;

    val = v ;
    val = l ;
    val = d ;

    <span class="co">// variantのデストラクターはdeque&lt;int&gt;を破棄する</span>
}</code></pre></div>
<p>variantのユーザーは何もする必要がない。</p>
<h3 id="variantの代入">variantの代入</h3>
<p>variantの代入はとても自然だ。variantを渡せばコピーするし、値を渡せばオーバーロード解決に従って適切な型の値を保持する。</p>
<h3 id="variantのemplace">variantのemplace</h3>
<p>variantはemplaceをサポートしている。variantの場合、構築すべき型を知らせる必要があるので、emplace&lt;T&gt;のTで構築すべき型を指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="bu">std::</span>monostate, X, <span class="bu">std::</span>string&gt; v ;

    <span class="co">// Xを構築</span>
    v.emplace&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// std::stringを構築</span>
    v.emplace&lt; <span class="bu">std::</span>string &gt;( <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<h3 id="variantに値が入っているかどうかの確認">variantに値が入っているかどうかの確認</h3>
<h4 id="valueless_by_exceptionメンバー関数">valueless_by_exceptionメンバー関数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">bool</span> valueless_by_exception() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>valueless_by_exceptionメンバー関数は、variantが値を保持している場合、falseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; &amp; v )
{

    <span class="cf">if</span> ( v.valueless_by_exception() ) 
    { <span class="co">// true</span>
        <span class="co">// vは値を保持していない</span>
    }
    <span class="cf">else</span>
    { <span class="co">// false</span>
        <span class="co">// vは値を保持している</span>
    }
}</code></pre></div>
<p>variantはどの値も保持しない状態になることがある。例えば、std::stringはコピーにあたって動的なメモリ確保を行うかもしれない。variantがstd::stringをコピーする際に、動的メモリ確保に失敗した場合、コピーは失敗する。なぜならば、variantは別の型の値を構築する前に、以前の値を破棄しなければならないからだ。variantは値を持たない状態になりうる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="bu">std::</span>string &gt; v ;
    <span class="cf">try</span> {
        <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;
        v = s ; <span class="co">// 動的メモリ確保が発生するかもしれない</span>
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_alloc e )
    {
        <span class="co">// 動的メモリ確保が失敗するかもしれない</span>
    }

    <span class="co">// 動的メモリ確保の失敗により</span>
    <span class="co">// trueになるかもしれない</span>
    <span class="dt">bool</span> b = v.valueless_by_exception() ;
}</code></pre></div>
<h4 id="indexメンバー関数">indexメンバー関数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> index() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>indexメンバー関数は、variantに指定したテンプレート実引数のうち、現在variantが保持している値の型を0ベースのインデックスで返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v ;

    <span class="kw">auto</span> v0 = v.index() ; <span class="co">// 0</span>
    v = <span class="fl">0.0</span> ;
    <span class="kw">auto</span> v1 = v.index() ; <span class="co">// 1</span>
    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="kw">auto</span> v2 = v.index() ; <span class="co">// 2</span>
}</code></pre></div>
<p>もしvariantが値を保持しない場合、つまりvalueless_by_exception()がtrueを返す場合は、std::variant_nposを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// variantが値を持っているかどうか確認する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types  &gt;
<span class="dt">void</span> has_value( <span class="bu">std::</span>variant&lt; Types ... &gt; &amp;&amp; v )
{
    <span class="cf">return</span> v.index() != <span class="bu">std::</span>variant_npos ;

    <span class="co">// これでもいい</span>
    <span class="co">// return v.valueless_by_exception() == false ;</span>
}</code></pre></div>
<p>std::variant_nposの値は-1だ。</p>
<h3 id="swap">swap</h3>
<p>variantはswapに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a, b ;

    a.swap(b) ;
    <span class="bu">std::</span>swap( a, b ) ;
}</code></pre></div>
<h3 id="variant_sizet-variantが保持できる型の数を取得">variant_size&lt;T&gt; : variantが保持できる型の数を取得</h3>
<p>std::variant_size&lt;T&gt;は、Tにvariant型を渡すと、variantが保持できる型の数を返してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> t1 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>&gt; ;
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>&gt; ;
<span class="kw">using</span> t3 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="co">// 1</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t1_size = <span class="bu">std::</span>variant_size&lt;t1&gt;::size ;
<span class="co">// 2</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t2_size = <span class="bu">std::</span>variant_size&lt;t2&gt;::size ;
<span class="co">// 3</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t2_size = <span class="bu">std::</span>variant_size&lt;t3&gt;::size ;</code></pre></div>
<p>variant_sizeはintegral_constantを基本クラスに持つクラスなので、デフォルト構築した結果をユーザー定義変換することでも値を取り出せる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="kw">constexpr</span> <span class="bu">std::</span>size_t size = <span class="bu">std::</span>variant_size&lt;type&gt;{} ;</code></pre></div>
<p>variant_sizeを以下のようにラップした変数テンプレートも用意されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> variant_size_v = variant_size&lt;T&gt;::value;</code></pre></div>
<p>これを使えば、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="kw">constexpr</span> <span class="bu">std::</span>size_t size = <span class="bu">std::</span>variant_size_v&lt;type&gt; ;</code></pre></div>
<h3 id="variant_alternativei-t-インデックスから型を返す">variant_alternative&lt;I, T&gt; : インデックスから型を返す</h3>
<p>std::variant_alternative&lt;I, T&gt;はT型のvariantの保持できる型のうち、I番目の型をネストされた型名typeで返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span> &gt; ;

<span class="co">// char</span>
<span class="kw">using</span> t0 = <span class="bu">std::</span>variant_alternative&lt; <span class="dv">0</span>, type &gt;::type ;
<span class="co">// short</span>
<span class="kw">using</span> t1 = <span class="bu">std::</span>variant_alternative&lt; <span class="dv">1</span>, type &gt;::type ;
<span class="co">// int</span>
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant_alternative&lt; <span class="dv">2</span>, type &gt;::type ;</code></pre></div>
<p>variant_alternative_tというテンプレートエイリアスが以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="kw">class</span> T&gt;
    <span class="kw">using</span> <span class="dt">variant_alternative_t</span> 
        = <span class="kw">typename</span> variant_alternative&lt;I, T&gt;::type ;</code></pre></div>
<p>これをつかえば、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span> &gt; ;

<span class="co">// char</span>
<span class="kw">using</span> t0 = <span class="bu">std::</span>variant_alternative_t&lt; <span class="dv">0</span>, type &gt; ;
<span class="co">// short</span>
<span class="kw">using</span> t1 = <span class="bu">std::</span>variant_alternative_t&lt; <span class="dv">1</span>, type &gt; ;
<span class="co">// int</span>
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant_alternative_t&lt; <span class="dv">2</span>, type &gt; ;</code></pre></div>
<h3 id="holds_alternative-variantが指定した型の値を保持しているかどうかの確認">holds_alternative : variantが指定した型の値を保持しているかどうかの確認</h3>
<p>holds_alternative&lt;T&gt;(v)は、variant vがT型の値を保持しているかどうかを確認する。保持しているのであればtrueを、そうでなければfalseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を構築</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v ;

    <span class="co">// true</span>
    <span class="dt">bool</span> has_int = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">int</span>&gt;(v) ;
    <span class="co">// false</span>
    <span class="dt">bool</span> has_double = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">double</span>&gt;(v) ;
}</code></pre></div>
<p>型Tは実引数に与えられたvariantが保持できる型でなければならない。以下のようなコードはエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; v ;

    <span class="co">// エラー</span>
    <span class="bu">std::</span>holds_alternative&lt;<span class="dt">double</span>&gt;(v) ;
}</code></pre></div>
<h3 id="getiv-インデックスから値の取得">get&lt;I&gt;(v) : インデックスから値の取得</h3>
<p>get&lt;I&gt;(v)は、variant vの型のインデックスからI番目の型の値を返す。インデックスは0ベースだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 0: int</span>
    <span class="co">// 1: double</span>
    <span class="co">// 2: std::string</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v(<span class="dv">42</span>) ;

    <span class="co">// int, 42</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(v) ;

    v = <span class="fl">3.14</span> ;
    <span class="co">// double, 3.14</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(v) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string, &quot;hello&quot;</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(v) ;
}</code></pre></div>
<p>Iがインデックスの範囲を超えているとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// インデックスは0, 1, 2まで</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v ;

    <span class="co">// エラー、範囲外</span>
    <span class="bu">std::</span>get&lt;<span class="dv">3</span>&gt;(v) ;
}</code></pre></div>
<p>もし、variantが値を保持していない場合、つまりv.index() != Iの場合は、std::bad_variant_accessがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v( <span class="dv">42</span> ) ;

    <span class="cf">try</span> {
        <span class="co">// double型の値を要求</span>
        <span class="kw">auto</span> d = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(v) ;
    } <span class="cf">catch</span> ( <span class="bu">std::</span>bad_variant_access &amp; e )
    {
        <span class="co">// doubleは保持していなかった</span>
    }
}</code></pre></div>
<p>getの実引数に渡すvariantがlvalueの場合は、戻り値はlvalueリファレンス、rvalueの場合は戻り値はrvalueリファレンスになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; v ;

    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(v) ;
    <span class="co">// int &amp;&amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) b = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( <span class="bu">std::</span>move(v) ) ;
}</code></pre></div>
<p>getの実引数に渡すvariantがCV修飾されている場合、戻り値の型も実引数と同じくCV修飾される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">const</span> cv ;
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">volatile</span> vv ;
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">const</span> <span class="at">volatile</span> cvv ;

    <span class="co">// int const &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( cv ) ;
    <span class="co">// int volatile &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) b = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( vv ) ;
    <span class="co">// int const volatile &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) c = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( cvv ) ;
}</code></pre></div>
<h3 id="gettv-型から値の取得">get&lt;T&gt;(v) : 型から値の取得</h3>
<p>get&lt;T&gt;(v)は、variant vの保有する型Tの値を返す。型Tの値を保持していない場合、std::bad_variant_accessがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// int</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get&lt;<span class="dt">int</span>&gt;( v ) ;

    v = <span class="fl">3.14</span> ;
    <span class="co">// double</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get&lt;<span class="dt">double</span>&gt;( v ) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get&lt;<span class="bu">std::</span>string&gt;( v ) ;
}</code></pre></div>
<p>その他はすべてget&lt;I&gt;と同じ。</p>
<h3 id="get_if-値を保持している場合に取得">get_if : 値を保持している場合に取得</h3>
<p>get_if&lt;I&gt;(vp)とget_if&lt;T&gt;(vp)は、variantへのポインターvpを実引数にとり、*vpがインデックスI、もしくは型Tの値を保持している場合、その値へのポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// int *</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">int</span>&gt;( &amp;v ) ; 

    v = <span class="fl">3.14</span> ;
    <span class="co">// double *</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get_if&lt;<span class="dv">1</span>&gt;( &amp;v ) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get_if&lt;<span class="dv">2</span>&gt;( &amp;v ) ;

}</code></pre></div>
<p>もし、vpがnullptrの場合、もしくは*vpが指定された値を保持していない場合は、nullptrを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// nullptr</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">int</span>&gt;( <span class="kw">nullptr</span> ) ;

    <span class="co">// nullptr</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">double</span>&gt;( &amp;v ) ;
}</code></pre></div>
<h3 id="variantの比較">variantの比較</h3>
<p>variantは比較演算子がオーバーロードされているため比較できる。variant同士の比較は、一般のプログラマーは自然だと思う結果になるように実装されている。</p>
<h4 id="同一性の比較">同一性の比較</h4>
<p>variantの同一性の比較のためには、variantのテンプレート実引数に与える型は自分自身と比較可能でなければならない。</p>
<p>つまり、variant v, wに対して、式 get&lt;i&gt;(v) == get&lt;i&gt;(w) がすべてのiに対して妥当でなければならない。</p>
<p>variant v, wの同一性の比較は、v == w の場合、以下のように行われる。</p>
<ol style="list-style-type: decimal">
<li>v.index() != w.index()ならば、false</li>
<li>それ以外の場合、v.value_less_by_exception()ならば、true</li>
<li>それ以外の場合、get&lt;i&gt;(v) == get&lt;i&gt;(w)。ただしiはv.index()</li>
</ol>
<p>二つのvariantが別の型を保持している場合は等しくない。ともに値なしの状態であれば等しい。それ以外は保持している値同士が比較される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; a(<span class="dv">0</span>), b(<span class="dv">0</span>) ;

    <span class="co">// true</span>
    <span class="co">// 同じ型の同じ値を保持している。</span>
    a == b ;

    a = <span class="fl">1.0</span> ;

    <span class="co">// false</span>
    <span class="co">// 型が違う</span>
    a == b ;
}</code></pre></div>
<p>例えばoperator ==は以下のような実装になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Types&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> 
<span class="kw">operator</span> == (<span class="at">const</span> variant&lt;Types...&gt;&amp; v, <span class="at">const</span> variant&lt;Types...&gt;&amp; w)
{
    <span class="cf">if</span> ( v.index() != w.index() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>visit( 
            []( <span class="kw">auto</span> &amp;&amp; a, <span class="kw">auto</span> &amp;&amp; b ){ <span class="cf">return</span> a == b ; },
            v, w ) ;
}</code></pre></div>
<p>operator !=はこの逆だと考えてよい。</p>
<h4 id="大小比較">大小比較</h4>
<p>variantの大小の比較のためには、variantのテンプレート実引数に与える型は自分自身と比較可能でなければならない。</p>
<p>つまり、operator &lt; の場合、variant v, wに対して、式 get&lt;i&gt;(v) &lt; get&lt;i&gt;(w) がすべてのiに対して妥当でなければならない。</p>
<p>variant v, wの大小比較は、v &lt; w の場合、以下のように行われる。</p>
<ol style="list-style-type: decimal">
<li>w.valueless_by_exception()ならば、false</li>
<li>それ以外の場合、v.valueless_by_exception()ならば、true</li>
<li>それ以外の場合、v.index() &lt; w.index()ならば、true</li>
<li>それ以外の場合、v.index() &gt; w.index()ならば、false</li>
<li>それ以外の場合、get&lt;i&gt;(v) &lt; get&lt;i&gt;(w)。ただしiはv.index()</li>
</ol>
<p>値なしのvariantは最も小さいとみなされる。インデックスの小さいほうが小さいとみなされる。どちらも同じ型の値があるのであれば、値同士の比較となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; a(<span class="dv">0</span>), b(<span class="dv">0</span>) ;

    <span class="co">// false</span>
    <span class="co">// 同じ型の同じ値を比較</span>
    a &lt; b ;

    a = <span class="fl">1.0</span> ;

    <span class="co">// false</span>
    <span class="co">// インデックスによる比較</span>
    a &lt; b ;
    <span class="co">// true</span>
    <span class="co">// インデックスによる比較</span>
    b &lt; a ;
}</code></pre></div>
<p>operator &lt;は以下のような実装になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Types&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> 
<span class="kw">operator</span>&lt;(<span class="at">const</span> variant&lt;Types...&gt;&amp; v, <span class="at">const</span> variant&lt;Types...&gt;&amp; w)
{
    <span class="cf">if</span> ( w.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.index() &lt; w.index() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.index() &gt; w.index() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>visit( 
            []( <span class="kw">auto</span> &amp;&amp; a, <span class="kw">auto</span> &amp;&amp; b ){ <span class="cf">return</span> a &lt; b ; },
            v, w ) ;
}</code></pre></div>
<p>残りの大小比較も同じ方法で比較される。</p>
<h3 id="visit-variantが保持している値を受け取る">visit : variantが保持している値を受け取る。</h3>
<p>std::visitは、variantの保持している型を実引数に関数オブジェクトを呼んでくれるライブラリだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> val = <span class="bu">std::</span>variant&lt;<span class="dt">int</span>, <span class="dt">double</span>&gt; ;

    val v(<span class="dv">42</span>) ;
    val w(<span class="fl">3.14</span>) ;

    <span class="kw">auto</span> visitor =  []( <span class="kw">auto</span> a, <span class="kw">auto</span> b ) 
                    { <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ; } ;

    <span class="co">// visitor( 42, 3.14 )が呼ばれる</span>
    <span class="bu">std::</span>visit( visitor, v, w ) ;
    <span class="co">// visitor( 3.14, 42 ) が呼ばれる</span>
    <span class="bu">std::</span>visit( visitor, w, v ) ;
}</code></pre></div>
<p>このように、variantにどの型の値が保持されていても扱うことができる。</p>
<p>std::visitは以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">class</span> Visitor, <span class="kw">class</span>... Variants &gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> visit( Visitor&amp;&amp; vis, Variants&amp;&amp;... vars ) ;</code></pre></div>
<p>第一引数に関数オブジェクトを渡し、第二引数以降にvariantを渡す。すると、vis( get&lt;i&gt;(vars)... )のように呼ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a(<span class="dv">1</span>), b(<span class="dv">2</span>), c(<span class="dv">3</span>) ;

    <span class="co">// ( 1 ) </span>
    <span class="bu">std::</span>visit( []( <span class="kw">auto</span> x ) {}, a ) ;

    <span class="co">// ( 1, 2, 3 )</span>
    <span class="bu">std::</span>visit( []( <span class="kw">auto</span> x, <span class="kw">auto</span> y, <span class="kw">auto</span> z ) {}, a, b, c ) ;
}</code></pre></div>
<h2 id="any-どんな型の値でも保持できるクラス">any : どんな型の値でも保持できるクラス</h2>
<h3 id="使い方-1">使い方</h3>
<p>ヘッダーファイル&lt;any&gt;で定義されているstd::anyは、ほとんどどんな型の値でも保持できるクラスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;any&gt;</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    a = <span class="dv">0</span> ; <span class="co">// int</span>
    a = <span class="fl">1.0</span> ; <span class="co">// double</span>
    a = <span class="st">&quot;hello&quot;</span> ; <span class="co">// char const *</span>

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    a = v ; <span class="co">// std::vector&lt;int&gt;</span>

    <span class="co">// 保持しているstd::vector&lt;int&gt;のコピー</span>
    <span class="kw">auto</span> value = <span class="bu">std::</span>any_cast&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &gt;( a ) ;
}</code></pre></div>
<p>anyが保持できない型は、コピー構築できない型だ。</p>
<h3 id="anyの構築と破棄">anyの構築と破棄</h3>
<p>クラスanyはテンプレートではない。そのため宣言は単純だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>any a ;
    <span class="co">// int型の値を保持する</span>
    <span class="bu">std::</span>any b( <span class="dv">0</span> ) ;
    <span class="co">// double型の値を保持する</span>
    <span class="bu">std::</span>any c( <span class="fl">0.0</span> ) ;
}</code></pre></div>
<p>anyが保持する型を事前に指定する必要はない。</p>
<p>クラスanyを破棄すると、その時保持していた値が適切に破棄される。</p>
<h3 id="in_place_typeコンストラクター">in_place_typeコンストラクター</h3>
<p>anyのコンストラクターでemplaceをするためにin_place_typeが使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// 型XをX(1, 2)で構築した結果の値を保持する</span>
    <span class="bu">std::</span>any a( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h3 id="anyへの代入">anyへの代入</h3>
<p>anyへの代入も普通のプログラマーの期待通りの動きをする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;
    <span class="bu">std::</span>any b ;

    <span class="co">// aはint型の値42を保持する。</span>
    a = <span class="dv">42</span> ;
    <span class="co">// bはint型の値42を保持する</span>
    b = a ;
    
}</code></pre></div>
<h3 id="anyのメンバー関数">anyのメンバー関数</h3>
<h4 id="emplace">emplace</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span>... Args&gt;
<span class="dt">decay_t</span>&lt;T&gt;&amp; emplace(Args&amp;&amp;... args);</code></pre></div>
<p>anyはemplaceメンバー関数をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// 型XをX(1, 2)で構築した結果の値を保持する</span>
    a.emplace&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h4 id="reset-値の破棄">reset : 値の破棄</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reset() <span class="kw">noexcept</span> ; </code></pre></div>
<p>anyのresetメンバー関数は、anyの保持してある値を破棄する。resetを呼び出した後のanyは値を保持しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// aは値を保持しない</span>
    <span class="bu">std::</span>any a ;
    <span class="co">// aはint型の値を保持する</span>
    a = <span class="dv">0</span> ;

    <span class="co">// aは値を保持しない</span>
    a.reset() ;
}</code></pre></div>
<h4 id="swap-スワップ">swap : スワップ</h4>
<p>anyはswapメンバー関数をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">0</span>) ;
    <span class="bu">std::</span>any b(<span class="fl">0.0</span>) ;

    <span class="co">// aはint型の値を保持</span>
    <span class="co">// bはdouble型の値を保持</span>

    a.swap(b) ;

    <span class="co">// aはdouble型の値を保持</span>
    <span class="co">// bはint型の値を保持。</span>
}</code></pre></div>
<h4 id="has_value-値を保持しているかどうか調べる">has_value : 値を保持しているかどうか調べる</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> has_value() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>anyのhas_valueメンバー関数はanyが値を保持しているかどうかを調べる。値を保持しているならばtrueを、保持していないならばfalseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    a = <span class="dv">0</span> ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = a.has_value() ;

    a.reset() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b3 = a.has_value() ;
}</code></pre></div>
<h4 id="type-保持している型のtype_infoを得る">type : 保持している型のtype_infoを得る</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> type_info&amp; type() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>typeメンバー関数は、保持している型Tのtypeid(T)を返す。値を保持していない場合、typeid(void)を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// typeid(void)</span>
    <span class="kw">auto</span> &amp; t1 = a.type() ;

    a = <span class="dv">0</span> ;
    <span class="co">// typeid(int)</span>
    <span class="kw">auto</span> &amp; t2 = a.type() ;

    a = <span class="fl">0.0</span> ;
    <span class="co">// typeid(double)</span>
    <span class="kw">auto</span> &amp; t3 = a.type() ;
}</code></pre></div>
<h3 id="anyのフリー関数">anyのフリー関数</h3>
<h4 id="make_anyt-t型のanyを作る">make_any&lt;T&gt; : T型のanyを作る</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">emplate &lt;<span class="kw">class</span> T, <span class="kw">class</span>... Args&gt;
any make_any(Args&amp;&amp; ...args);

<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U, <span class="kw">class</span>... Args&gt;
any make_any(initializer_list&lt;U&gt; il, Args&amp;&amp; ...args);</code></pre></div>
<p>make_any&lt;T&gt;( args... )はT型をコンストラクター実引数args...で構築した値を保持するanyを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持するany</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>make_any&lt;<span class="dt">int</span>&gt;( <span class="dv">0</span> ) ;
    <span class="co">// double型の値を保持するany</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>make_any&lt;<span class="dt">double</span>&gt;( <span class="fl">0.0</span> ) ;

    <span class="co">// X型の値を保持するany</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>make_any&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h4 id="any_cast-保持している値の取り出し">any_cast : 保持している値の取り出し</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(<span class="at">const</span> any&amp; operand);
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(any&amp; operand);
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(any&amp;&amp; operand);</code></pre></div>
<p>any_cast&lt;T&gt;(operand)はoperandが保持している値を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">0</span>) ;

    <span class="dt">int</span> value = <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;(a) ;
}</code></pre></div>
<p>any_cast&lt;T&gt;で指定したT型が、anyが保持している型ではない場合、std::bad_any_castがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">try</span> {
        <span class="bu">std::</span>any a ;
        <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;(a) ;
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_any_cast e )
    {
        <span class="co">// 型を保持していなかった。</span>
    }

}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="at">const</span> T* any_cast(<span class="at">const</span> any* operand) <span class="kw">noexcept</span>;
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
T* any_cast(any* operand) <span class="kw">noexcept</span>;</code></pre></div>
<p>any_cast&lt;T&gt;にanyへのポインターを渡すと、Tへのポインター型が返される。anyがT型を保持している場合はT型を参照するポインターが返る。保持していない場合は、nullptrが返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">42</span>) ;

    <span class="co">// int型の値を参照するポインター</span>
    <span class="dt">int</span> * p1 = <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;( &amp;a ) ;

    <span class="co">// nullptr</span>
    <span class="dt">double</span> * p2 = <span class="bu">std::</span>any_cast&lt;<span class="dt">double</span>&gt;( &amp;a ) ;
}</code></pre></div>
<h2 id="optional-値を保有しているかしていないクラス">optional : 値を保有しているか、していないクラス</h2>
<h3 id="使い方-2">使い方</h3>
<p>ヘッダーファイル&lt;optional&gt;で定義されているoptional&lt;T&gt;は、T型の値を保有しているか、保有していないライブラリだ。</p>
<p>条件次第で値が用意できない場合が存在する。例えば割り算の結果の値を返す関数を考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> divide( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
    <span class="cf">if</span> ( b == <span class="dv">0</span> )
    {
        <span class="co">// エラー処理</span>
    }
    <span class="cf">else</span>
        <span class="cf">return</span> a / b ;
}</code></pre></div>
<p>ゼロで除算はできないので、bの値が0の場合、この関数は値を用意することができない。問題は、int型のすべての値は通常の除算結果として使われるので、エラーであることを示す特別な値を返すこともできない。</p>
<p>このような場合にエラーや値を通知する方法として、過去に様々な方法が考案された。例えば、ポインターやリファレンスを実引数として受け取る方法、グローバル変数を使う方法、例外だ。</p>
<p>optionalはこのような値が用意できない場合に使える共通の方法を提供する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; divide( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
    <span class="cf">if</span> ( b == <span class="dv">0</span> )
        <span class="cf">return</span> {} ;
    <span class="cf">else</span>
        <span class="cf">return</span> { a / b } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> result = divide( <span class="dv">10</span>, <span class="dv">2</span> ) ;
    <span class="co">// 値の取得</span>
    <span class="kw">auto</span> value = result.value() ;

    <span class="co">// ゼロ除算</span>
    <span class="kw">auto</span> fail = divide( <span class="dv">10</span>, <span class="dv">0</span> ) ;

    <span class="co">// false、値を保持していない</span>
    <span class="dt">bool</span> has_value = fail.has_value() ;

    <span class="co">// throw bad_optional_access</span>
    <span class="kw">auto</span> get_value_anyway = fail.value() ;
}</code></pre></div>
<h3 id="optionalのテンプレート実引数">optionalのテンプレート実引数</h3>
<p>optional&lt;T&gt;はT型の値を保持するか、もしくは保持しない状態を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持するかしないoptional</span>
    <span class="kw">using</span> a = <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; ;
    <span class="co">// double型の値を保持するかしないoptional</span>
    <span class="kw">using</span> b = <span class="bu">std::</span>optional&lt;<span class="dt">double</span>&gt; ;
}</code></pre></div>
<h3 id="optionalの構築">optionalの構築</h3>
<p>optionalをデフォルト構築すると、値を保持しないoptionalになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a ;
}</code></pre></div>
<p>コンストラクターの実引数にstd::nulloptを渡すと、値を保持しないoptionalになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="bu">std::</span>nullopt ) ;
}</code></pre></div>
<p>optional&lt;T&gt;のコンストラクターの実引数にT型に変換できる型を渡すと、T型の値に型変換して保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">42</span>) ;

    <span class="co">// double型の値1.0を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">double</span>&gt; b( <span class="fl">1.0</span> ) ;

    <span class="co">// intからdoubleへの型変換が行われる</span>
    <span class="co">// int型の値1を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; c ( <span class="fl">1.0</span> ) ;
}</code></pre></div>
<p>T型からU型に型変換できるとき、optional&lt;T&gt;のコンストラクターにoptional&lt;U&gt;を渡すとUからTに型変換されてT型の値を保持するoptionalになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// long型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">long</span>&gt; b ( a ) ;
}</code></pre></div>
<p>optionalのコンストラクターの第一引数にstd::in_place_type&lt;T&gt;を渡すと、後続の引数を使ってT型のオブジェクトがemplace構築される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// X(1, 2)</span>
    <span class="bu">std::</span>optional&lt;X&gt; o( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h3 id="optionalの代入">optionalの代入</h3>
<p>通常のプログラマーの期待通りの挙動をする。std::nulloptを代入すると値を保持しないoptionalになる。</p>
<h3 id="optionalの破棄">optionalの破棄</h3>
<p>optionalが破棄されるとき、保持している値があれば、適切に破棄される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X() { }
} ;

<span class="dt">int</span> main()
{
    {
        <span class="co">// 値を保持する</span>
        <span class="bu">std::</span>optional&lt;X&gt; o ( X{} ) ;
        <span class="co">// Xのデストラクターが呼ばれる。</span>
    }

    {
        <span class="co">// 値を保持しない</span>
        <span class="bu">std::</span>optional&lt;X&gt; o ;
        <span class="co">// Xのデストラクターは呼ばれない。</span>
    }   
}</code></pre></div>
<h3 id="swap-1">swap</h3>
<p>optionalはswapに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">1</span>), b(<span class="dv">2</span>) ;

    a.swap(b) ;
}</code></pre></div>
<h3 id="has_value-値を保持しているかどうか確認する">has_value : 値を保持しているかどうか確認する</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">bool</span> has_value() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>has_valueメンバー関数はoptionalが値を保持している場合、trueを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b(<span class="dv">42</span>) ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = b.has_value() ;
}</code></pre></div>
<h3 id="operator-bool-値を保持しているかどうか確認する">operator bool : 値を保持しているかどうか確認する</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>optionalを文脈上boolに変換すると、値を保持している場合にのみtrueとして評価される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">bool</span>&gt; a = some_function();
    <span class="co">// OK、文脈上boolに変換</span>
    <span class="cf">if</span> ( a )
    {
        <span class="co">// 値を保持</span>
    }
    <span class="cf">else</span>
    {
        <span class="co">// 値を不保持</span>
    }

    <span class="co">// エラー、暗黙の型変換は行われない</span>
    <span class="dt">bool</span> b1 = a ;
    <span class="co">// OK、明示的な型変換</span>
    <span class="dt">bool</span> b2 = <span class="kw">static_cast</span>&lt;<span class="dt">bool</span>&gt;(a) ;
}</code></pre></div>
<h3 id="value-保持している値を取得">value : 保持している値を取得</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="at">const</span> T&amp; value() <span class="at">const</span>&amp;;
<span class="kw">constexpr</span> T&amp; value() &amp;;
<span class="kw">constexpr</span> T&amp;&amp; value() &amp;&amp;;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;&amp; value() <span class="at">const</span>&amp;&amp;;</code></pre></div>
<p>valueメンバー関数はoptionalが値を保持している場合、値へのリファレンスを返す。値を保持していない場合、std::bad_optional_accessがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">42</span>) ;

    <span class="co">// OK</span>
    <span class="dt">int</span> x = a.value () ;

    <span class="cf">try</span> {
        <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b ;
        <span class="dt">int</span> y = b.value() ;
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_optional_access e )
    {
        <span class="co">// 値を保持していなかった</span>
    }
}</code></pre></div>
<h3 id="value_or-値もしくはデフォルト値を返す">value_or : 値もしくはデフォルト値を返す</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> T value_or(U&amp;&amp; v) <span class="at">const</span>&amp;;
<span class="kw">template</span> &lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> T value_or(U&amp;&amp; v) &amp;&amp;;</code></pre></div>
<p>value_or(v)メンバー関数は、optionalが値を保持している場合はその値を、保持していない場合はvを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// 42</span>
    <span class="dt">int</span> x = a.value_or(<span class="dv">0</span>) ;

    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b ;

    <span class="co">// 0</span>
    <span class="dt">int</span> x = b.value_or(<span class="dv">0</span>) ;
}</code></pre></div>
<h3 id="reset-保持している値を破棄する">reset : 保持している値を破棄する</h3>
<p>resetメンバー関数を呼び出すと、保持している値がある場合破棄する。resetメンバー関数を呼び出した後のoptionalは値を保持しない状態になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    a.reset() ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = a.has_value() ;
}</code></pre></div>
<h3 id="optional同士の比較">optional同士の比較</h3>
<p>optional&lt;T&gt;を比較するためには、T型のオブジェクト同士が比較できる必要がある。</p>
<h4 id="同一性の比較-1">同一性の比較</h4>
<p>値を保持しない二つのoptionalは等しい。片方のみが値を保持しているoptionalは等しくない。両方とも値を保持しているoptionalは値による比較になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a, b ;

    <span class="co">// true</span>
    <span class="co">// どちらも値を保持しないoptional</span>
    <span class="dt">bool</span> b1 = a == b ;

    a = <span class="dv">0</span> ;

    <span class="co">// false</span>
    <span class="co">// aのみ値を保持</span>
    <span class="dt">bool</span> b2 = a == b ;

    b = <span class="dv">1</span> ;

    <span class="co">// false</span>
    <span class="co">// どちらも値を保持。値による比較</span>
    <span class="dt">bool</span> b3 = a == b ;
}</code></pre></div>
<h4 id="大小比較-1">大小比較</h4>
<p>optional同士の大小比較は、a &lt; bの場合</p>
<ol style="list-style-type: decimal">
<li>bが値を保持していなければfalse</li>
<li>それ以外の場合で、aが値を保持していなければtrue</li>
<li>それ以外の場合、aとbの保持している値同士の比較</li>
</ol>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a, b ;

    <span class="co">// false</span>
    <span class="co">// bが値なし</span>
    <span class="dt">bool</span> b1 = a &lt; b ;

    b = <span class="dv">0</span> ;

    <span class="co">// true</span>
    <span class="co">// bは値ありでaが値なし</span>
    <span class="dt">bool</span> b2 = a &lt; b ;

    a = <span class="dv">1</span> ;

    <span class="co">// false</span>
    <span class="co">// どちらとも値があるので値同士の比較</span>
    <span class="co">// 1 &lt; 0はfalse</span>
    <span class="dt">bool</span> b3 = a &lt; b ;
}</code></pre></div>
<h3 id="optionalとstdnulloptとの比較">optionalとstd::nulloptとの比較</h3>
<p>optionalとstd::nulloptとの比較は、std::nulloptが値を持っていないoptionalとして扱われる。</p>
<h3 id="optionaltとtの比較">optional&lt;T&gt;とTの比較</h3>
<p>optional&lt;T&gt;とT型の比較をする場合、optionalは値を保持していなければならない。</p>
<h3 id="make_optionalt-optionaltを返す">make_optional&lt;T&gt; : optional&lt;T&gt;を返す</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> optional&lt;<span class="dt">decay_t</span>&lt;T&gt;&gt; make_optional(T&amp;&amp; v);</code></pre></div>
<p>make_optional&lt;T&gt;(T t)はoptional&lt;T&gt;(t)を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::optional&lt;int&gt;、値は0</span>
    <span class="kw">auto</span> o1 = <span class="bu">std::</span>make_optional( <span class="dv">0</span> ) ;

    <span class="co">// std::optional&lt;double&gt;、値は0.0</span>
    <span class="kw">auto</span> o2 = <span class="bu">std::</span>make_optional( <span class="fl">0.0</span> ) ;
}</code></pre></div>
<h3 id="make_optionalt-args-...-optionaltをin_place_type構築して返す">make_optional&lt;T, Args ... &gt; : optional&lt;T&gt;をin_place_type構築して返す</h3>
<p>make_optionalの第一引数がT型ではない場合、in_place_type構築するオーバーロード関数が選ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// std::optional&lt;X&gt;( std::in_place_type&lt;X&gt;, 1, 2 )</span>
    <span class="kw">auto</span> o = <span class="bu">std::</span>make_optional&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h1 id="string_view-文字列ラッパー">string_view : 文字列ラッパー</h1>
<p>string_viewは、文字型(char, wchar_t, char16_t, char32_t)の連続した配列で表現された文字列に対する共通の文字列ビューを提供する。文字列は所有しない。</p>
<h2 id="使い方-3">使い方</h2>
<p>連続した文字型の配列を使った文字列の表現方法には様々ある。C++では最も基本的な文字列の表現方法として、null終端された文字型の配列がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> str[<span class="dv">6</span>] = { <span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;</span><span class="sc">\0</span><span class="st">&#39;</span> } ;</code></pre></div>
<p>あるいは、文字型の配列と文字数で表現することもある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sizeは文字数</span>
<span class="bu">std::</span>size_t size
<span class="dt">char</span> * ptr ;</code></pre></div>
<p>このような表現をいちいち管理するのは面倒なので、クラスで包むこともある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> <span class="dt">string_type</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> *ptr
} ;</code></pre></div>
<p>このように文字列を表現する方法は様々ある。これらのすべてに対応していると、表現の数だけ関数のオーバーロードが追加されていくことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// null終端文字列用</span>
<span class="dt">void</span> process_string( <span class="dt">char</span> * ptr ) ;
<span class="co">// 配列へのポインターと文字数</span>
<span class="dt">void</span> process_string( <span class="dt">char</span> * ptr, <span class="bu">std::</span>size_t size ) ;
<span class="co">// std::stringクラス</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string s ) ;
<span class="co">// 自作のstring_typeクラス</span>
<span class="dt">void</span> process_string( <span class="dt">string_type</span> s ) ;
<span class="co">// 自作のmy_string_typeクラス</span>
<span class="dt">void</span> process_string( <span class="dt">my_string_type</span> s ) ;</code></pre></div>
<p>string_viewは様々な表現の文字列に対して共通のviewを提供することで、この問題を解決できる。もう関数のオーバーロードを大量に追加する必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 自作のstring_type</span>
<span class="kw">struct</span> <span class="dt">string_type</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;

    <span class="co">// string_viewに対応する変換関数</span>
    <span class="kw">operator</span> <span class="bu">std::</span>string_view() <span class="at">const</span> <span class="kw">noexcept</span>
    {
        <span class="cf">return</span> <span class="bu">std::</span>string_view( ptr, size ) ;
    }
}

<span class="co">// これひとつだけでよい。</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string_view s ) ;

<span class="dt">int</span> main()
{
    <span class="co">// OK</span>
    process_string( <span class="st">&quot;hello&quot;</span> ) ;
    <span class="co">// OK</span>
    process_string( { <span class="st">&quot;hello&quot;</span>, <span class="dv">5</span> } ) ;

    <span class="bu">std::</span>string str( <span class="st">&quot;hello&quot;</span> ) ;
    process_string( str ) ;

    <span class="dt">string_type</span> st{<span class="dv">5</span>, <span class="st">&quot;hello&quot;</span>} ;

    process_string( st ) ;
}</code></pre></div>
<h2 id="basic_string_view">basic_string_view</h2>
<p>std::stringがstd::basic_string&lt; CharT, Traits &gt;に対するstd::basic_string&lt;char&gt;であるように、std::string_viewも、その実態はstd::basic_string_viewの特殊化へのtypedef名だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 本体</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> charT, <span class="kw">class</span> traits = char_traits&lt;charT&gt;&gt;
<span class="kw">class</span> basic_string_view ;

<span class="co">// それぞれの文字型のtypedef名</span>
<span class="kw">using</span> string_view = basic_string_view&lt;<span class="dt">char</span>&gt;;
<span class="kw">using</span> u16string_view = basic_string_view&lt;<span class="dt">char16_t</span>&gt;;
<span class="kw">using</span> u32string_view = basic_string_view&lt;<span class="dt">char32_t</span>&gt;;
<span class="kw">using</span> wstring_view = basic_string_view&lt;<span class="dt">wchar_t</span>&gt;;</code></pre></div>
<p>なので、通常はbasic_string_viewではなく、string_viewとかu16string_viewなどのtypedef名を使うことになる。本書ではstring_viewだけを解説するが、その他のtypedef名も文字型が違うだけで同じだ。</p>
<h2 id="文字列の所有非所有">文字列の所有、非所有</h2>
<p>string_viewは文字列を所有しない。所有というのは、文字列を表現するストレージの確保と破棄に責任を持つということだ。所有しないことの意味を説明するために、まず文字列を所有するライブラリについて説明する。</p>
<p>std::stringは文字列を所有する。std::string風のクラスの実装は、例えば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;

<span class="kw">public</span> :
    <span class="co">// 文字列を表現するストレージの動的確保</span>
    string ( <span class="dt">char</span> <span class="at">const</span> * str )
    {
        size = <span class="bu">std::</span>strlen( str ) ;
        ptr = <span class="kw">new</span> <span class="dt">char</span>[size<span class="dv">+1</span>] ;
        <span class="bu">std::</span>strcpy( ptr, str ) ;
    }

    <span class="co">// コピー</span>
    <span class="co">// 別のストレージを動的確保</span>
    string ( string <span class="at">const</span> &amp; r )
        : size( r.size ), ptr ( <span class="kw">new</span> <span class="dt">char</span>[size<span class="dv">+1</span>] )
    {
        <span class="bu">std::</span>strcpy( ptr, r.ptr ) ;
    }

    <span class="co">// ムーブ</span>
    <span class="co">// 所有権の移動</span>
    string ( string &amp;&amp; r )
        : size( r.size ), ptr( r.ptr )
    {
        r.size = <span class="dv">0</span> ;
        r.ptr = <span class="kw">nullptr</span> ;
    }

    <span class="co">// 破棄</span>
    <span class="co">// 動的確保したストレージを解放</span>
    ~string()
    {
        <span class="kw">delete</span>[] ptr ;
    }
    
} ;</code></pre></div>
<p>std::stringは文字列を表現するストレージを動的に確保し、所有する。コピーは別のストレージを確保する。ムーブするときはストレージの所有権を移す。デストラクターは所有しているストレージを破棄する。</p>
<p>std::string_viewは文字列を所有しない。std::string_view風のクラスの実装は、例えば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> strin<span class="va">g_view</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> <span class="at">const</span> * ptr ;

<span class="kw">public</span> :

    <span class="co">// 所有しない</span>
    <span class="co">// strの参照先の寿命は呼び出し側が責任を持つ</span>
    string_view( <span class="dt">char</span> <span class="at">const</span> * str ) <span class="kw">noexcept</span>
        : size( <span class="bu">std::</span>strlen(str) ), ptr( str )
    { }

    <span class="co">// コピー</span>
    <span class="co">// メンバーごとのコピーだけでよいのでdefault化するだけでよい</span>
    string_view( string_view <span class="at">const</span> &amp; r ) <span class="kw">noexcept</span> = <span class="cf">default</span> ;

    <span class="co">// ムーブはコピーと同じ</span>
    <span class="co">// 所有しないので所有権の移動もない</span>

    <span class="co">// 破棄</span>
    <span class="co">// 何も開放するストレージはない</span>
    <span class="co">// デストラクターもトリビアルでよい</span>
} ;</code></pre></div>
<p>string_viewに渡した連続した文字型の配列へのポインターの寿命は、渡した側が責任を持つ。つまり、以下のようなコードは間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>string_view get_string()
{
    <span class="dt">char</span> str[] = <span class="st">&quot;hello&quot;</span> ;

    <span class="co">// エラー</span>
    <span class="co">// strの寿命は関数の呼び出し元に戻った時点で尽きている</span>
    <span class="cf">return</span> str ;
}</code></pre></div>
<h2 id="string_viewの構築">string_viewの構築</h2>
<p>string_viewの構築には4種類ある。</p>
<ul>
<li>デフォルト構築</li>
<li>null終端された文字型の配列へのポインター</li>
<li>文字方の配列へのポインターと文字数</li>
<li>文字列クラスからの変換関数</li>
</ul>
<h3 id="デフォルト構築">デフォルト構築</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view() <span class="kw">noexcept</span>;</code></pre></div>
<p>string_viewのデフォルト構築は、空のstring_viewを作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 空のstring_view</span>
    <span class="bu">std::</span>string_view s ;
}</code></pre></div>
<h3 id="null終端された文字型の配列へのポインター">null終端された文字型の配列へのポインター</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view(<span class="at">const</span> charT* str);</code></pre></div>
<p>このstring_viewのコンストラクターは、null終端された文字型へのポインターを受け取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string_view s( <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<h3 id="文字型へのポインターと文字数">文字型へのポインターと文字数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view(<span class="at">const</span> charT* str, <span class="dt">size_type</span> len);</code></pre></div>
<p>このstring_viewのコンストラクターは、文字型の配列へのポインターと文字数を受け取る。ポインターはnull終端されていなくてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">char</span> str[] = {<span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>} ;

    <span class="bu">std::</span>string_view s( str, <span class="dv">5</span> ) ;
}</code></pre></div>
<h2 id="文字列クラスからの変換関数">文字列クラスからの変換関数</h2>
<p>他の文字列クラスからstring_viewを作るには、変換関数を使う。string_viewのコンストラクターは使わない。</p>
<p>std::stringはstring_viewへの変換関数をサポートしている。独自の文字列クラスをstring_viewに対応させるにも変換関数を使う。例えば以下のように実装する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;
<span class="kw">public</span> :
    <span class="kw">operator</span> <span class="bu">std::</span>string_view() <span class="at">const</span> <span class="kw">noexcept</span>
    {
        <span class="cf">return</span> <span class="bu">std::</span>string_view( ptr, size ) ;
    }
} ;</code></pre></div>
<p>これにより、std::stringからstring_viewへの変換が可能になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;
    <span class="bu">std::</span>string_view sv = s ;
}</code></pre></div>
<p>コレと同じ方法を使えば、独自の文字列クラスもstring_viewに対応させることができる。</p>
<p>std::stringはstring_viewを受け取るコンストラクターを持っているので、string_viewからstringへの変換もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string_view sv = <span class="st">&quot;hello&quot;</span> ;

    <span class="co">// コピーされる</span>
    <span class="bu">std::</span>string s = sv ;
}</code></pre></div>
<h2 id="string_viewの操作">string_viewの操作</h2>
<p>string_viewは既存の標準ライブラリのstringとほぼ同じ操作性を提供している。例えばイテレーターを取ることができるし、operator []で要素にアクセスできるし、size()で要素数が返るし、find()で検索もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T  t )
{
    <span class="cf">for</span> ( <span class="kw">auto</span> c : t )
    {
        <span class="bu">std::</span>cout &lt;&lt; c ;
    }

    <span class="cf">if</span> ( t.size() &gt; <span class="dv">3</span> )
    {
        <span class="kw">auto</span> c = t[<span class="dv">3</span>] ;
    }

    <span class="kw">auto</span> pos = t.find( <span class="st">&quot;fox&quot;</span> ) ;
}

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s(<span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>) ;

    f( s ) ;

    <span class="bu">std::</span>string_view sv = s ;

    f( sv ) ;
}</code></pre></div>
<p>string_viewは文字列を所有しないので、文字列を書き換える方法を提供していない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;

    s[<span class="dv">0</span>] = <span class="st">&#39;H&#39;</span> ;
    s += <span class="st">&quot;,world&quot;</span> ;

    <span class="bu">std::</span>string_view sv = s ;

    <span class="co">// エラー</span>
    <span class="co">// string_viewは書き換えられない</span>
    sv[<span class="dv">0</span>] = <span class="st">&#39;h&#39;</span> ;
    s += <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
}</code></pre></div>
<p>string_viewは文字列を所有せず、ただ参照しているだけだからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;
    <span class="bu">std::</span>string_view sv = s ;

    <span class="co">// &quot;hello&quot;</span>
    <span class="bu">std::</span>cout &lt;&lt; sv ;

    s = <span class="st">&quot;world&quot;</span> ;

    <span class="co">// &quot;world&quot;</span>
    <span class="co">// string_viewは参照しているだけ</span>
    <span class="bu">std::</span>cout &lt;&lt; sv ;
}</code></pre></div>
<p>string_viewはstringとほぼ互換性のあるメンバーを持っているが、一部の文字列を変更するメンバーは削除されている。</p>
<h3 id="remove_prefixremove_suffix-先頭末尾の要素の削除">remove_prefix/remove_suffix : 先頭、末尾の要素の削除</h3>
<p>string_viewは先頭と末尾からn個の要素を削除するメンバー関数を提供している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">void</span> remove_prefix(<span class="dt">size_type</span> n);
<span class="kw">constexpr</span> <span class="dt">void</span> remove_suffix(<span class="dt">size_type</span> n);</code></pre></div>
<p>string_viewにとって、先頭と末尾からn個の要素を削除するのは、ポインターをn個ずらすだけなので、これは文字列を所有しないstring_viewでも行える操作だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;

    <span class="bu">std::</span>string_view s1 = s ;

    <span class="co">// &quot;lo&quot;</span>
    s1.remove_prefix(<span class="dv">3</span>) ;

    <span class="bu">std::</span>string_view s2 = s ;

    <span class="co">// &quot;he&quot;</span>
    s2.remove_suffix(<span class="dv">3</span>) ;
}</code></pre></div>
<p>このメンバー関数は既存のstd::stringにも追加されている。</p>
<h2 id="ユーザー定義リテラル">ユーザー定義リテラル</h2>
<p>std::stringとstd::string_viewにはユーザー定義リテラルが追加されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char</span>* str, <span class="dt">size_t</span> len);
u16string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char16_t</span>* str, <span class="dt">size_t</span> len);
u32string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char32_t</span>* str, <span class="dt">size_t</span> len);
wstring operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">wchar_t</span>* str, <span class="dt">size_t</span> len);

<span class="kw">constexpr</span> strin<span class="va">g_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;

<span class="kw">constexpr</span> u<span class="er">16string_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char16_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;

<span class="kw">constexpr</span> u<span class="er">32string_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char32_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;

<span class="kw">constexpr</span> wstrin<span class="va">g_view</span>
operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">wchar_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;</code></pre></div>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// std::string</span>
    <span class="kw">auto</span> s = <span class="st">&quot;hello&quot;</span>s ;

    <span class="co">// std::string_view</span>
    <span class="kw">auto</span> sv = <span class="st">&quot;hello&quot;</span>sv ;
}</code></pre></div>
<h1 id="メモリーリソース-動的ストレージ確保ライブラリ">メモリーリソース : 動的ストレージ確保ライブラリ</h1>
<p>ヘッダーファイル&lt;memory_resource&gt;で定義されているメモリーリソースは、動的ストレージを確保するためのC++17で追加されたライブラリだ。その特徴は以下の通り。</p>
<ul>
<li>アロケーターに変わる新しいインターフェースとしてのメモリーリソース</li>
<li>ポリモーフィックな振る舞いを可能にするアロケーター</li>
<li>標準で提供される様々な特性を持ったメモリーリソースの実装</li>
</ul>
<h2 id="メモリーリソース">メモリーリソース</h2>
<p>メモリーリソースはアロケーターに変わる新しいメモリ確保と解放のためのインターフェースとしての抽象クラスだ。コンパイル時に挙動を変える静的ポリモーフィズム設計のアロケーターと違い、メモリーリソースは実行時に挙動を変える動的ポリモーフィズム設計となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( memory_resource * mem )
{
    <span class="co">// 10バイトのストレージを確保</span>
    <span class="kw">auto</span> ptr = mem-&gt;allocate( <span class="dv">10</span> ) ;
    <span class="co">// 確保したストレージを解放</span>
    mem-&gt;deallocate( ptr ) ;
}</code></pre></div>
<p>クラスstd::pmr::memory_resourceの宣言は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> memory_resource {
<span class="kw">public</span>:
    <span class="kw">virtual</span> ~ memory_resource();
    <span class="dt">void</span>* allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment = max_align);
    <span class="dt">void</span> deallocate(<span class="dt">void</span>* p, <span class="dt">size_t</span> bytes,
                    <span class="dt">size_t</span> alignment = max_align);
    <span class="dt">bool</span> is_equal(<span class="at">const</span> memory_resource&amp; other) <span class="at">const</span> <span class="kw">noexcept</span>;

<span class="kw">private</span>:
    <span class="kw">virtual</span> <span class="dt">void</span>* do_allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate( <span class="dt">void</span>* p, <span class="dt">size_t</span> bytes,
                                <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal(<span class="at">const</span> memory_resource&amp; other)
        <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;
};

}</code></pre></div>
<p>クラスmemory_resourceはstd::pmr名前空間スコープのなかにある。</p>
<h3 id="メモリーリソースの使い方">メモリーリソースの使い方</h3>
<p>memory_resourceを使うのは簡単だ。memory_resourceのオブジェクトを確保したら、メンバー関数allocate( bytes, alignment )でストレージを確保する。メンバー関数deallocate( p, bytes, alignment )でストレージを解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * mem )
{
    <span class="co">// 100バイトのストレージを確保</span>
    <span class="dt">void</span> * ptr = mem-&gt;allocate( <span class="dv">100</span> ) ;
    <span class="co">// ストレージを解放</span>
    mem-&gt;deallocate( ptr, <span class="dv">100</span> ) ;
}</code></pre></div>
<p>二つのmemory_resourceのオブジェクトa, bがあるとき、一方のオブジェクトで確保したストレージをもう一方のオブジェクトで解放できるとき、a.is_equal( b )はtrueを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * a, <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resouce * b )
{
    <span class="dt">void</span> * ptr = a-&gt;allocate( <span class="dv">1</span> ) ;

    <span class="co">// aで確保したストレージはbで解放できるか？</span>
    <span class="cf">if</span> ( a-&gt;is_equal( *b ) )
    {<span class="co">// できる</span>
        b-&gt;deallocate( ptr, <span class="dv">1</span> ) ;
    }
    <span class="cf">else</span>
    {<span class="co">// できない</span>
        a-&gt;deallocate( ptr, <span class="dv">1</span> ) ;
    }
}</code></pre></div>
<p>is_equalを呼び出すoperator ==とoperator !=も提供されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * a, <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * b )
{
    <span class="dt">bool</span> b1 = ( *a == *b ) ;
    <span class="dt">bool</span> b2 = ( *a != *b ) ;
}</code></pre></div>
<h3 id="メモリーリソースの作り方">メモリーリソースの作り方</h3>
<p>独自のメモリーアロケーターをmemory_resouceのインターフェースに合わせて作るには、memory_resourceから派生した上で、do_allocate, do_deallocate, do_is_equalの3つのprivate純粋virtualメンバー関数をオーバーライドする。必要に応じてデストラクターもオーバーライドする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> memory_resource {
    <span class="co">// 非公開</span>
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> max_align = <span class="kw">alignof</span>(<span class="dt">max_align_t</span>);

<span class="kw">public</span>:
    <span class="kw">virtual</span> ~ memory_resource();

<span class="kw">private</span>:
    <span class="kw">virtual</span> <span class="dt">void</span>* do_allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate( <span class="dt">void</span>* p, <span class="dt">size_t</span> bytes,
                                <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal(<span class="at">const</span> memory_resource&amp; other) <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;
};</code></pre></div>
<p>do_allocate(bytes, alignment)は少なくともalignmentバイトでアライメントされたbytesバイトのストレージへのポインターを返す。ストレージが確保できなかった場合は、適切な例外をthrowする。</p>
<p>do_deallocate(p, bytes, alignment)は事前に同じ*thisから呼び出されたallocate( bytes, alignment )で返されたポインターpを解放する。すでに解放されたポインターpを渡してはならない。例外は投げない。</p>
<p>do_is_equal(other)は、*thisとotherが互いに一方で確保したストレージをもう一方で解放できる場合にtrueを返す。</p>
<p>たとえば、malloc/freeを使ったmemory_resouceの実装は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// malloc/freeを使ったメモリーリソース</span>
<span class="kw">class</span> malloc_resource : <span class="kw">public</span> <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource
{
<span class="kw">public</span> :
    <span class="co">//</span>
    ~malloc_resource() { }
<span class="kw">private</span> :
    <span class="co">// ストレージの確保</span>
    <span class="co">// 失敗した場合std::bad_allocをthrowする</span>
    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc( bytes ) ;
        <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )
        { <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc{} ; }

        <span class="cf">return</span> ptr ;
    }

    <span class="co">// ストレージの解放</span>
    <span class="kw">virtual</span> <span class="dt">void</span> 
    do_deallocate(  <span class="dt">void</span> * p, <span class="bu">std::</span>size_t bytes, 
                    <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>free( p ) ;
    }

    <span class="kw">virtual</span> <span class="dt">bool</span> 
    do_is_equal( <span class="at">const</span> memory_resource &amp; other )
        <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>
    {
        <span class="cf">return</span> <span class="kw">dynamic_cast</span>&lt; <span class="at">const</span> malloc_resource * &gt;
                    ( &amp;other ) != <span class="kw">nullptr</span> ;
    }

} ;</code></pre></div>
<p>do_allocateはmallocでストレージを確保し、do_deallocateはfreeでストレージを解放する。メモリーリソースで0バイトのストレージを確保しようとしたときの規定はないので、mallocの挙動に任せる。mallocは0バイトのメモリを確保しようとしたとき、C11では規定がない。posixではnullポインターを返すか、freeで解放可能な何らかのアドレスを返すものとしている。</p>
<p>do_is_equalは、malloc_resourceでさえあればどのオブジェクトから確保されたストレージであっても解放できるので、*thisがmalloc_resourceであるかどうかをdynamic_castで確認している。</p>
<h2 id="polymorphic_allocator-動的ポリモーフィズムを実現するアロケーター">polymorphic_allocator : 動的ポリモーフィズムを実現するアロケーター</h2>
<p>std::pmr::polymorphic_allocatorはメモリーリソースを動的ポリモーフィズムとして振る舞うアロケーターにするためのライブラリだ。</p>
<p>従来のアロケーターは、静的ポリモーフィズムを実現するために設計されていた。例えば独自のcustom_int_allocator型を使いたい場合は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>vector&lt; <span class="dt">int</span>, custom_int_allocator &gt; v ;</code></pre></div>
<p>コンパイル時に使うべきアロケーターが決定できる場合はこれでいいのだが、実行時にアロケーターを選択したい場合、アロケーターをテンプレート引数に取る設計は問題になる。</p>
<p>そのため、C++17ではメモリーリソースをコンストラクター引数にとり、メモリーリソースからストレージを確保する実行時ポリモーフィックの振る舞いをするstd::pmr::polymorphic_allocatorが追加された。</p>
<p>例えば、標準入力からtrueかfalseが入力されたかによって、システムのデフォルトのメモリーリソースと、monotonic_buffer_resourceを実行時に切り替えるには、以下のようにかける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b;

    <span class="bu">std::</span>cin &gt;&gt; b ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>mempry_resource * mem ;
    <span class="bu">std::</span>unique_ptr&lt; memory_resource &gt; mono ;

    <span class="cf">if</span> ( b )
    { <span class="co">// デフォルトのメモリーリソースを使う</span>
        mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;
    }
    <span class="cf">else</span>
    { <span class="co">// モノトニックバッファーを使う</span>
        mono = <span class="bu">std::</span>make_unique&lt; <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource &gt;
                ( <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;
        mem = mono.get() ;
    }

    <span class="bu">std::</span>vector&lt; <span class="dt">int</span>, <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; &gt;
        v( <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt;( mem ) ) ;
}</code></pre></div>
<p>std::pmr::polymorphic_allocatorは以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">class</span> polymorphic_allocator ;

}</code></pre></div>
<p>テンプレート実引数にはstd::allocator&lt;T&gt;と同じく、確保する型を与える。</p>
<h3 id="コンストラクター">コンストラクター</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">polymorphic_allocator() <span class="kw">noexcept</span>;
polymorphic_allocator(memory_resource* r);</code></pre></div>
<p>std::pmr::polymorphic_allocatorのデフォルトコンストラクターは、メモリーリソースをstd::pmr::get_default_resource()で取得する。</p>
<p>memory_resource *を引数に取るコンストラクターは、渡されたメモリーリソースをストレージ確保に使う。polymorphic_allocatorの生存期間中、メモリーリソースへのポインターは妥当なものでなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// p1( std::pmr::get_default_resource () ) と同じ</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; p1 ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; p2( <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;
}</code></pre></div>
<p>後は通常のアロケーターと同じように振る舞う。</p>
<h2 id="プログラム全体で使われるメモリーリソースの取得">プログラム全体で使われるメモリーリソースの取得</h2>
<p>C++17では、プログラム全体で使われるメモリーリソースへのポインターを取得することができる。</p>
<h3 id="new_delete_resource">new_delete_resource()</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* new_delete_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>関数new_delete_resourceはメモリーリソースへのポインターを返す。参照されるメモリーリソースは、ストレージの確保に::operator newを使い、ストレージの解放に::operator deleteを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> mem = <span class="bu">std::</span>pmr<span class="bu">::</span>new_delete_resource() ;
}</code></pre></div>
<h3 id="null_memory_resource">null_memory_resource()</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* null_memory_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>関数null_memory_resourceはメモリーリソースへのポインターを返す。参照されるメモリーリソースのallocateは必ず失敗し、std::bad_allocをthrowする。deallocateは何もしない。</p>
<p>このメモリーリソースは、ストレージの確保に失敗した場合のコードをテストする目的で使える。</p>
<h3 id="デフォルトリソース">デフォルトリソース</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* set_default_resource(memory_resource* r) <span class="kw">noexcept</span> ;
memory_resource* get_default_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>デフォルト・メモリーリソース・ポインターとは、メモリーリソースを明示的に指定することができない場合に、システムがデフォルトで利用するメモリーリソースへのポインターのことだ。初期値はnew_delete_resource()の戻り値となっている。</p>
<p>現在のデフォルト・メモリーリソース・ポインターと取得するためには、関数get_default_resourceを使う。デフォルト・メモリーリソース・ポインターを独自のメモリーリソースに差し替えるには、関数set_default_resourceを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 現在のデフォルトのメモリーリソースへのポインター</span>
    <span class="kw">auto</span> init_mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource pool_mem ;

    <span class="co">// デフォルトのメモリーリソースを変更する</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>set_default_resource( &amp;pool_mem ) ;

    <span class="kw">auto</span> current_mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b = current_mem == pool_mem ;
}</code></pre></div>
<h2 id="標準ライブラリのメモリーリソース">標準ライブラリのメモリーリソース</h2>
<p>標準ライブラリはメモリーリソースの実装として、プールリソースとモノトニックリソースを提供している。このメモリーリソースの詳細は後に解説するが、ここではそのための事前知識として、汎用的なメモリーアロケーター一般の解説をする。</p>
<p>プログラマーはメモリーを気軽に確保している。例えば47バイトとか151バイトのような中途半端なサイズのメモリーを以下のように気軽に確保している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> mem = <span class="bu">std::</span>get_default_resource() ;

    <span class="kw">auto</span> p1 = mem-&gt;allocate( <span class="dv">47</span> ) ;
    <span class="kw">auto</span> p2 = mem-&gt;allocate( <span class="dv">151</span> ) ;

    mem-&gt;deallocate( p1 ) ;
    mem-&gt;deallocate( p2 ) ;
}</code></pre></div>
<p>しかし、残念ながら現実のハードウェアやOSのメモリ管理は、このように柔軟にはできていない。例えば、あるアーキテクチャーとOSでは、メモリはページサイズと呼ばれる単位でしか確保できない。そして最小のページサイズですら4KBであったりする。もしシステムの低級なメモリ管理を使って上のコードを実装しようとすると、47バイト程度のメモリを使うのに3KB超の無駄が生じることになる。</p>
<p>他にもアライメントの問題がある。アーキテクチャによってはメモリアドレスが適切なアライメントに配置されていないとメモリアクセスができないか、著しくパフォーマンスが落ちることがある。</p>
<p>mallocやoperator newなどのメモリーアロケーターは、低級なメモリ管理を隠匿し、小さなサイズのメモリ確保を効率的に行うための実装をしている。</p>
<p>一般的には、大きな連続したアドレス空間のメモリを確保し、その中に管理用のデータ構造を作り、メモリを必要なサイズに切り出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="co">// ストレージを分割して管理するためのリンクリストデータ構造</span>
<span class="kw">struct</span> <span class="kw">alignas</span>(<span class="bu">std::</span>max_align_t) chunk
{
    chunk * next ;
    chunk * prev ;
    <span class="bu">std::</span>size_t size ;
} ;

<span class="kw">class</span> memory_allocator : <span class="kw">public</span> <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource
{
    chunk * ptr ; <span class="co">// ストレージの先頭へのポインター</span>
    <span class="bu">std::</span>size_t size ; <span class="co">// ストレージのサイズ</span>
    <span class="bu">std::</span>mutex m ; <span class="co">// 同期用</span>

    
<span class="kw">public</span> :

    memory_allocator()
    {
        <span class="co">// 大きな連続したストレージを確保</span>
    }

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>scoped_lock lock( m ) ; 
        <span class="co">// リンクリストをたどり、十分な大きさの未使用領域を探し、リンクリスト構造体を構築して返す</span>
        <span class="co">// アライメント要求に注意</span>
    }

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>scoped_lock lock( m ) ;
        <span class="co">// リンクリストから該当する部分を削除</span>
    }

    <span class="kw">virtual</span> <span class="dt">bool</span> 
    do_is_equal( <span class="at">const</span> memory_resource &amp; other )
        <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>
    { 
    <span class="co">// *thisとotherで相互にストレージを解放できるかどうか返す</span>
    }
} ;</code></pre></div>
<h2 id="プールリソース">プールリソース</h2>
<p>プールリソースはC++17の標準ライブラリが提供しているメモリーリソースの実装だ。synchronized_pool_resourceとunsynchronized_pool_resourceの二つがある。</p>
<h3 id="アルゴリズム">アルゴリズム</h3>
<p>プールリソースは以下のような特徴を持つ。</p>
<ul>
<li>プールリソースのオブジェクトが破棄されるとき、そのオブジェクトからallocateで確保したストレージは、明示的にdeallocateを呼ばずとも解放される。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource mem ;
    mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// 確保したストレージは破棄される</span>
}</code></pre></div>
<ul>
<li>プールリソースの構築時に、上流メモリーリソースを与えることができる。プールリソースは上流メモリーリソースからチャンクのためのストレージを確保する。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// get_default_resource()が使われる</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource m1 ;

    <span class="co">// 独自の上流メモリーリソースを指定</span>
    custom_memory_resource mem ;
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource m2( &amp;mem ) ;
    
}</code></pre></div>
<ul>
<li><p>プールリソースはストレージを確保する上流メモリーリソースから、プールと呼ばれる複数のストレージを確保する。プールは複数のチャンクを保持している。チャンクは複数の同一サイズのブロックを保持している。プールリソースに対するdo_allocate(size, alignment)は、少なくともsizeバイトのブロックサイズのプールのいずれかのチャンクのブロックが割り当てられる。</p>
<p>もし、最大のブロックサイズを超えるサイズのストレージを確保しようとした場合、上流メモリーリソースから確保される。</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="co">// チャンクの実装</span>
<span class="kw">template</span> &lt; <span class="dt">size_t</span> block_size &gt;
<span class="kw">class</span> chunk
{
    blocks&lt;block_size&gt; b ;
}

<span class="co">// プールの実装</span>
<span class="kw">template</span> &lt; <span class="dt">size_t</span> block_size &gt;
<span class="kw">class</span> pool : <span class="kw">public</span> memory_resource
{
    chunks&lt;block_size&gt; c ;
} ;

<span class="kw">class</span> pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="co">// それぞれのブロックサイズのプール</span>
    pool&lt;<span class="dv">8</span>&gt; pool_8bytes ;
    pool&lt;<span class="dv">16</span>&gt; pool_16bytes ;
    pool&lt;<span class="dv">32</span>&gt; pool_32bytes ;

    <span class="co">// 上流メモリーリソース</span>
    memory_resource * mem ;


    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 対応するブロックサイズのプールにディスパッチ</span>
        <span class="cf">if</span> ( bytes &lt;= <span class="dv">8</span> )
            <span class="cf">return</span> pool_8bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span> <span class="cf">if</span> ( bytes &lt;= <span class="dv">16</span> )
            <span class="cf">return</span> pool_16bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span> <span class="cf">if</span> ( bytes &lt; <span class="dv">32</span> )
            <span class="cf">return</span> pool_32bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span>
        <span class="co">// 最大ブロックサイズを超えたので上流メモリーリソースにディスパッチ</span>
            <span class="cf">return</span> mem-&gt;allocate( bytes, alignment ) ;
    }
} ;

}</code></pre></div>
<ul>
<li><p>プールリソースは構築時にpool_optionsを渡すことにより、最大ブロックサイズと最大チャンクサイズを設定できる。</p></li>
<li><p>マルチスレッドから呼び出しても安全な同期を取るsynchronized_pool_resourceと、同期をとらないunsynchronized_pool_resourceがある。</p></li>
</ul>
<h3 id="synchronizedunsynchronized_pool_resource">synchronized/unsynchronized_pool_resource</h3>
<p>プールリソースには、synchronized_pool_resourceとunsynchronized_pool_resourceがある。どちらもクラス名以外は同じように使える。ただし、synchronized_pool_resourceは複数のスレッドから同時に実行しても使えるように内部で同期が取られているのに対し、unsynchronized_pool_resourceは同期を行わない。unsyncrhonized_pool_resourceは複数のスレッドから同時に呼び出すことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> synchronized_pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="bu">std::</span>mutex m ;

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="dt">size_t</span> size, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 同期する</span>
        <span class="bu">std::</span>scoped_lock l(m) ;
        <span class="cf">return</span> do_allocate_impl( size, alignment ) ;
    }
} ;

<span class="kw">class</span> unsynchronized_pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="dt">size_t</span> size, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 同期しない</span>
        <span class="cf">return</span> do_allocate_impl( size, alignment ) ;
    }
} ;

}</code></pre></div>
<h3 id="pool_options">pool_options</h3>
<p>pool_optionsはプールリソースの挙動を指定するためのクラスで、以下のように定義されてる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">struct</span> pool_options {
    <span class="dt">size_t</span> max_blocks_per_chunk = <span class="dv">0</span>;
    <span class="dt">size_t</span> largest_required_pool_block = <span class="dv">0</span>;
};

}</code></pre></div>
<p>このクラスのオブジェクトをプールリソースのコンストラクターに与えることで、プールリソースの挙動を指定できる。ただし、pool_optionsによる指定はあくまでも目安で、実装には従う義務はない。</p>
<p>max_blocks_per_chunkは、上流メモリーリソースからプールのチャンクを補充する際に一度に確保する最大のブロック数だ。この値がゼロか、実装の上限より大きい場合、実装の上限が使われる。実装は指定よりも小さい値を使うことができるし、またプールごとに別の値を使うこともできる。</p>
<p>largest_required_pool_blockはプール機構によって確保される最大のストレージのサイズだ。この値より大きなサイズのストレージを確保しようとすると、上流メモリーストレージから直接確保される。この値がゼロか、実装の上限よりも大きい場合、実装の上限が使われる。実装は指定よりも大きい値を使うこともできる。</p>
<h3 id="プールリソースのコンストラクター">プールリソースのコンストラクター</h3>
<p>プールリソースの根本的なコンストラクターは以下の通り。synchronizedとunsynchronizedどちらも同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pool_resource(<span class="at">const</span> pool_options&amp; opts, memory_resource* upstream);

pool_resource()
: pool_resource(pool_options(), get_default_resource()) {}
<span class="kw">explicit</span> pool_resource(memory_resource* upstream)
: pool_resource(pool_options(), upstream) {}
<span class="kw">explicit</span> pool_resource(<span class="at">const</span> pool_options&amp; opts)
: pool_resource(opts, get_default_resource()) {}</code></pre></div>
<p>pool_optionsとmemory_resource *を指定する。指定しない場合はデフォルト値が使われる。</p>
<h3 id="プールリソースのメンバー関数">プールリソースのメンバー関数</h3>
<h4 id="release">release()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> release();</code></pre></div>
<p>確保したストレージ全てを解放する。たとえ明示的にdeallocateを呼び出されていないストレージも解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    synchronized_pool_resource mem ;
    <span class="dt">void</span> * ptr = mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// ptrは解放される</span>
    mem.release() ;

}</code></pre></div>
<h4 id="upstream_resource">upstream_resource()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* upstream_resource() <span class="at">const</span>;</code></pre></div>
<p>構築時に渡した上流メモリーリソースへのポインターを返す。</p>
<h4 id="options">options()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pool_options options() <span class="at">const</span>;</code></pre></div>
<p>構築時に渡したpool_optionsオブジェクトと同じ値を返す。</p>
<h2 id="モノトニックバッファーリソース">モノトニックバッファーリソース</h2>
<p>モノトニックバッファーリソースはC++17で標準ライブラリに追加されたメモリーリソースの実装だ。クラス名はmonotonic_buffer_resource。</p>
<p>モノトニックバッファーリソースは高速にメモリーを確保し、一気に解放するという用途に特化した特殊な設計をしている。モノトニックバッファーリソースはメモリー解放をせず、メモリー使用量がモノトニックに増え続けるので、この名前がついている。</p>
<p>例えばゲームで1フレームを描画する際に大量に小さなオブジェクトのためのストレージを確保し、その後確保したストレージをすべて解放したい場合を考える。通常のメモリーアロケーターでは、メモリー片を解放するためにメモリー全体に構築されたデータ構造を辿り、データ構造を書き換えなければならない。この処理は高くつく。すべてのメモリー片を一斉に解放してよいのであれば、データ構造をいちいち辿ったり書き換えたりする必要はない。メモリーの管理は、単にポインターだけでよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> monotonic_buffer_resource : <span class="kw">public</span> memory_resource
{
    <span class="co">// 連続した長大なストレージの先頭へのポインター</span>
    <span class="dt">void</span> * ptr ;
    <span class="co">// 現在の未使用ストレージの先頭へのポインター</span>
    <span class="bu">std::</span>byte * current ;

    <span class="kw">virtual</span> <span class="dt">void</span> * 
    do_allocate( <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="dt">void</span> * result = <span class="kw">static_cast</span>&lt;<span class="dt">void</span> *&gt;(current) ;
        current += bytes ; <span class="co">// 必要であればアライメント調整</span>
        <span class="cf">return</span> result ;
    }

    <span class="kw">virtual</span> <span class="dt">void</span> 
    do_deallocate( <span class="dt">void</span> * ptr, <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span> 
    {
        <span class="co">// 何もしない</span>
    }

<span class="kw">public</span> :
    ~monotonic_buffer_resource()
    {
        <span class="co">// ptrの解放</span>
    }
} ;

}</code></pre></div>
<p>このように、基本的な実装としては、do_allocateはポインターを加算して管理するだけだ。なぜならば解放処理がいらないため、個々のストレージ片を管理するためのデータ構造を構築する必要がない。do_deallocateはなにもしない。デストラクターはストレージ全体を解放する。</p>
<h3 id="アルゴリズム-1">アルゴリズム</h3>
<p>モノトニックバッファーリソースは以下のような特徴を持つ。</p>
<ul>
<li>deallocate呼び出しは何もしない。メモリー使用量はリソースが破棄されるまでモノトニックに増え続ける。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem ;

    <span class="dt">void</span> * ptr = mem.allocate( <span class="dv">10</span> ) ;
    <span class="co">// 何もしない</span>
    <span class="co">// ストレージは解放されない。</span>
    mem.deallocate( ptr ) ;

    <span class="co">// memが破棄される際に確保したストレージはすべて破棄される</span>
}</code></pre></div>
<ul>
<li>メモリー確保に使う初期バッファーを与えることができる。ストレージ確保の際に、初期バッファーに空きがある場合はそこから確保する。空きがない場合は上流メモリーリソースからバッファーを確保して、バッファーから確保する。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte initial_buffer[<span class="dv">10</span>] ;
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource 
        mem( initial_buffer, <span class="dv">10</span>, <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;

    <span class="co">// 初期バッファーから確保</span>
    mem.allocate( <span class="dv">1</span> ) ;
    <span class="co">// 上流メモリーリソースからストレージを確保して切り出して確保</span>
    mem.allocate( <span class="dv">100</span> ) ;
    <span class="co">// 前回のストレージ確保で空きがあればそこから</span>
    <span class="co">// なければ新たに上流から確保して切り出す。</span>
    mem.allocate( <span class="dv">100</span> ) ;
}</code></pre></div>
<ul>
<li><p>一つのスレッドから使うことを前提に設計されている。allocateとdeallocateは同期しない。</p></li>
<li><p>メモリーリソースが破棄されると確保されたすべてのストレージも解放される。明示的にdeallocateを呼ばなくてもよい。</p></li>
</ul>
<h3 id="コンストラクター-1">コンストラクター</h3>
<p>モノトニックバッファーリソースには以下のコンストラクターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">explicit</span> monotonic_buffer_resource(memory_resource *upstream);
monotonic_buffer_resource(  <span class="dt">size_t</span> initial_size,
                            memory_resource *upstream);
monotonic_buffer_resource(  <span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size,
                            memory_resource *upstream);


monotonic_buffer_resource()
    : monotonic_buffer_resource(get_default_resource()) {}
<span class="kw">explicit</span> monotonic_buffer_resource(<span class="dt">size_t</span> initial_size)
    : monotonic_buffer_resource(initial_size,
                                get_default_resource()) {}
monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size)
    : monotonic_buffer_resource(buffer, buffer_size,
                                get_default_resource()) {}</code></pre></div>
<p>初期バッファーを取らないコンストラクターは以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">explicit</span> monotonic_buffer_resource(memory_resource *upstream);
monotonic_buffer_resource(  <span class="dt">size_t</span> initial_size,
                            memory_resource *upstream);

monotonic_buffer_resource()
    : monotonic_buffer_resource(get_default_resource()) {}
<span class="kw">explicit</span> monotonic_buffer_resource(<span class="dt">size_t</span> initial_size)
    : monotonic_buffer_resource(initial_size,
                                get_default_resource()) {}</code></pre></div>
<p>initial_sizeは、上流メモリーリソースから最初に確保するバッファーのサイズ(初期サイズ)のヒントとなる。実装はこのサイズか、あるいは実装依存のサイズをバッファーとして確保する。</p>
<p>デフォルトコンストラクターは上流メモリーリソースにstd::pmr_get_default_resource()を与えたのと同じ挙動になる。</p>
<p>size_tひとつだけを取るコンストラクターは、初期サイズだけを与えて後はデフォルトの扱いになる。</p>
<p>初期バッファーをとるコンストラクターは以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">monotonic_buffer_resource(  <span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size,
                            memory_resource *upstream);

monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size)
    : monotonic_buffer_resource(buffer, buffer_size,
                                get_default_resource()) {}</code></pre></div>
<p>初期バッファーは先頭アドレスをvoid *型で渡し、そのサイズをsize_t型で渡す。</p>
<h3 id="その他の操作">その他の操作</h3>
<h4 id="release-1">release()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> release() ;</code></pre></div>
<p>メンバー関数releaseは、上流リソースから確保されたストレージをすべて解放する。明示的にdeallocateを呼び出していないストレージも解放される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem ;

    mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// ストレージはすべて解放される</span>
    mem.release() ;

}</code></pre></div>
<h4 id="upstream_resource-1">upstream_resource()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* upstream_resource() <span class="at">const</span>;</code></pre></div>
<p>メンバー関数uptream_resourceは、構築時に与えられた上流メモリーリソースへのポインターを返す。</p>
<h1 id="並列アルゴリズム">並列アルゴリズム</h1>
<p>並列アルゴリズムはC++17で追加された新しいライブラリだ。このライブラリは既存の&lt;algorithm&gt;に、並列実行版を追加する。</p>
<h2 id="並列実行について">並列実行について</h2>
<p>C++11では、スレッドと同期処理が追加され、複数の実行媒体が同時に実行されるという概念がC++標準規格に入った。</p>
<p>C++17では、既存のアルゴリズムに、並列実行版が追加された。</p>
<p>例えば、all_of(first, last, pred)というアルゴリズムは、[first,last)の区間が空であるか、すべてのイテレーターiに対してpred(*i)がtrueを返すとき、trueを返す。それ以外の場合はfalseを返す。</p>
<p>すべての値が100未満であるかどうかを調べるには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="cf">return</span> <span class="bu">std::</span>all_of( <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
        []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
}

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; input ;
    <span class="bu">std::</span>copy( <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin), <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(), <span class="bu">std::</span>back_inserter(input) ) ;

    <span class="dt">bool</span> result = is_all_of_less_than_100( input ) ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;result : &quot;</span> &lt;&lt; result &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>本書の執筆時点では、コンピューターはマルチコアが一般的になり、同時に複数のスレッドを実行できるようになった。さっそくこの処理を二つのスレッドで並列化してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> double_is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(input) ;
    <span class="kw">auto</span> last = first + (input.size()/<span class="dv">2</span>) ;

    <span class="kw">auto</span> r1 = <span class="bu">std::</span>async( [=]
    {
        <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,
                            [](<span class="kw">auto</span> x) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ; 
    } ) ;

    first = last ;
    last = <span class="bu">std::</span>end(input) ;

    <span class="kw">auto</span> r2 = <span class="bu">std::</span>async( [=]
    {
        <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,
                            [](<span class="kw">auto</span> x) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
    } ) ;

    <span class="cf">return</span> r1.get() &amp;&amp; r2.get() ;
}</code></pre></div>
<p>なるほど、とてもわかりにくいコードだ。</p>
<p>筆者のコンピューターのCPUは二つの物理コア、4つの論理コアを持っているので、4スレッドまで同時に並列実行できる。読者の使っているコンピューターは、より高性能で更に多くのスレッドを同時に実行可能だろう。実行時に最大の効率を出すようにできるだけ頑張ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> parallel_is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="bu">std::</span>size_t cores = <span class="bu">std::</span>thread<span class="bu">::</span>hardware_concurrency() ;
    cores = <span class="bu">std::</span>min( input.size(), cores ) ;

    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>future&lt;<span class="dt">bool</span>&gt; &gt; futures( cores ) ;

    <span class="kw">auto</span> step = input.size() / cores ;
    <span class="kw">auto</span> remainder = input.size() % cores ;

    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(input) ;
    <span class="kw">auto</span> last = first + step + remainder ;

    <span class="cf">for</span> ( <span class="kw">auto</span> &amp; f : futures )
    {
        f = <span class="bu">std::</span>async( [=]
        {
            <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last,
                                [](<span class="kw">auto</span> x){ <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
        } ) ;

        first = last ;
        last = first + step ;
    }

    <span class="cf">for</span> ( <span class="kw">auto</span> &amp; f : futures )
    {
        <span class="cf">if</span> ( f.get() == <span class="kw">false</span> )
            <span class="cf">return</span> <span class="kw">false</span> ;
    }
    <span class="cf">return</span> <span class="kw">true</span> ;
}</code></pre></div>
<p>もうわけがわからない。</p>
<p>このような並列化をそれぞれのアルゴリズムに対して自前で実装するのは面倒だ。そこで、C++17では標準で並列実行してくれる並列アルゴリズム(Parallelism)が追加された。</p>
<h2 id="使い方-4">使い方</h2>
<p>並列アルゴリズムは既存のアルゴリズムのオーバーロードとして追加されている。</p>
<p>以下は既存のアルゴリズムであるall_ofの宣言だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Predicate&gt;
<span class="dt">bool</span> all_of(InputIterator first, InputIterator last, Predicate pred);</code></pre></div>
<p>並列アルゴリズム版のall_ofは以下のような宣言になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> ExecutionPolicy, <span class="kw">class</span> ForwardIterator,
            <span class="kw">class</span> Predicate&gt;
<span class="dt">bool</span> all_of(ExecutionPolicy&amp;&amp; exec, ForwardIterator first,
            ForwardIterator last, Predicate pred);</code></pre></div>
<p>並列アルゴリズムには、テンプレート仮引数としてExecutionPolicyが追加されていて第一引数に取る。これを実行時ポリシーと呼ぶ。</p>
<p>実行時ポリシーは&lt;execution&gt;で定義されている関数ディスパッチ用のタグ型で、std::execution::seq, std::execution::par, std::execution::par_unseqがある。</p>
<p>複数のスレッドによる並列実行を行うには、std::execution::parを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="cf">return</span> <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par,
        <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
        []( <span class="kw">auto</span> x ){ <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
}</code></pre></div>
<p>std::execution::seqを渡すと既存のアルゴリズムと同じシーケンシャル実行になる。std::execution::parを渡すとパラレル実行になる。std::execution::par_unseqは並列実行かつベクトル実行になる。</p>
<p>C++17には実行ポリシーを受け取るアルゴリズムのオーバーロード関数が追加されている。</p>
<h2 id="並列アルゴリズム詳細">並列アルゴリズム詳細</h2>
<h3 id="並列アルゴリズム-1">並列アルゴリズム</h3>
<p>並列アルゴリズム(parallel algorithm)とは、ExecutionPolicy(実行ポリシー)というテンプレートパラメーターのある関数テンプレートのことだ。既存の&lt;algorithm&gt;とC++14で追加された一部の関数テンプレートが、並列アルゴリズムに対応している。</p>
<p>並列アルゴリズムはイテレーター、仕様上定められた操作、ユーザーの提供する関数オブジェクトによる操作、仕様上定められた関数オブジェクトに対する操作によって、オブジェクトにアクセスする。そのような関数群を、要素アクセス関数(element access functions)と呼ぶ。</p>
<p>例えば、std::sortは以下のような要素アクセス関数を持つ。</p>
<ul>
<li>テンプレート実引数で与えられたランダムアクセスイテレーター</li>
<li>要素に対するswap関数の適用</li>
<li>ユーザー提供されたCompare関数オブジェクト</li>
</ul>
<p>並列アルゴリズムが使う要素アクセス関数は、並列実行にともなう様々な制約を満たさなければならない。</p>
<h3 id="ユーザー提供する関数オブジェクトの制約">ユーザー提供する関数オブジェクトの制約</h3>
<p>並列アルゴリズムのうち、テンプレートパラメーター名が、Predicate, BinaryPredicate, Compare, UnaryOperation, BinaryOperation, BinaryOperation1, BinaryOperation2となってるものは、関数オブジェクトとしてユーザーがアルゴリズムに提供するものである。このようなユーザー提供の関数オブジェクトには、並列アルゴリズムに渡す際の制約がある。</p>
<ul>
<li>実引数で与えられたオブジェクトを直接、間接に変更してはならない</li>
<li>実引数で与えられたオブジェクトの一意性に依存してはならない</li>
<li>データ競合と同期</li>
</ul>
<p>一部の特殊なアルゴリズムには例外もあるが、ほとんどの並列アルゴリズムではこの制約を満たさなければならない。</p>
<h4 id="実引数で与えられたオブジェクトを直接間接に変更してはならない">実引数で与えられたオブジェクトを直接、間接に変更してはならない</h4>
<p>ユーザー提供の関数オブジェクトは実引数で与えられたオブジェクトを直接、間接に変更してはならない。</p>
<p>つまり、以下のようなコードは違法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
    <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [](<span class="kw">auto</span> &amp; x){ ++x ; <span class="cf">return</span> <span class="kw">true</span> ; } ) ;
    <span class="co">// エラー</span>
}</code></pre></div>
<p>これは、ユーザー提供の関数オブジェクトが実引数をlvalueリファレンスで受け取って変更しているので、並列アルゴリズムの制約を満たさない。</p>
<p>std::for_eachはイテレーターが変更可能な要素を返す場合、ユーザー提供の関数オブジェクトが実引数を変更することが可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [](<span class="kw">auto</span> &amp; x){ ++x ; } ) ;
    <span class="co">// OK</span>
}</code></pre></div>
<p>これは、for_eachは仕様上そのように定められているからだ。</p>
<h4 id="実引数で与えられたオブジェクトの一意性に依存してはならない">実引数で与えられたオブジェクトの一意性に依存してはならない</h4>
<p>ユーザー提供の関数オブジェクトは実引数で与えられたオブジェクトの一意性に依存してはならない。</p>
<p>これはどういうことかというと、たとえば実引数で渡されたオブジェクトのアドレスを取得して、そのアドレスがアルゴリズムに渡したオブジェクトのアドレスと同じであることを期待するようなコードを書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="co">// 最後の要素へのポインター</span>
    <span class="dt">int</span> * ptr = &amp;c[<span class="dv">4</span>] ;

    <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [=]( <span class="kw">auto</span> &amp; x ){
            <span class="cf">if</span> ( ptr == &amp;x )
            {
                <span class="co">// 最後の要素なので特別な処理</span>
                <span class="co">// エラー</span>
            }
        } ) ;
}</code></pre></div>
<p>これはなぜかというと、並列アルゴリズムはその並列処理の一環として、要素のコピーを作成し、そのコピーをユーザー提供の関数オブジェクトに渡すかもしれないからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">template</span> &lt;  <span class="kw">typename</span> ExecutionPolicy,
            <span class="kw">typename</span> ForwardIterator,
            <span class="kw">typename</span> Predicate &gt;
<span class="dt">bool</span> all_of(    ExecutionPolicy &amp;&amp; exec,
                ForwardIterator first, ForwardIterator last,
                Predicate pred )
{
    <span class="cf">if</span> <span class="kw">constexpr</span> (
        <span class="bu">std::</span>is_same_v&lt; ExecutionPolicy,
                        <span class="bu">std::</span>execution<span class="bu">::</span>parallel_policy &gt;
    )
    {
        <span class="bu">std::</span>vector c( first, last ) ;
        do_all_of_par( <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c), pred ) ;
    }
}</code></pre></div>
<p>このため、オブジェクトの一意性に依存したコードを書くことはできない。</p>
<h4 id="データ競合と同期">データ競合と同期</h4>
<p>std::execution::sequenced_policyを渡した並列アルゴリズムによる要素アクセス関数の呼び出しは呼び出し側スレッドで実行される。パラレル実行ではない。</p>
<p>std::execution::parallel_policyを渡した並列アルゴリズムによる要素アクセス関数の呼び出しは、呼び出し側スレッドか、ライブラリ側で作られたスレッドのいずれかで実行される。それぞれの要素アクセス関数の呼び出しの同期は定められていない。そのため、要素アクセス関数はデータ競合やデッドロックを起こさないようにしなければならない。</p>
<p>以下のコードはデータ競合が発生するのでエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [&amp;]( <span class="kw">auto</span> x ){ sum += x ; } ) ;
    <span class="co">// エラー、データ競合</span>
}</code></pre></div>
<p>なぜならば、ユーザー提供の関数オブジェクトは複数のスレッドから同時に呼び出されるかもしれないからだ。</p>
<p>std::execution::parallel_unsequenced_policyの実行は変わっている。未規定のスレッドから同期されない実行が許されている。これは、パラレルベクトル実行で想定している実行媒体がスレッドのような強い実行保証のある実行媒体ではなく、SIMDやGPGPUのような極めて軽い実行媒体であるからだ。</p>
<p>その結果、要素アクセス関数は通常のデータ競合やデッドロックを防ぐための手段すら取れなくなる。なぜならば、スレッドは実行の途中に中断して別の処理をしたりするからだ。</p>
<p>例えば、以下のコードは動かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
    <span class="bu">std::</span>mutex m ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="bu">std::</span>for_each(
        <span class="bu">std::</span>execution<span class="bu">::</span>par_unseq,
        <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [&amp;]( <span class="kw">auto</span> x ) {
            <span class="bu">std::</span>scoped_lock l(m) ;
            sum += x ; 
        } ) ;
    <span class="co">// エラー</span>
}</code></pre></div>
<p>このコードはparallel_policyならば、非効率的ではあるが問題なく同期されてデータ競合なく動くコードだ。しかし、parallel_unsequenced_policyでは動かない。なぜならば、mutexのlockという同期をする関数を呼び出すからだ。</p>
<p>C++では、ストレージの確保解放以外の同期する標準ライブラリの関数をすべて、ベクトル化非安全(vectorization-unsafe)に分類している。ベクトル化非安全な関数はstd::execution::parallel_unsequenced_policyの要素アクセス関数内で呼び出すことはできない。</p>
<h3 id="例外">例外</h3>
<p>並列アルゴリズムの実行中に、一時メモリーの確保が必要になったが確保できない場合、std::bad_allocがthrowされる。</p>
<p>並列アルゴリズムの実行中に、要素アクセス関数の外に例外が投げられた場合、std::terminateが呼ばれる。</p>
<h3 id="実行ポリシー">実行ポリシー</h3>
<p>実行ポリシーはヘッダーファイル&lt;execution&gt;で定義されている。その定義は以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">struct</span> is_execution_policy;
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span>
    is_execution_policy_v = is_execution_policy&lt;T&gt;::value;
}

<span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> sequenced_policy;
<span class="kw">class</span> parallel_policy;
<span class="kw">class</span> parallel_unsequenced_policy;

<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq{ };

}</code></pre></div>
<h4 id="is_execution_policy-traits">is_execution_policy traits</h4>
<p>std::is_execution_policy&lt;T&gt;はTが実行ポリシー型であるかどうかを返すtraitsだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// false</span>
<span class="kw">constexpr</span> <span class="dt">bool</span> b1 = <span class="bu">std::</span>is_execution_policy_v&lt;<span class="dt">int</span>&gt; ;
<span class="co">// true</span>
<span class="kw">constexpr</span> <span class="dt">bool</span> b2 = 
    <span class="bu">std::</span>is_execution_policy_v&lt;<span class="bu">std::</span>execution<span class="bu">::</span>sequenced_policy&gt; ;</code></pre></div>
<h4 id="シーケンス実行ポリシー">シーケンス実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> sequenced_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq { } ;

}</code></pre></div>
<p>シーケンス実行ポリシーは、並列アルゴリズムにパラレル実行を行わせないためのポリシーだ。この実行ポリシーが渡された場合、処理は呼び出し元のスレッドだけで行われる。</p>
<h4 id="パラレル実行ポリシー">パラレル実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> parallel_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par { } ;

}</code></pre></div>
<p>パラレル実行ポリシーは、並列アルゴリズムにパラレル実行を行わせるためのポリシーだ。この実行ポリシーが渡された場合、処理は呼び出し元のスレッドと、ライブラリが作成したスレッドを用いる。</p>
<h4 id="パラレル非シーケンス実行ポリシー">パラレル非シーケンス実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> parallel_unsequenced_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq { } ;

}</code></pre></div>
<p>パラレル非シーケンス実行ポリシーは、並列アルゴリズムにパラレル実行かつベクトル実行を行わせるためのポリシーだ。この実行ポリシーが渡された場合、処理は複数のスレッドと、SIMDやGPGPUのようなベクトル実行による並列化を行う。</p>
<h4 id="実行ポリシーオブジェクト">実行ポリシーオブジェクト</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq{ };

}</code></pre></div>
<p>実行ポリシーの型を直接書くのは面倒だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>parallel_policy{}, ... ) ;</code></pre></div>
<p>そのため、標準ライブラリは実行ポリシーのオブジェクトを用意している。seqとparとpar_unseqがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, ... ) ;</code></pre></div>
<p>並列アルゴリズムを使うには、このオブジェクトを並列アルゴリズムの第一引数に渡すことになる。</p>
<h1 id="数学の特殊関数群">数学の特殊関数群</h1>
<p>C++17では数学の特殊関数群(mathematical special functions)がヘッダーファイル&lt;cmath&gt;に追加された。</p>
<p>数学の特殊関数は、いずれも実引数をとって、規定の計算をし、結果を浮動小数点数型の戻り値として返す。</p>
<p>数学の特殊関数はdouble, float, long double型の3つのオーバーロードがある。それぞれ、関数名の最後に、何もなし、f, lというサフィックスで表現されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      function_name() ;   <span class="co">// 何もなし</span>
<span class="dt">float</span>       function_namef() ;  <span class="co">// f</span>
<span class="dt">long</span> <span class="dt">double</span> function_namel() ;  <span class="co">// l</span></code></pre></div>
<p>数学の特殊関数の説明は、関数の宣言、効果、戻り値、注意がある。</p>
<p>もし、数学の特殊関数に渡した実引数がNaN(Not a Number)である場合、関数の戻り値もNaNになる。ただし定義域エラーは起こらない。</p>
<p>それ以外の場合で、関数が定義域エラーを返すべきときは、</p>
<ul>
<li>関数の戻り値の記述で、定義域が示されていて実引数が示された定義域を超えるとき</li>
<li>実引数に対応する数学関数の結果の値が非ゼロの虚数部を含むとき</li>
<li>実引数に対応する数学関数の結果の値が数学的に定義されていないとき</li>
</ul>
<p>別途示されていない場合、関数はすべての有限の値、負の無限大、正の無限大に対しても定義されている。</p>
<p>数学関数が与えられた実引数の値に対して定義されているというとき、それは以下のいずれかである。</p>
<ul>
<li>実引数の値の集合に対して明示的に定義されている</li>
<li>計算方法に依存しない極限値が存在する</li>
</ul>
<p>ある関数の効果が実装定義(implementation-defined)である場合、その効果はC++標準規格で定義されず、C++実装はどのように実装してもよいという意味だ。</p>
<h2 id="ラゲール多項式laguerre-polynomials">ラゲール多項式(Laguerre polynomials)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       laguerre(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        laguerref(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  laguerrel(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数n, xに対するラゲール多項式(Laguerre polynomials)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{L}_n(x) =
  \frac{e^x}{n!} \frac{ \mathsf{d} ^ n}
            { \mathsf{d}x ^ n} \, (x^n e^{-x}),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(n\)</span>をn、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意： n &gt;= 128のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="ラゲール陪多項式associated-laguerre-polynomials">ラゲール陪多項式(Associated Laguerre polynomials)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      assoc_laguerre(<span class="dt">unsigned</span> n, <span class="dt">unsigned</span> m, <span class="dt">double</span> x);
<span class="dt">float</span>       assoc_laguerref(<span class="dt">unsigned</span> n, <span class="dt">unsigned</span> m, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span> assoc_laguerrel(<span class="dt">unsigned</span> n, <span class="dt">unsigned</span> m, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数n, m, xに対するラゲール陪多項式(Associated Laguerre polynomials)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{L}_n^m(x) =
  (-1)^m \frac{\mathsf{d} ^ m}
       {\mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(n\)</span>をn、<span class="math inline">\(m\)</span>をm、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：n &gt;= 128 もしくは m &gt;= 128 のときの関数呼び出しの効果は実装定義である。</p>
<h2 id="ルジャンドル多項式legendre-polynomials">ルジャンドル多項式(Legendre polynomials)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       legendre(<span class="dt">unsigned</span> l, <span class="dt">double</span> x);
<span class="dt">float</span>        legendref(<span class="dt">unsigned</span> l, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  legendrel(<span class="dt">unsigned</span> l, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数l, xに対するルジャンドル多項式(Legendre polynomials)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{P}_\ell(x) =
  \frac{1}
       {2^\ell \, \ell!}
  \frac{ \mathsf{d} ^ \ell}
       { \mathsf{d}x ^ \ell} \, (x^2 - 1) ^ \ell,
       \quad \mbox{for $|x| \le 1$}
\]</span></p>
<p><span class="math inline">\(l\)</span>をl、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：l &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="sf.cmath.assoc_legendre">ルジャンドル陪関数(Associated Legendre functions)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      assoc_legendre(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">double</span> x);
<span class="dt">float</span>       assoc_legendref(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span> assoc_legendrel(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数l, m, xに対するルジャンドル陪関数(Associated Legendre functions)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{P}_\ell^m(x) =
  (1 - x^2) ^ {m/2}
  \:
  \frac{ \mathsf{d} ^ m}
       { \mathsf{d}x ^ m} \, \mathsf{P}_\ell(x),
       \quad \mbox{for $|x| \le 1$}
\]</span></p>
<p><span class="math inline">\(l\)</span>をl、<span class="math inline">\(m\)</span>をm、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：l &gt;= 128 のときの関数呼び出しの効果は実装定義である。</p>
<h2 id="球面ルジャンドル陪関数spherical-associated-legendre-functions">球面ルジャンドル陪関数(Spherical associated Legendre functions)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       sph_legendre(  <span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">double</span> theta);
<span class="dt">float</span>        sph_legendref( <span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">float</span> theta);
<span class="dt">long</span> <span class="dt">double</span>  sph_legendrel( <span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m,
                            <span class="dt">long</span> <span class="dt">double</span> theta);</code></pre></div>
<p>効果：実引数l, m, theta(thetaの単位はラジアン)に対する球面ルジャンドル陪関数(Spherical associated Legendre functions)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{Y}_\ell^m(\theta, 0)
\]</span></p>
<p>このとき、</p>
<p><span class="math display">\[
  \mathsf{Y}_\ell^m(\theta, \phi) =
  (-1)^m \left[ \frac{(2 \ell + 1)}
                     {4 \pi}
            \frac{(\ell - m)!}
                 {(\ell + m)!}
         \right]^{1/2}
     \mathsf{P}_\ell^m
     ( \cos\theta ) e ^ {i m \phi},
       \quad \mbox{for $|m| \le \ell$}
\]</span></p>
<p><span class="math inline">\(l\)</span>をl、<span class="math inline">\(m\)</span>をm、<span class="math inline">\(\theta\)</span>をthetaとする。</p>
<p>注意：l &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p>球面調和関数(Spherical harmonics) <span class="math inline">\(\mathsf{Y}_\ell^m(\theta, \phi)\)</span> は、以下のような関数を定義することによって計算できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span>
<span class="pp">#include </span><span class="im">&lt;complex&gt;</span>

<span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt;
spherical_harmonics(<span class="dt">unsigned</span> l, <span class="dt">unsigned</span> m, <span class="dt">double</span> theta, <span class="dt">double</span> phi)
{
    <span class="cf">return</span> <span class="bu">std::</span>sph_legendre(l, m, theta) * <span class="bu">std::</span>polar(<span class="fl">1.0</span>, m * phi) ;
}</code></pre></div>
<p><a href="#sf.cmath.assoc_legendre">ルジャンドル陪関数</a>も参照。</p>
<h2 id="エルミート多項式hermite-polynomials">エルミート多項式(Hermite polynomials)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       hermite(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        hermitef(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  hermitel(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数n, xに対するエルミート多項式(Hermite polynomials)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{H}_n(x) =
  (-1)^n e^{x^2} \frac{ \mathsf{d} ^n}
              { \mathsf{d}x^n} \, e^{-x^2}
\;
\]</span></p>
<p><span class="math inline">\(n\)</span>をn、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：n &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="ベータ関数beta-function">ベータ関数(Beta function)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      beta(<span class="dt">double</span> x, <span class="dt">double</span> y);
<span class="dt">float</span>       betaf(<span class="dt">float</span> x, <span class="dt">float</span> y);
<span class="dt">long</span> <span class="dt">double</span> betal(<span class="dt">long</span> <span class="dt">double</span> x, <span class="dt">long</span> <span class="dt">double</span> y);</code></pre></div>
<p>効果：実引数x, yに対するベータ関数(Beta function)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{B}(x, y) =
  \frac{ \Gamma(x) \, \Gamma(y) }
       { \Gamma(x+y) },
       \quad \mbox{for $x &gt; 0$,\, $y &gt; 0$}
\]</span></p>
<p><span class="math inline">\(x\)</span>をx、<span class="math inline">\(y\)</span>をyとする。</p>
<h2 id="第1種完全楕円積分complete-elliptic-integral-of-the-first-kind">第1種完全楕円積分(Complete elliptic integral of the first kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      comp_ellint_1(<span class="dt">double</span> k);
<span class="dt">float</span>       comp_ellint_1f(<span class="dt">float</span> k);
<span class="dt">long</span> <span class="dt">double</span> comp_ellint_1l(<span class="dt">long</span> <span class="dt">double</span> k);</code></pre></div>
<p>効果：実引数kに対する第1種完全楕円積分(Complete elliptic integral of the first kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{K}(k) =
  \mathsf{F}(k, \pi / 2),
              \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>をkとする。</p>
<p><a href="#sf.cmath.ellint_1">第1種不完全楕円積分</a>も参照。</p>
<h2 id="第2種完全楕円積分complete-elliptic-integral-of-the-second-kind">第2種完全楕円積分(Complete elliptic integral of the second kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      comp_ellint_2(<span class="dt">double</span> k);
<span class="dt">float</span>       comp_ellint_2f(<span class="dt">float</span> k);
<span class="dt">long</span> <span class="dt">double</span> comp_ellint_2l(<span class="dt">long</span> <span class="dt">double</span> k);</code></pre></div>
<p>効果：実引数kに対する第2種完全楕円積分(Complete elliptic integral of the second kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{E}(k) =
  \mathsf{E}(k, \pi / 2),
\quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>をkとする。</p>
<p><a href="#sf.cmath.ellint_2">第2種不完全楕円積分</a>も参照。</p>
<h2 id="第3種完全楕円積分complete-elliptic-integral-of-the-third-kind">第3種完全楕円積分(Complete elliptic integral of the third kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>      comp_ellint_3(<span class="dt">double</span> k, <span class="dt">double</span> nu);
<span class="dt">float</span>       comp_ellint_3f(<span class="dt">float</span> k, <span class="dt">float</span> nu);
<span class="dt">long</span> <span class="dt">double</span> comp_ellint_3l(<span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> nu);</code></pre></div>
<p>効果：実引数k, nuに対する第3種完全楕円積分(Complete elliptic integral of the third kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{\Pi}(\nu, k) = \mathsf{\Pi}(\nu, k, \pi / 2),
        \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>をk、<span class="math inline">\(\nu\)</span>をnuとする。</p>
<p><a href="#sf.cmath.ellint_3">第3種不完全楕円積分</a>も参照。</p>
<h2 id="sf.cmath.ellint_1">第1種不完全楕円積分(Incomplete elliptic integral of the first kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       ellint_1(<span class="dt">double</span> k, <span class="dt">double</span> phi);
<span class="dt">float</span>        ellint_1f(<span class="dt">float</span> k, <span class="dt">float</span> phi);
<span class="dt">long</span> <span class="dt">double</span>  ellint_1l(<span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> phi);</code></pre></div>
<p>効果：実引数k, phi(phiの単位はラジアン)に対する第1種不完全楕円積分(Incomplete elliptic integral of the first kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{F}(k, \phi) =
  \int_0^\phi \! \frac{\mathsf{d}\theta}
                      {\sqrt{1 - k^2 \sin^2 \theta}},
       \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>をk、<span class="math inline">\(\phi\)</span>をphiとする。</p>
<h2 id="sf.cmath.ellint_2">第2種不完全楕円積分(Incomplete elliptic integroal of the second kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       ellint_2(<span class="dt">double</span> k, <span class="dt">double</span> phi);
<span class="dt">float</span>        ellint_2f(<span class="dt">float</span> k, <span class="dt">float</span> phi);
<span class="dt">long</span> <span class="dt">double</span>  ellint_2l(<span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> phi);</code></pre></div>
<p>効果：実引数k, phi(phiの単位はラジアン)に対する第2種不完全楕円積分(Incomplete elliptic integral of the second kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{E}(k, \phi) =
  \int_0^\phi \! \sqrt{1 - k^2 \sin^2 \theta} \, \mathsf{d}\theta,
       \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(k\)</span>をk、<span class="math inline">\(\phi\)</span>をphiとする。</p>
<h2 id="sf.cmath.ellint_3">第3種不完全楕円積分(Incomplete elliptic integral of the third kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       ellint_3(  <span class="dt">double</span> k, <span class="dt">double</span> nu, <span class="dt">double</span> phi);
<span class="dt">float</span>        ellint_3f( <span class="dt">float</span> k, <span class="dt">float</span> nu, <span class="dt">float</span> phi);
<span class="dt">long</span> <span class="dt">double</span>  ellint_3l( <span class="dt">long</span> <span class="dt">double</span> k, <span class="dt">long</span> <span class="dt">double</span> nu,
                        <span class="dt">long</span> <span class="dt">double</span> phi);</code></pre></div>
<p>効果：実引数k, nu, phi(phiの単位はラジアン)に対する第3種不完全楕円積分(Incomplete elliptic integral of the third kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{\Pi}(\nu, k, \phi) =
  \int_0^\phi \! \frac{ \mathsf{d}\theta }
                      { (1 - \nu \, \sin^2 \theta) \sqrt{1 - k^2 \sin^2 \theta} },
       \quad \mbox{for $|k| \le 1$}
\]</span></p>
<p><span class="math inline">\(\nu\)</span>をnu、<span class="math inline">\(k\)</span>をk、<span class="math inline">\(\phi\)</span>をphiとする。</p>
<h2 id="sf.cmath.cyl_bessel_j">第1種ベッセル関数(Cylindrical Bessel functions of the first kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_bessel_j(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_bessel_jf(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_bessel_jl(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数nu, kに対する第1種ベッセル関数(Cylindrical Bessel functions of the first kind, Bessel functions of the first kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{J}_\nu(x) =
  \sum_{k=0}^\infty \frac{(-1)^k (x/2)^{\nu+2k}}
             {k! \: \Gamma(\nu+k+1)},
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(\nu\)</span>をnu、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：nu &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<h2 id="sf.cmath.cyl_neumann">ノイマン関数(Cylindrical Neumann functions)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_neumann(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_neumannf(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_neumannl(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数nu, xに対するノイマン関数(Cylindrical Neumann functions, Neumann functions)、またの名を第2種ベッセル関数(Cylindrical Bessel functions of the second kind, Bessel functions of the second kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{N}_\nu(x) =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \frac{\mathsf{J}_\nu(x) \cos \nu\pi - \mathsf{J}_{-\nu}(x)}
       {\sin \nu\pi },
  &amp; \mbox{for $x \ge 0$ and non-integral $\nu$}
  \\
  \\
  \displaystyle
  \lim_{\mu \rightarrow \nu} \frac{\mathsf{J}_\mu(x) \cos \mu\pi - \mathsf{J}_{-\mu}(x)}
                                {\sin \mu\pi },
  &amp; \mbox{for $x \ge 0$ and integral $\nu$}
  \end{array}
  \right.
\]</span></p>
<p><span class="math inline">\(\nu\)</span>をnu、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：nu &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>も参照。</p>
<h2 id="sf.cmath.cyl_bessel_i">第1種変形ベッセル関数(Regular modified cylindrical Bessel functions)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_bessel_i(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_bessel_if(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_bessel_il(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数nu, xに対する第1種変形ベッセル関数(Regular modified cylindrical Bessel functions, Modified Bessel functions of the first kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{I}_\nu(x) =
  \mathrm{i}^{-\nu} \mathsf{J}_\nu(\mathrm{i}x)
  =
  \sum_{k=0}^\infty \frac{(x/2)^{\nu+2k}}
             {k! \: \Gamma(\nu+k+1)},
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(\nu\)</span>をnu、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：nu &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>も参照。</p>
<h2 id="第2種変形ベッセル関数irregular-modified-cylindrical-bessel-functions">第2種変形ベッセル関数(Irregular modified cylindrical Bessel functions)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       cyl_bessel_k(<span class="dt">double</span> nu, <span class="dt">double</span> x);
<span class="dt">float</span>        cyl_bessel_kf(<span class="dt">float</span> nu, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  cyl_bessel_kl(<span class="dt">long</span> <span class="dt">double</span> nu, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数nu, xに対する第2種変形ベッセル関数(Irregular modified cylindrical Bessel functions, Modified Bessel functions of the second kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{K}_\nu(x) =
  (\pi/2)\mathrm{i}^{\nu+1} (            \mathsf{J}_\nu(\mathrm{i}x)
                + \mathrm{i} \mathsf{N}_\nu(\mathrm{i}x)
                )
  =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \frac{\pi}{2}
  \frac{\mathsf{I}_{-\nu}(x) - \mathsf{I}_{\nu}(x)}
       {\sin \nu\pi },
  &amp; \mbox{for $x \ge 0$ and non-integral $\nu$}
  \\
  \\
  \displaystyle
  \frac{\pi}{2}
  \lim_{\mu \rightarrow \nu} \frac{\mathsf{I}_{-\mu}(x) - \mathsf{I}_{\mu}(x)}
                                  {\sin \mu\pi },
  &amp; \mbox{for $x \ge 0$ and integral $\nu$}
  \end{array}
  \right.
\]</span></p>
<p><span class="math inline">\(\nu\)</span>をnu、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：nu &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_i">第1種変形ベッセル関数</a>、<a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>、<a href="#sf.cmath.cyl_neumann">ノイマン関数</a>も参照。</p>
<h2 id="第1種球ベッセル関数spherical-bessel-functions-of-the-first-kind">第1種球ベッセル関数(Spherical Bessel functions of the first kind)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       sph_bessel(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        sph_besself(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  sph_bessell(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数n, xに対する第1種球ベッセル関数(Spherical Bessel functions of the first kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{j}_n(x) =
  (\pi/2x)^{1\!/\!2} \mathsf{J}_{n + 1\!/\!2}(x),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p>注意： n &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_bessel_j">第1種ベッセル関数</a>も参照。</p>
<h2 id="球ノイマン関数spherical-neumann-functions">球ノイマン関数(Spherical Neumann functions)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       sph_neumann(<span class="dt">unsigned</span> n, <span class="dt">double</span> x);
<span class="dt">float</span>        sph_neumannf(<span class="dt">unsigned</span> n, <span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  sph_neumannl(<span class="dt">unsigned</span> n, <span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数n, xに対する球ノイマン関数(Spherical Neumann functions)、またの名を第2種球ベッセル関数(Spherical Bessel functions of the second kind)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{n}_n(x) =
  (\pi/2x)^{1\!/\!2} \mathsf{N}_{n + 1\!/\!2}(x),
       \quad \mbox{for $x \ge 0$}
\]</span></p>
<p><span class="math inline">\(n\)</span>をn、<span class="math inline">\(x\)</span>をxとする。</p>
<p>注意：n &gt;= 128 のときの関数の呼び出しの効果は実装定義である。</p>
<p><a href="#sf.cmath.cyl_neumann">ノイマン関数</a>も参照。</p>
<h2 id="指数積分exponential-integral">指数積分(Exponential integral)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       expint(<span class="dt">double</span> x);
<span class="dt">float</span>        expintf(<span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  expintl(<span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数xに対する指数積分(Exponential integral)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{Ei}(x) =
  - \int_{-x}^\infty \frac{e^{-t}}
                          {t     } \, \mathsf{d}t
\;
\]</span></p>
<p><span class="math inline">\(x\)</span>をxとする。</p>
<h2 id="リーマンゼータ関数riemann-zeta-function">リーマンゼータ関数(Riemann zeta function)</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>       riemann_zeta(<span class="dt">double</span> x);
<span class="dt">float</span>        riemann_zetaf(<span class="dt">float</span> x);
<span class="dt">long</span> <span class="dt">double</span>  riemann_zetal(<span class="dt">long</span> <span class="dt">double</span> x);</code></pre></div>
<p>効果：実引数xに対するリーマンゼータ関数(Riemann zeta function)を計算する。</p>
<p>戻り値：</p>
<p><span class="math display">\[
  \mathsf{\zeta}(x) =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \sum_{k=1}^\infty k^{-x},
  &amp; \mbox{for $x &gt; 1$}
  \\
  \\
  \displaystyle
  \frac{1}
    {1 - 2^{1-x}}
  \sum_{k=1}^\infty (-1)^{k-1} k^{-x},
  &amp; \mbox{for $0 \le x \le 1$}
  \\
  \\
  \displaystyle
  2^x \pi^{x-1} \sin(\frac{\pi x}{2}) \, \Gamma(1-x) \, \zeta(1-x),
  &amp; \mbox{for $x &lt; 0$}
  \end{array}
  \right.
\;
\]</span></p>
<p><span class="math inline">\(x\)</span>をxとする。</p>
<h1 id="その他の標準ライブラリ">その他の標準ライブラリ</h1>
<p>この章ではC++17で追加された細かいライブラリをまとめて解説する。</p>
<h2 id="ハードウェア干渉サイズキャッシュライン">ハードウェア干渉サイズ(キャッシュライン)</h2>
<p>C++17にはハードウェアの干渉サイズを取得するライブラリが入った。ハードウェアの干渉サイズとは、俗にキャッシュライン(cache line)とも呼ばれている概念だ。</p>
<p>残念ながら、この2017年では、メモリーは極めて遅い。そのため、プロセッサーはより高速にアクセスできるキャッシュメモリーを用意している。メモリーに対するキャッシュはある程度のまとまったバイト数単位で行われる。この単位が何バイトであるのかは実装依存だ。C++17にはこのサイズを取得できるライブラリが入った。</p>
<p>ハードウェア干渉サイズを知りたい理由は二つある。二つのオブジェクトを同一の局所性を持つキャッシュに載せたくない場合と載せたい場合だ。</p>
<p>二つのオブジェクトのうち、一方は頻繁に変更し、もう一方はめったに変更しない場合で、二つのオブジェクトが同じ局所性をもつキャッシュに載っている場合、よく変更するオブジェクトを変更しただけで、めったに変更しないオブジェクトも、メモリとの同期が発生する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Data
{
    <span class="dt">int</span> counter ;
    <span class="dt">int</span> status ;
} ;</code></pre></div>
<p>ここで、counterは頻繁に変更するが、statusはめったに変更しない場合、counterとstatusの間に適切なパディングを挿入することで、二つのオブジェクトが同じ局所性を持たないようにしたい。</p>
<p>この場合には、std::hardware_destructive_interference_sizeが使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Data
{
    <span class="dt">int</span> counter ;
    <span class="bu">std::</span>byte padding[
        <span class="bu">std::</span>hardware_destructive_interference_size - <span class="kw">sizeof</span>(<span class="dt">int</span>)
    ] ;
    <span class="dt">int</span> status ;
} ;</code></pre></div>
<p>反対に、二つのオブジェクトを同一の局所性を持つキャッシュに載せたい場合、std::hardware_constructive_interference_sizeが使える。</p>
<p>ハードウェア干渉サイズは&lt;new&gt;ヘッダーで以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span>
        hardware_destructive_interference_size = 実装依存 ;
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span>
        hardware_constructive_interference_size = 実装依存 ;
}</code></pre></div>
<h2 id="stduncaught_exceptions">std::uncaught_exceptions</h2>
<p>C++14までは、まだcatchされていない例外がある場合は、bool std::uncaught_exception()で判定することができた。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    {
        <span class="cf">if</span> ( <span class="bu">std::</span>uncaught_exception() )
        {
            <span class="co">// デストラクターはスタックアンワインディング中に呼ばれた。</span>
        }
        <span class="cf">else</span>
        {
            <span class="co">// 通常の破棄</span>
        }
    }
} ;

<span class="dt">int</span> main()
{
    {
        X x ;
    }<span class="co">// 通常の破棄</span>

    {
        X x ;
        <span class="cf">throw</span> <span class="dv">0</span> ;
    }<span class="co">// スタックアンワインディング中</span>

}</code></pre></div>
<p>bool std::uncaught_exception()は、C++17では非推奨扱いになった。いずれ廃止される見込みだ。</p>
<p>廃止の理由としては、単に以下のような例で役に立たないからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    {
        <span class="cf">try</span> {
            <span class="co">// true</span>
            <span class="dt">bool</span> b = <span class="bu">std::</span>uncaught_exception() ;
        } <span class="cf">catch</span>( ... ) { }
    }
} ;</code></pre></div>
<p>このため、int std::uncaught_exceptions()が新たに追加された。この関数は現在catchされていない例外の個数を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    {
        <span class="cf">try</span> {
            <span class="cf">if</span> ( <span class="dt">int</span> x = <span class="bu">std::</span>uncaught_exceptions() ; x &gt; <span class="dv">1</span> )
            {
                <span class="co">// ネストされた例外</span>
            }
        } <span class="cf">catch</span>( ... )
    }

} ;</code></pre></div>
<h2 id="apply-tupleの要素を実引数に関数を呼び出す">apply: tupleの要素を実引数に関数を呼び出す</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> F, <span class="kw">class</span> Tuple&gt;
<span class="kw">constexpr</span> <span class="kw">decltype</span>(<span class="kw">auto</span>) apply(F&amp;&amp; f, Tuple&amp;&amp; t);</code></pre></div>
<p>std::applyはtupleのそれぞれの要素を順番に実引数に渡して関数を呼び出すヘルパー関数だ。</p>
<p>ある要素数Nのtuple tと関数オブジェクトfに対して、apply( f, t )は、f( get&lt;0&gt;(t), get&lt;1&gt;(t), ... , get&lt;N-1&gt;(t) )のようにfを関数呼び出しする。</p>
<p>例</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> f( Types ... args ) { }

<span class="dt">int</span> main()
{
    <span class="co">// int, int, int</span>
    <span class="bu">std::</span>tuple t1( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> ) ;

    <span class="co">// f( 1, 2, 3 )の関数呼び出し</span>
    <span class="bu">std::</span>apply( f, t1 ) ;

    <span class="co">// int, double, const char *</span>
    <span class="bu">std::</span>tuple t2( <span class="dv">123</span>, <span class="fl">4.56</span>, <span class="st">&quot;hello&quot;</span> ) ;

    <span class="co">// f( 123, 4.56, &quot;hello&quot; )の関数呼び出し</span>
    <span class="bu">std::</span>apply( f, t2 ) ;
}</code></pre></div>
<h2 id="searcher-検索">Searcher : 検索</h2>
<p>C++17では&lt;functional&gt;にsearcherというライブラリが追加された。これは順序のあるオブジェクトの集合に、ある部分集合(パターン)が含まれているかどうかを検索するためのライブラリだ。その最も一般的な応用例は文字列検索となる。</p>
<p>searcherの基本的な設計としては、クラスのオブジェクトを構築して、コンストラクターで検索したい部分集合(パターン)を与え、operator ()で部分集合が含まれているかを検索したい集合を与える。</p>
<p>この設計のライブラリが追加された理由は、パターンの検索のために何らかの事前の準備を状態として保持しておきたい検索アルゴリズムを実装するためだ。</p>
<h3 id="default_searcher">default_searcher</h3>
<p>クラスstd::default_searcherは以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> ForwardIterator1,
            <span class="kw">class</span> BinaryPredicate = equal_to&lt;&gt; &gt;
<span class="kw">class</span> default_searcher {
<span class="kw">public</span>:
    <span class="co">// コンストラクター</span>
    default_searcher( 
        ForwardIterator1 pat_first, ForwardIterator1 pat_last
        , BinaryPredicate pred = BinaryPredicate() ) ;

    <span class="co">// operator ()</span>
    <span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator2&gt;
    pair&lt;ForwardIterator2, ForwardIterator2&gt;
    <span class="kw">operator</span>()(ForwardIterator2 first, ForwardIterator2 last) <span class="at">const</span> ;
} ;</code></pre></div>
<p>コンストラクターで部分集合を受け取る。operator ()で集合を受け取り、部分集合(パターン)と一致した場所をイテレーターのペアで返す。見つからない場合、イテレーターのペアは[last, last)になっている。</p>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string pattern(<span class="st">&quot;fox&quot;</span>) ;
    <span class="bu">std::</span>default_searcher
        fox_searcher( <span class="bu">std::</span>begin(pattern), <span class="bu">std::</span>end(pattern) ) ;

    <span class="bu">std::</span>string corpus = <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span> ;

    <span class="kw">auto</span>[first, last] = fox_searcher( <span class="bu">std::</span>begin(corpus),
                                      <span class="bu">std::</span>end(corpus) ) ;
    <span class="bu">std::</span>string fox( first, last ) ;
}</code></pre></div>
<p>default_searcherの検索は、内部的にstd::searchが使われる。</p>
<h3 id="boyer_moore_searcher">boyer_moore_searcher</h3>
<p>std::boyer_moore_searcherはBoyer-Moore文字列検索アルゴリズムを使って部分集合の検索を行う。</p>
<p>Boyer-Moore文字列検索アルゴリズムは極めて効率的な文字列検索のアルゴリズムだ。Boyer-MooreアルゴリズムはBob BoyerとStrother Mooreによって発明され、1977年のCommunications of the ACMで発表された。その内容は以下のURLで読むことができる。</p>
<p><a href="http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf" class="uri">http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf</a></p>
<p>愚直に実装した文字列検索アルゴリズムは検索すべき部分文字列(パターン)を検索対象の文字列(コーパス)から探す際、パターンの先頭の文字をコーパスの先頭から順に探していき、見つかれば2文字目以降も一致するかどうかを調べる。</p>
<p>Boyer-Mooreアルゴリズムはパターンの末尾の文字から調べる。文字が一致しなければ、パターンから絶対に不一致であると分かっている長さだけの文字を比較せずに読み飛ばす。これによって効率的な文字列検索を実現している。</p>
<p>Boyer-Mooreアルゴリズムは事前にパターンのどの文字が不一致ならば何文字比較せずに読み飛ばせるかという情報を計算した二つのテーブルを生成する必要がある。このため、Boyer-Mooreアルゴリズムはメモリ使用量と検索前の準備時間というコストがかかる。そのコストは、より効率的な検索により相殺できる。特に、パターンが長い場合は効果的だ。</p>
<p>C++17に入るBoyer_mooreアルゴリズムに基づく検索は、テンプレートを使った汎用的なchar型のような状態数の少ない型に対しての実装だけではなく、ハッシュを使ったハッシュマップのようなデータ構造を使うことにより、任意の型に対応できる汎用的な設計になっている。</p>
<p>クラスboyer_moore_searcherは以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;
    <span class="kw">class</span> RandomAccessIterator1,
    <span class="kw">class</span> Hash = hash&lt;
        <span class="kw">typename</span> iterator_traits&lt;RandomAccessIterator1&gt;::<span class="dt">value_type</span>&gt;,
    <span class="kw">class</span> BinaryPredicate = equal_to&lt;&gt; &gt;
<span class="kw">class</span> boyer_moore_searcher {
<span class="kw">public</span>:
    <span class="co">// コンストラクター</span>
    boyer_moore_searcher(
        RandomAccessIterator1 pat_first,
        RandomAccessIterator1 pat_last,
        Hash hf = Hash(),
        BinaryPredicate pred = BinaryPredicate() ) ;

    <span class="co">// operator ()</span>
    <span class="kw">template</span> &lt;<span class="kw">class</span> RandomAccessIterator2&gt;
    pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    <span class="kw">operator</span>()( RandomAccessIterator2 first,
                RandomAccessIterator2 last) <span class="at">const</span>;
} ;</code></pre></div>
<p>boyer_moore_searcherは、文字列以外にも適用できる汎用的な設計のため、ハッシュ関数を取る。char型のような取りうる状態数の少ない型以外が渡された場合は、std::unordered_mapのようなメモリ使用量を削減できる何らかのデータ構造を使ってテーブルを構築する。</p>
<p>使い方はdefault_searcherとほとんど変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string pattern(<span class="st">&quot;fox&quot;</span>) ;
    <span class="bu">std::</span>boyer_moore_searcher
        fox_searcher( <span class="bu">std::</span>begin(pattern), <span class="bu">std::</span>end(pattern) ) ;

    <span class="bu">std::</span>string corpus = <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span> ;

    <span class="kw">auto</span>[first, last] = fox_searcher( <span class="bu">std::</span>begin(corpus), <span class="bu">std::</span>end(corpus) ) ;
    <span class="bu">std::</span>string fox( first, last ) ;
}</code></pre></div>
<h3 id="boyer_moore_horspool_searcher">boyer_moore_horspool_searcher</h3>
<p>std::boyer_moore_horspool_searcherはBoyer-Moore-Horspool検索アルゴリズムを使って部分集合の検索を行う。Boyer_Moore-HorspoolアルゴリズムはNigel Horspoolによって1980年に発表された。</p>
<p>参考: &quot;Practical fast searching in strings&quot; 1980</p>
<p>Boyer-Moore-Horspoolアルゴリズムは内部テーブルに使うメモリー使用量を削減しているが、最悪計算量の点でオリジナルのBoyer-Mooreアルゴリズムには劣っている。つまり、実行時間の増大を犠牲にしてメモリ使用量を削減したトレードオフなアルゴリズムと言える。</p>
<p>クラスboyer_moore_horspool_searcherの宣言は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;
    <span class="kw">class</span> RandomAccessIterator1,
    <span class="kw">class</span> Hash = hash&lt;
        <span class="kw">typename</span> iterator_traits&lt;RandomAccessIterator1&gt;::<span class="dt">value_type</span>&gt;,
    <span class="kw">class</span> BinaryPredicate = equal_to&lt;&gt; &gt;
<span class="kw">class</span> boyer_moore_horspool_searcher {
<span class="kw">public</span>:
    <span class="co">// コンストラクター</span>
    boyer_moore_horspool_searcher(
        RandomAccessIterator1 pat_first,
        RandomAccessIterator1 pat_last,
        Hash hf = Hash(),
        BinaryPredicate pred = BinaryPredicate() );

    <span class="co">// operator () </span>
    <span class="kw">template</span> &lt;<span class="kw">class</span> RandomAccessIterator2&gt;
    pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    <span class="kw">operator</span>()( RandomAccessIterator2 first,
                RandomAccessIterator2 last) <span class="at">const</span>;
} ;</code></pre></div>
<p>使い方はboyer_moore_horspool_searcherと変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string pattern(<span class="st">&quot;fox&quot;</span>) ;
    <span class="bu">std::</span>boyer_moore_horspool_searcher
        fox_searcher( <span class="bu">std::</span>begin(pattern), <span class="bu">std::</span>end(pattern) ) ;

    <span class="bu">std::</span>string corpus = <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span> ;

    <span class="kw">auto</span>[first, last] = fox_searcher(   <span class="bu">std::</span>begin(corpus),
                                        <span class="bu">std::</span>end(corpus) ) ;
    <span class="bu">std::</span>string fox( first, last ) ;
}</code></pre></div>
<h2 id="sample-乱択アルゴリズム">sample: 乱択アルゴリズム</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;

SampleIterator sample(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g) ;</code></pre></div>
<p>C++17で&lt;algorithm&gt;に追加されたstd::sampleは、標本を確率的に選択するための乱択アルゴリズムだ。</p>
<p>[first, last)は標本を選択する先の集合を指すイテレーター。outは標本を出力する先のイテレーター。nは選択する標本の個数。gは標本を選択するのに使う乱数生成器。戻り値はout。</p>
<p>ある要素の集合から、n個の要素を確率的に公平に選択したい場合に使うことができる。</p>
<h3 id="乱択アルゴリズム">乱択アルゴリズム</h3>
<p>std::sampleを使う前に、まず正しい乱択アルゴリズムについて学ぶ必要がある。乱択アルゴリズムについて詳しくは、Donald E. KnuthのThe Arf of Computer Programming(以下TAOCP、邦訳はアスキードワンゴから同名の書名で出版されている)を参照。</p>
<p>ユーザーからの入力、計測した気象情報のデータ、サーバーへのアクセスログなど、世の中には膨大な量のデータが存在する。これらの膨大なデータをすべて処理するのではなく、標本を採取することによって、統計的にそれなりに信頼できる確率で正しい全体のデータを推定することができる。そのためにはn個の標本をバイアスがかからない方法で選択する必要がある。バイアスのかからない方法でn個の標本を取り出すには、集合の先頭からn個とか、一つおきにn個といった方法で選択してはならない。それはバイアスがかかっている。</p>
<p>ある値の集合から、バイアスのかかっていないn個の標本を得るには、集合のすべての値が等しい確率で選ばれた上でn個を選択しなければならない。一体どうすればいいのだろうか。</p>
<p>std::sampleを使えば、100個の値から10個の標本を得るのは、以下のように書くことが可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 100個の値の集合</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; pop(<span class="dv">100</span>) ;
    <span class="bu">std::</span>iota( <span class="bu">std::</span>begin(pop), <span class="bu">std::</span>end(pop), <span class="dv">0</span> ) ;

    <span class="co">// 標本を格納するコンテナー</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; out(<span class="dv">10</span>) ;

    <span class="co">// 乱数生成器</span>
    <span class="bu">std::</span>array&lt;<span class="bu">std::</span>uint32_t, <span class="kw">sizeof</span>(<span class="bu">std::</span>knuth_b)/<span class="dv">4</span>&gt; a ;
    <span class="bu">std::</span>random_device r ;
    <span class="bu">std::</span>generate( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a), [&amp;]{ <span class="cf">return</span> r() ; } ) ;
    <span class="bu">std::</span>seed_seq seed( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a) ) ;
    <span class="bu">std::</span>knuth_b g( seed ) ;

    <span class="co">// 10個の標本を得る。</span>
    sample( <span class="bu">std::</span>begin(pop), <span class="bu">std::</span>end(pop), <span class="bu">std::</span>begin(out), <span class="dv">10</span>, g ) ;

    <span class="co">// 標本を出力</span>
    <span class="bu">std::</span>copy(  <span class="bu">std::</span>begin(out), <span class="bu">std::</span>end(out),
                <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;, &quot;</span>) ) ;
}</code></pre></div>
<p>集合に含まれる値の数がN個だと分かっているならば、それぞれの値について<span class="math inline">\(n/m\)</span>の確率で選ぶというのはどうだろうか。100個中10個を選ぶのであれば、<span class="math inline">\(1/10\)</span>の確率でそれぞれの値を標本として選択することになる。</p>
<p>この考えに基づく乱択アルゴリズムは以下のようになる。</p>
<ol style="list-style-type: decimal">
<li>集合の要素数をN、選択すべき標本の数をn、iを0とする。</li>
<li>0ベースインデックスでi番目の値を<span class="math inline">\(n/m\)</span>の確率で標本として選択する</li>
<li>iをインクリメントする</li>
<li>i != Nならばgoto 2.</li>
</ol>
<p>このアルゴリズムをコードで書くと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator sample(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    <span class="kw">auto</span> N = <span class="bu">std::</span>distance( first, last ) ;

    <span class="co">// 確率n/Nでtrueを返すベルヌーイ分布</span>
    <span class="dt">double</span> probability = <span class="dt">double</span>(n)/<span class="dt">double</span>(N) ;
    <span class="bu">std::</span>bernoulli_distribution d( probability ) ;

    <span class="co">// それぞれの値に対して</span>
    <span class="bu">std::</span>for_each( first, last,
        [&amp;]( <span class="kw">auto</span> &amp;&amp; value )
        {
            <span class="cf">if</span> ( d(g) )
            {<span class="co">// n/Nの確率で標本として選択する</span>
                *out = value ;
                ++out ;
            }
        } ) ;

    <span class="cf">return</span> out ;
}</code></pre></div>
<p>残念ながらこのアルゴリズムは正しく動かない。この例では、100個の値の集合から10個の標本を選択したい。しかし、選ばれる標本の数はプログラムの実行ごとに異なる。このアルゴリズムは、標本の数が平均的に10個選ばれることが期待できるが、運が悪いと0個や100個の標本が選ばれてしまう可能性がある。</p>
<p>ちなみに、TAOCP Vol.2によれば、このとき選ばれる標本数の標準偏差は<span class="math inline">\(\sqrt{n(1-n/N)}\)</span>になる。</p>
<p>正しいアルゴリズムは、要素の集合のうちの<span class="math inline">\((t+1)\)</span>番目の要素は、すでにm個の要素が標本として選ばれたとき、<span class="math inline">\((n-m)(N-t)\)</span>の確率で選ぶものだ。</p>
<h3 id="アルゴリズムs選択標本要素数が分かっている集合からの標本の選択">アルゴリズムS：選択標本、要素数が分かっている集合からの標本の選択</h3>
<p>KnuthのTAOCP Vol.2では、アルゴリズムSと称して、要素数の分かっている集合から標本を選択する方法を解説している。</p>
<p>アルゴリズムRは以下の通り。</p>
<p><span class="math inline">\(0 &lt; n \leq N\)</span> のとき、N個の集合からn個の標本をランダムに選択する。</p>
<ol style="list-style-type: decimal">
<li>t, mを0とする。tはこれまでに処理した要素数、mは標本として選択した要素数とする。</li>
<li><span class="math inline">\(0 \leq U \leq N - t\)</span>の範囲の乱数Uを生成する</li>
<li><span class="math inline">\(U \geq n - m\)</span>であればgoto 5.</li>
<li>次の要素を標本として選択する。mとtをインクリメントする。<span class="math inline">\(m &lt; n\)</span>であれば、goto 2. そうでなければ標本は完了したのでアルゴリズムは終了する</li>
<li>次の要素を標本として選択しない。tをインクリメントする。goto 2.</li>
</ol>
<p>実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator
sample_s(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    <span class="co">// 1.</span>
    Distance t = <span class="dv">0</span> ;
    Distance m = <span class="dv">0</span> ;
    <span class="at">const</span> <span class="kw">auto</span> N = <span class="bu">std::</span>distance( first, last ) ;

    <span class="kw">auto</span> r = [&amp;]{
        <span class="bu">std::</span>uniform_int_distribution&lt;&gt; d(<span class="dv">0</span>, N-t) ;
        <span class="cf">return</span> d(g) ;
    } ;

    <span class="cf">while</span> ( m &lt; n  &amp;&amp; first != last )
    {
        <span class="co">// 2. 3.</span>
        <span class="cf">if</span> ( r() &gt;= n - m )
        {<span class="co">// 5.</span>
            ++t ;
            ++first ;
        }
        <span class="cf">else</span> { <span class="co">// 4.</span>
            *out = *first ;
            ++first ; ++out ;
            ++m ; ++t ;
        }
    }
    
    <span class="cf">return</span> out ;
}</code></pre></div>
<h3 id="アルゴリズムr保管標本要素数がわからない集合からの標本の選択">アルゴリズムR：保管標本、要素数がわからない集合からの標本の選択</h3>
<p>アルゴリズムSは集合の要素数がN個であると分かっている場合に、n個の標本を選択するアルゴリズムだ。では、もしNがわからない場合はどうすればいいのだろうか。</p>
<p>現実にはNがわからない状況がよくある。</p>
<ul>
<li>ユーザーからの入力</li>
<li>シーケンシャルアクセスしか提供しておらず全部読み込まなければ要素数のわからないテープデバイスからの入力</li>
<li>ガイガーカウンターからの入力</li>
</ul>
<p>このような要素数のわからない入力にアルゴリズムSを適用するには、まず一度全部入力を得て、全体の要素数を確定させた上で、全要素に対してアルゴリズムSを適用させるという2段階の方法を使うことができる。</p>
<p>しかし、1段階の要素の巡回だけで済ませたい。要素数のわからない入力を処理して、その時点で公平に選択された標本を得たい。</p>
<p>アルゴリズムRはそのような状況で使えるアルゴリズムだ。</p>
<p>アルゴリズムRでは、要素数のわからない要素の集合からn個の標本を選択する。そのために標本として選択した要素を保管しておき、新しい入力が与えられるたびに、標本として選択するかどうかの判断をし、選択をするのであれば、保管しておいた既存の標本と置き換える。</p>
<p>アルゴリズムRは以下の通り(このアルゴリズムはknuth本とは違う)</p>
<p><span class="math inline">\(n &gt; 0\)</span>のとき、<span class="math inline">\(size \geq n\)</span>である未確定のsize個の要素数をもつ入力から、n個の標本をランダムに選択する。標本の候補はn個まで保管される。<span class="math inline">\(1 \leq j \leq n\)</span>のときI[j]は保管された標本を指す。</p>
<ol style="list-style-type: decimal">
<li>入力から最初のn個を標本として選択し、保管する。<span class="math inline">\(1 \leq j \leq n\)</span>の範囲でI[j]にj番目の標本を保管する。tの値をnとする。I[1], ..., I[n]は現在の標本を指す。tは現在処理した入力の個数を指す。</li>
<li>入力の終わりであればアルゴリズムを終了する。</li>
<li>tをインクリメントする。<span class="math inline">\(1 \leq M \leq t\)</span>の範囲の乱数Mを生成する。<span class="math inline">\(M &gt; n\)</span> ならばgoto 5.</li>
<li>次の入力をI[M]に保管する。goto 2.</li>
<li>次の入力を保管しない。goto 2.</li>
</ol>
<p>実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;

SampleIterator sample_r(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    Distance t = <span class="dv">0</span> ;

    <span class="kw">auto</span> result = out ;

    <span class="cf">for</span> ( ; (first != last) &amp;&amp; (t != n) ; ++first, ++t, ++result )
    {
        out[t] = *first ;
    }

    <span class="cf">if</span> ( t != n )
        <span class="cf">return</span> result ;


    <span class="kw">auto</span> I = [&amp;](Distance j) -&gt; <span class="kw">decltype</span>(<span class="kw">auto</span>) { <span class="cf">return</span> out[j<span class="dv">-1</span>] ; } ;

    <span class="cf">while</span> ( first != last )
    {
        ++t ;
        <span class="bu">std::</span>uniform_int_distribution&lt;Distance&gt; d( <span class="dv">1</span>, t ) ;
        <span class="kw">auto</span> M = d(g) ;

        <span class="cf">if</span> ( M &gt; n )
        {
            ++first ;
        }
        <span class="cf">else</span> {
            I(M) = *first ;
            ++first ;
        }
    }

    <span class="cf">return</span> result ;
}</code></pre></div>
<h3 id="cのsample">C++のsample</h3>
<p>ここまで説明したように、乱択アルゴリズムには2種類ある。入力の要素数が分かっている場合のアルゴリズムS(選択標本)と、入力の要素数がわからない場合のアルゴリズムR(保管標本)だ。</p>
<p>しかし、C++に追加された乱択アルゴリズムの関数テンプレートの宣言は、はじめに説明したように以下の一つしかない。並列アルゴリズムには対応していない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;
    <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
    <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator
sample(
    PopulationIterator first, PopulationIterator last,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g) ;</code></pre></div>
<p>[first, last)は標本を選択する先の集合を指すイテレーター。outは標本を出力する先のイテレーター。nは選択する標本の個数。gは標本を選択するのに使う乱数生成器。戻り値はout。</p>
<p>sampleはPopulationIteratorとSampleIteratorのイテレーターカテゴリーによって、どちらのアルゴリズムを使うべきか判断している。</p>
<p>アルゴリズムS(選択標本)を使う場合、PopulationIteratorは前方イテレーター、SampleIteratorは出力イテレーターを満たさなければならない。</p>
<p>アルゴリズムR(保管標本)を使う場合、PopulationIteratorは入力イテレーター、SampleIteratorはランダムアクセスイテレーターを満たさなければならない。</p>
<p>これはどういうことかというと、要素数の取得のためには、入力元のPopulationIterator [first, last)から要素数を得る必要があり、そのためにはPopulationIteratorは前方イテレーターを満たしていなければならない。その場合、選択した標本はそのままイテレーターに出力すればいいので、出力先のSampleIteratorは出力イテレーターを満たすだけでよい。</p>
<p>もし入力元のPopulationIteratorが入力イテレーターしか満たさない場合、この場合はPopulationIteratorの[first, last)から要素数を得ることができないので、要素数がわからないときに使えるアルゴリズムR(保管標本)を選択せざるを得ない。その場合、入力を処理するに連れて、新たに選択した標本が既存の標本を上書きするので、出力先のSampleIteratorはランダムアクセスイテレーターである必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; input ;

    <span class="bu">std::</span>knuth_b g ;

    <span class="co">// PopulationIteratorは前方イテレーターを満たす</span>
    <span class="co">// SampleIteratorは出力イテレーターでよい</span>
    <span class="bu">std::</span>sample(    <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
                    <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout), <span class="dv">100</span>
                    g ) ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; sample(<span class="dv">100</span>) ;

    <span class="co">// PopulationIteratorは入力イテレーターしか満たさない</span>
    <span class="co">// SampleIteratorにはランダムアクセスイテレーターが必要</span>
    <span class="bu">std::</span>sample(
        <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin),
        <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;{},
        <span class="bu">std::</span>begin(sample), <span class="dv">100</span>, g ) ;

}</code></pre></div>
<p>注意が必要なこととして、C++のsampleは入力元のPopulationIteratorが前方イテレーター以上を満たす場合は、かならずアルゴリズムS(選択標本)を使うということだ。これはつまり、要素数を得るためにstd::distance(first, last)が行われるということを意味する。もしこの処理が非効率的なイテレーターを渡した場合、必要以上に非効率的なコードになってしまう。</p>
<p>例えば以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; input(<span class="dv">10000</span>) ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; sample(<span class="dv">100</span>) ;
    <span class="bu">std::</span>knuth_b g ;

    <span class="bu">std::</span>sample(    <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
                    <span class="bu">std::</span>begin(sample), <span class="dv">100</span>, g ) ;
}</code></pre></div>
<p>以下のような意味を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; input(<span class="dv">10000</span>) ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; sample(<span class="dv">100</span>) ;
    <span class="bu">std::</span>knuth_b g ;

    <span class="bu">std::</span>size_t count = <span class="dv">0</span> ;
    
    <span class="co">// 要素数の得るためにイテレーターを回す</span>
    <span class="co">// 非効率的</span>
    <span class="cf">for</span>( <span class="kw">auto</span> &amp;&amp; e : input )
    { ++count ; }

    <span class="co">// 標本の選択のためにイテレーターを回す</span>
    <span class="cf">for</span> ( <span class="kw">auto</span> &amp;&amp; e : input )
    {<span class="co">/* 標本の選択 */</span>}
}</code></pre></div>
<p>std::listのメンバー関数sizeは定数時間であることが保障されているため、このコードにおけるイテレーターを回すループは一回に抑えられる。しかし、std::sampleは要素数を渡す実引数がないために要素数がイテレーターを全走査しなくても分かっている場合でも、非効率的な処理を行わなければならない。</p>
<p>もしランダムアクセスイテレーター未満、前方イテレーター以上のイテレーターカテゴリーのイテレーターの範囲から標本を選択したい場合で、イテレーターの範囲の指す要素数が予め分かっている場合は、自前でアルゴリズムSを実装したほうが効率がよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;  <span class="kw">class</span> PopulationIterator, <span class="kw">class</span> SampleIterator,
            <span class="kw">class</span> Distance, <span class="kw">class</span> UniformRandomBitGenerator &gt;
SampleIterator
sample_s(
    PopulationIterator first, PopulationIterator last,
    Distance size,
    SampleIterator out,
    Distance n, UniformRandomBitGenerator&amp;&amp; g)
{
    <span class="co">// 1.</span>
    Distance t = <span class="dv">0</span> ;
    Distance m = <span class="dv">0</span> ;
    <span class="at">const</span> <span class="kw">auto</span> N = size ;

    <span class="kw">auto</span> r = [&amp;]{
        <span class="bu">std::</span>uniform_int_distribution&lt;&gt; d(<span class="dv">0</span>, N-t) ;
        <span class="cf">return</span> d(g) ;
    } ;

    <span class="cf">while</span> ( m &lt; n  &amp;&amp; first != last )
    {
        <span class="co">// 2. 3.</span>
        <span class="cf">if</span> ( r() &gt;= n - m )
        {<span class="co">// 5.</span>
            ++t ;
            ++first ;
        }
        <span class="cf">else</span> { <span class="co">// 4.</span>
            *out = *first ;
            ++first ; ++out ;
            ++m ; ++t ;
        }
    }
    
    <span class="cf">return</span> out ;
}</code></pre></div>
<h2 id="shared_ptrt-配列に対するshared_ptr">shared_ptr&lt;T[]&gt; : 配列に対するshared_ptr</h2>
<p>C++17では、shared_ptrが配列に対応した。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 配列対応のshared_ptr</span>
    <span class="bu">std::</span>shared_ptr&lt; <span class="dt">int</span> [] &gt; ptr( <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">5</span>] ) ;

    <span class="co">// operator []で配列に添字アクセスできる</span>
    ptr[<span class="dv">0</span>] = <span class="dv">42</span> ;

    <span class="co">// shared_ptrのデストラクターがdelete[]を呼び出す</span>
}</code></pre></div>
<h2 id="as_const-const性の付与">as_const: const性の付与</h2>
<p>as_constはヘッダーファイル&lt;utility&gt;で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt; <span class="kw">constexpr</span> <span class="dt">add_const_t</span>&lt;T&gt;&amp; as_const(T&amp; t) <span class="kw">noexcept</span>
{
    <span class="cf">return</span> t ;
}</code></pre></div>
<p>as_constは引数として渡したlvalueリファレンスをconstなlvalueリファレンスにキャストする関数だ。const性を付与する手軽なヘルパー関数として使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp; ) {}
<span class="co">// 2、こちらを呼び出したい</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="at">const</span> &amp; ) { }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> x{} ;

    f(x) ; <span class="co">// 1</span>

    <span class="co">// constを付与する冗長な方法</span>
    <span class="dt">int</span> <span class="at">const</span> &amp; ref = x ;
    f(ref) ; <span class="co">// 2</span>

    <span class="co">// 簡潔</span>
    f( <span class="bu">std::</span>as_const(x) ) ; <span class="co">// 2</span>
}</code></pre></div>
<h2 id="make_from_tuple-tupleの要素を実引数にコンストラクターを呼び出す">make_from_tuple : tupleの要素を実引数にコンストラクターを呼び出す</h2>
<p>make_from_tupleはヘッダーファイル&lt;tuple&gt;で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> Tuple&gt;
<span class="kw">constexpr</span> T make_from_tuple(Tuple&amp;&amp; t);</code></pre></div>
<p>applyはtupleの要素を実引数に関数を呼び出すライブラリだが、make_from_tupleはtupleの要素を実引数にコンストラクターを呼び出すライブラリだ。</p>
<p>ある型Tと要素数Nのtuple tに対して、make_from_tuple&lt;T&gt;(t)は、T型をT( get&lt;0&gt;(t), get&lt;1&gt;(t), ... , get&lt;N-1&gt;(t) )のように構築して、構築したT型のオブジェクトを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X
{
    <span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
    T( Types ... ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// int, int, int</span>
    <span class="bu">std::</span>tuple t1(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) ;

    <span class="co">// X(1,2,3)</span>
    X x1 = <span class="bu">std::</span>make_from_tuple&lt;X&gt;( t1 ) 

    <span class="co">// int, double, const char *</span>
    <span class="bu">std::</span>tuple t2( <span class="dv">123</span>, <span class="fl">4.56</span>, <span class="st">&quot;hello&quot;</span> ) ;

    <span class="co">// X(123, 4.56, &quot;hello&quot;)</span>
    X x2 = <span class="bu">std::</span>make_from_tuple&lt;X&gt;( t2 ) ;
}</code></pre></div>
<h2 id="invoke-指定した関数を指定した実引数で呼び出す">invoke : 指定した関数を指定した実引数で呼び出す</h2>
<p>invokeはヘッダーファイル&lt;functional&gt;で定義されている</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> F, <span class="kw">class</span>... Args&gt;
<span class="dt">invoke_result_t</span>&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)
<span class="kw">noexcept</span>(is_nothrow_invocable_v&lt;F, Args...&gt;);</code></pre></div>
<p>invoke( f, t1, t2, ... , tN )は、関数fをf( a1, a2, ... , aN )のように呼び出す。</p>
<p>より正確には、C++標準規格のINVOKE(f, t1, t2, ... , tN)と同じ規則で呼び出す。これには様々な規則があり、たとえばメンバー関数へのポインターやデータメンバーへのポインター、またその場合に与えるクラスへのオブジェクトがリファレンスかポインターかreference_wrapperかによっても異なる。その詳細はここでは解説しない。</p>
<p>INVOKEはstd::functionやstd::bindでも使われている規則なので、標準ライブラリと同じ挙動ができるようになると覚えておけばよい。</p>
<p>例</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> ) { }

<span class="kw">struct</span> S
{
    <span class="dt">void</span> f( <span class="dt">int</span> ) ;
    <span class="dt">int</span> data ;
} ;

<span class="dt">int</span> main()
{
    <span class="co">// f( 1 ) </span>
    <span class="bu">std::</span>invoke( f, <span class="dv">1</span> ) ;

    S s ;

    <span class="co">// (s.*&amp;S::f)(1)</span>
    <span class="bu">std::</span>invoke( &amp;S::f, s, <span class="dv">1</span> ) ;
    <span class="co">// ((*&amp;s).*&amp;S::f)(1)</span>
    <span class="bu">std::</span>invoke( &amp;S::f, &amp;s, <span class="dv">1</span> ) ;
    <span class="co">// s.*&amp;S::data </span>
    <span class="bu">std::</span>invoke( &amp;S::data, s ) ;
}</code></pre></div>
<h2 id="not_fn-戻り値の否定ラッパー">not_fn : 戻り値の否定ラッパー</h2>
<p>not_fnはヘッダーファイル&lt;functional&gt;で定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> F&gt; unspecified not_fn(F&amp;&amp; f);</code></pre></div>
<p>関数オブジェクトfに対してnot_fn(f)を呼び出すと、戻り値として何らかの関数オブジェクトが帰ってくる。その関数オブジェクトを呼び出すと、実引数をfに渡してfを関数呼び出しして、戻り値をoperator !で否定して返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="kw">auto</span> r1 = <span class="bu">std::</span>not_fn( []{ <span class="cf">return</span> <span class="kw">true</span> ; } ) ;

    r1() ; <span class="co">// false</span>

    <span class="kw">auto</span> r2 = <span class="bu">std::</span>not_fn( []( <span class="dt">bool</span> b ) { <span class="cf">return</span> b ; } ) ;

    r2(<span class="kw">true</span>) ; <span class="co">// false</span>
}</code></pre></div>
<p>すでに廃止予定になったnot1, not2の代替品。</p>
<h2 id="メモリー管理アルゴリズム">メモリー管理アルゴリズム</h2>
<p>C++17ではヘッダーファイル&lt;memory&gt;にメモリー管理用のアルゴリズムが追加された。</p>
<h3 id="addressof">addressof</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt; <span class="kw">constexpr</span> T* addressof(T&amp; r) <span class="kw">noexcept</span>;</code></pre></div>
<p>addressofはC++17以前からもある。addressof(r)はrのポインターを取得する。たとえ、rの型がoperator &amp;をオーバーロードしていても正しいポインターを取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    S * <span class="kw">operator</span> &amp;() <span class="at">const</span> <span class="kw">noexcept</span>
    { <span class="cf">return</span> <span class="kw">nullptr</span> ; } 
} ;

<span class="dt">int</span> main()
{
    S s ;

    <span class="co">// nullptr</span>
    S * p1 = &amp; s ;
    <span class="co">// 妥当なポインター</span>
    S * p2 = <span class="bu">std::</span>addressof(s) ;

}</code></pre></div>
<h3 id="uninitialized_default_construct">uninitialized_default_construct</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator&gt;
<span class="dt">void</span> uninitialized_default_construct(
    ForwardIterator first, ForwardIterator last);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size&gt;
ForwardIterator uninitialized_default_construct_n(
    ForwardIterator first, Size n);</code></pre></div>
<p>[first, last)の範囲、もしくはfirstからn個の範囲の未初期化のメモリーをtypename iterator_traits&lt;ForwardIterator&gt;::value_typeでデフォルト初期化する。2つめのアルゴリズムはfirstからn個をデフォルト初期化する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>shared_ptr&lt;<span class="dt">void</span>&gt; raw_ptr
    (   ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(<span class="bu">std::</span>string) * <span class="dv">10</span> ),
        [](<span class="dt">void</span> * ptr){ ::<span class="kw">operator</span> <span class="kw">delete</span>(ptr) ; } ) ;
 
    <span class="bu">std::</span>string * ptr = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>string *&gt;( raw_ptr.get() ) ;

    <span class="bu">std::</span>uninitialized_default_construct_n( ptr, <span class="dv">10</span> ) ;
    <span class="bu">std::</span>destroy_n( ptr, <span class="dv">10</span> ) ;
}</code></pre></div>
<h3 id="uninitialized_value_construct">uninitialized_value_construct</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator&gt;
<span class="dt">void</span> uninitialized_value_construct(
    ForwardIterator first, ForwardIterator last);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size&gt;
ForwardIterator uninitialized_value_construct_n(
    ForwardIterator first, Size n);</code></pre></div>
<p>使い方はuninitialized_default_constructと同じ。ただし、こちらはデフォルト初期化ではなく値初期化する。</p>
<h3 id="uninitialized_copy">uninitialized_copy</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> ForwardIterator&gt;
ForwardIterator
uninitialized_copy( InputIterator first, InputIterator last,
                    ForwardIterator result);

<span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Size, <span class="kw">class</span> ForwardIterator&gt;
ForwardIterator
uninitialized_copy_n(   InputIterator first, Size n,
                        ForwardIterator result);</code></pre></div>
<p>[first, last)の範囲、もしくはfirstからn個の範囲の値を、resultの指す未初期化のメモリーにコピー構築する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; input(<span class="dv">10</span>, <span class="st">&quot;hello&quot;</span>) ;

    <span class="bu">std::</span>shared_ptr&lt;<span class="dt">void</span>&gt; raw_ptr
    (   ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(<span class="bu">std::</span>string) * <span class="dv">10</span> ),
        [](<span class="dt">void</span> * ptr){ ::<span class="kw">operator</span> <span class="kw">delete</span>(ptr) ; } ) ;
 
    <span class="bu">std::</span>string * ptr = <span class="kw">static_cast</span>&lt;<span class="bu">std::</span>string *&gt;( raw_ptr.get() ) ;


    <span class="bu">std::</span>uninitialized_copy_n( <span class="bu">std::</span>begin(input), <span class="dv">10</span>, ptr ) ;
    <span class="bu">std::</span>destroy_n( ptr, <span class="dv">10</span> ) ;
}</code></pre></div>
<h3 id="uninitialized_move">uninitialized_move</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> ForwardIterator&gt;
ForwardIterator
uninitialized_move( InputIterator first, InputIterator last,
                    ForwardIterator result);

<span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Size, <span class="kw">class</span> ForwardIterator&gt;
pair&lt;InputIterator, ForwardIterator&gt;
uninitialized_move_n(   InputIterator first, Size n,
                        ForwardIterator result);</code></pre></div>
<p>使い方はuninitialized_copyと同じ。ただしこちらはコピーではなくムーブする。</p>
<h3 id="uninitialized_fill">uninitialized_fill</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> T&gt;
<span class="dt">void</span> uninitialized_fill(
    ForwardIterator first, ForwardIterator last,
    <span class="at">const</span> T&amp; x);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size, <span class="kw">class</span> T&gt;
ForwardIterator uninitialized_fill_n(
    ForwardIterator first, Size n,
    <span class="at">const</span> T&amp; x);</code></pre></div>
<p>[first, last)の範囲、もしくはfirstからn個の範囲の未初期化のメモリーを、コンストラクターに実引数xを与えて構築する。</p>
<h3 id="destory">destory</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="dt">void</span> destroy_at(T* location);</code></pre></div>
<p>location-&gt;~T()を呼び出す</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator&gt;
<span class="dt">void</span> destroy(ForwardIterator first, ForwardIterator last);

<span class="kw">template</span> &lt;<span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Size&gt;
ForwardIterator destroy_n(ForwardIterator first, Size n);</code></pre></div>
<p>[first, last)の範囲、もしくはfirstからn個の範囲にdestroy_atを呼び出す。</p>
<h2 id="shared_ptrweak_type">shared_ptr::weak_type</h2>
<p>C++17ではshared_ptrにweak_typeというネストされた型名が追加された。これはshared_ptrに対するweak_ptrのtypedef名となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> shared_ptr
{
    <span class="kw">using</span> <span class="dt">weak_type</span> = weak_ptr&lt;T&gt; ;
} ;

}</code></pre></div>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Shared_ptr &gt;
<span class="dt">void</span> f( Shared_ptr sptr )
{
    <span class="co">// C++14</span>
    <span class="kw">auto</span> wptr1 = <span class="bu">std::</span>weak_ptr&lt;
                    <span class="kw">typename</span> Shared_ptr::<span class="dt">element_type</span>
                &gt;( sptr ) ;

    <span class="co">// C++17</span>
    <span class="kw">auto</span> wptr2 = <span class="kw">typename</span> Shared_ptr::<span class="dt">weak_type</span>( sptr ) ;
}</code></pre></div>
<h2 id="void_t">void_t</h2>
<p>ヘッダーファイル&lt;type_traits&gt;で定義されているvoid_tは以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {

<span class="kw">template</span> &lt; <span class="kw">class</span> ... &gt;
<span class="kw">using</span> <span class="dt">void_t</span> = <span class="dt">void</span> ;

}</code></pre></div>
<p>void_tは任意個の型をテンプレート実引数として受け取るvoid型だ。この性質はテンプレートメタプログラミングにおいてとても便利なので、標準ライブラリに追加された。</p>
<h2 id="bool_constant">bool_constant</h2>
<p>ヘッダーファイル&lt;type_traits&gt;にbool_constantが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">bool</span> B&gt;
<span class="kw">using</span> bool_constant = integral_constant&lt;<span class="dt">bool</span>, B&gt;;

<span class="kw">using</span> <span class="dt">true_type</span> = bool_constant&lt;<span class="kw">true</span>&gt;;
<span class="kw">using</span> <span class="dt">false_type</span> = bool_constant&lt;<span class="kw">false</span>&gt;;</code></pre></div>
<p>今までintegral_constantを使っていた場面で特にboolだけが必要な場面では、C++17以降は単にstd::true_typeかstd::false_typeと書くだけでよくなる。</p>
<h2 id="type_traits">type_traits</h2>
<p>C++17では&lt;type_traits&gt;に機能追加が行われた。</p>
<h3 id="変数テンプレート版traits">変数テンプレート版traits</h3>
<p>C++17では、既存のtraitsに変数テンプレートを利用した_v版が追加された。</p>
<p>例えば、is_integral&lt;T&gt;::valueと書く代わりにis_integral_v&lt;T&gt;と書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T x )
{
    <span class="kw">constexpr</span> <span class="dt">bool</span> b1 = <span class="bu">std::</span>is_integral&lt;T&gt;::value ; <span class="co">// データメンバー</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b2 = <span class="bu">std::</span>is_integral_v&lt;T&gt; ; <span class="co">// 変数テンプレート</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b3 = <span class="bu">std::</span>is_integral&lt;T&gt;{} ; <span class="co">// operator bool()</span>
}</code></pre></div>
<h3 id="論理演算traits">論理演算traits</h3>
<p>C++17ではクラステンプレートconjunction, disjunction, negationが追加された。これはテンプレートメタプログラミングで論理積、論理和、否定を手軽に扱うためのtraitsだ。</p>
<h4 id="conjunction-論理積">conjunction : 論理積</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span>... B&gt; <span class="kw">struct</span> conjunction;</code></pre></div>
<p>クラステンプレートconjunction&lt;B1, B2, ..., BN&gt;はテンプレート実引数B1, B2, ... BNに論理積を適用する。conjunctionはそれぞれのテンプレート実引数Biに対して、bool(Bi::value)がfalseとなる最初の型を基本クラスに持つか、あるいは最後のBNを基本クラスに持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// is_void&lt;void&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t1 =
        conjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;, is_integral&lt;<span class="dt">int</span>&gt;,
            is_void&lt;<span class="dt">void</span>&gt; &gt; ;

    <span class="co">// is_integral&lt;double&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t2 =
        conjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;, is_integral&lt;<span class="dt">double</span>&gt;,
            is_void&lt;<span class="dt">void</span>&gt; &gt; ;

}</code></pre></div>
<h4 id="disjunction-論理和">disjunction: 論理和</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span>... B&gt; <span class="kw">struct</span> disjunction;</code></pre></div>
<p>クラステンプレートdisjunction&lt;B1, B2, ..., BN&gt;はテンプレート実引数B1, B2, ... BNに論理和を適用する。disjunctionはそれぞれのテンプレート実引数Biに対して、bool(Bi::value)がtrueとなる最初の型を基本クラスに持つか、あるいは最後のBNを基本クラスに持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// is_same&lt;int,int&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t1 =
        disjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;, is_integral&lt;<span class="dt">int</span>&gt;,
            is_void&lt;<span class="dt">void</span>&gt; &gt; ;

    <span class="co">// is_void&lt;int&gt;を基本クラスに持つ</span>
    <span class="kw">using</span> t2 =
        disjunction&lt;
            is_same&lt;<span class="dt">int</span>, <span class="dt">double</span>&gt;, is_integral&lt;<span class="dt">double</span>&gt;,
            is_void&lt;<span class="dt">int</span>&gt; &gt; ;
}</code></pre></div>
<h3 id="negation-否定">negation: 否定</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> B&gt; <span class="kw">struct</span> negation;</code></pre></div>
<p>クラステンプレートnegation&lt;B&gt;はBに否定を適用する。negationは基本クラスとしてbool_constant&lt;!bool(B::value)&gt;を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b1 = negation&lt; <span class="dt">true_type</span> &gt;::value ;
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b2 = negation&lt; <span class="dt">false_type</span> &gt;::value ; 
}</code></pre></div>
<h3 id="is_invocable-呼び出し可能か確認するtraits">is_invocable: 呼び出し可能か確認するtraits</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_invocable;

<span class="kw">template</span> &lt;<span class="kw">class</span> R, <span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_invocable_r;

<span class="kw">template</span> &lt;<span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_nothrow_invocable;

<span class="kw">template</span> &lt;<span class="kw">class</span> R, <span class="kw">class</span> Fn, <span class="kw">class</span>... ArgTypes&gt;
<span class="kw">struct</span> is_nothrow_invocable_r;</code></pre></div>
<p>is_invocableはテンプレート実引数で与えられた型FnがパラメーターパックArgTypesをパック展開した結果を実引数に関数呼び出しできるかどうか、そしてその戻り値はRへ暗黙変換できるかどうかを確認するtraitsだ。呼び出せるのであればtrue_type、そうでなければfalse_typeを基本クラスに持つ。</p>
<p>is_invocableは関数呼び出しした結果の戻り値の型については問わない。</p>
<p>is_invocable_rは呼び出し可能性に加えて、関数呼び出しした結果の戻り値の型がRへ暗黙変換できることが確認される。</p>
<p>is_nothrow_invocableとis_nothrow_invocable_rは、関数呼び出し（および戻り値型Rへの暗黙変換）が無例外保証されていることも確認する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> f( <span class="dt">int</span>, <span class="dt">double</span> ) ;

<span class="dt">int</span> main()
{
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b1 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">double</span> &gt;{} ;
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b2 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">int</span> &gt;{} ;

    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b3 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span> &gt;{} ;
    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b4 =
        <span class="bu">std::</span>is_invocable&lt; <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="bu">std::</span>string &gt;{} ;
    
    <span class="co">// true</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b5 = 
        <span class="bu">std::</span>is_invocable_r&lt; <span class="dt">int</span>, <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">double</span> &gt;{} ;
    <span class="co">// false</span>
    <span class="kw">constexpr</span> <span class="dt">bool</span> b6 =
        <span class="bu">std::</span>is_invocable_r&lt; <span class="dt">double</span>, <span class="kw">decltype</span>(&amp;f), <span class="dt">int</span>, <span class="dt">double</span> &gt;{} ;
}</code></pre></div>
<h3 id="has_unique_object_representations-同値の内部表現が同一か確認するtraits">has_unique_object_representations : 同値の内部表現が同一か確認するtraits</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">struct</span> has_unique_object_representations ;</code></pre></div>
<p>has_unique_object_representations&lt;T&gt;は、T型がトリビアルにコピー可能で、かつT型の同値である2つのオブジェクトの内部表現が同じ場合に、trueを返す。</p>
<p>falseを返す例としては、オブジェクトがパディング(padding)と呼ばれるアライメント調整などのための値の表現に影響しないストレージ領域を持つ場合だ。パディングビットの値は同値に影響しないので、falseを返す。</p>
<p>例えば以下のようなクラスXは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="bu">std::</span>uint8_t a ;
    <span class="bu">std::</span>uint32_t b ;
} ;</code></pre></div>
<p>ある実装においては、4バイトにアライメントする必要があり、そのオブジェクトの本当のレイアウトは以下のようになっているかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="bu">std::</span>uint8_t a ;

    <span class="bu">std::</span>byte unused_padding[<span class="dv">3</span>] ;

    <span class="bu">std::</span>uint32_t b ;
} ;</code></pre></div>
<p>この場合、unused_paddingの値には意味がなく、クラスXの同値比較には用いられない。この場合、std::has_unique_representations_v&lt;X&gt;はfalseになる。</p>
<h3 id="is_nothrow_swappable-無例外swap可能か確認するtraits">is_nothrow_swappable: 無例外swap可能か確認するtraits</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">struct</span> is_nothrow_swappable;

<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U&gt;
<span class="kw">struct</span> is_nothrow_swappable_with;</code></pre></div>
<p>is_nothrow_swappable&lt;T&gt;はT型がswapで例外を投げないときにtrueを返す。</p>
<p>is_nothrow_swappable_with&lt;T, U&gt;は、T型とU型を相互にswapするときに例外を投げないときにtrueを返す。</p>
<h2 id="コンテナーで不完全型のサポート">コンテナーで不完全型のサポート</h2>
<p>注意：この説明は上級者向けだ。</p>
<p>C++17では以下のコードが合法になった。このコードの挙動はC++14までは実装依存であった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="bu">std::</span>vector&lt;X&gt; v ;
    <span class="bu">std::</span>list&lt;X&gt; l ;
    <span class="bu">std::</span>forward_list&lt;X&gt; f ;
} ;</code></pre></div>
<p>クラスはクラス定義の終了である}を持って完全型となる。クラススコープに注入されたクラス名は、クラス定義の中ではまだ完全型ではない。不完全型をコンテナーの要素型に指定した場合の挙動は、C++14までは規定されていなかった。</p>
<p>C++17では、vector, list, forward_listに限り、要素型に一時的に不完全型を許すようになった。実際にコンテナーを使う際には完全型になっていなければならない。</p>
<h2 id="emplaceの戻り値">emplaceの戻り値</h2>
<p>C++17ではシーケンスコンテナーのemplace_front/emplace_back、queueとstackのemplaceが構築した要素へのリファレンスを返すように変更された。</p>
<p>そのため、C++14では以下のように書いていたコードが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    v.emplace_back(<span class="dv">0</span>) ; <span class="co">// void</span>
    <span class="dt">int</span> value = v.back() ;
}</code></pre></div>
<p>以下の様に書けるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="dt">int</span> value = v.emplace_back(<span class="dv">0</span>) ;
}</code></pre></div>
<h2 id="mapとunordered_mapの変更">mapとunordered_mapの変更</h2>
<p>mapとunordered_mapに、try_emplaceとinsert_or_assignという2つのメンバー関数が入った。このメンバー関数はmulti_mapとunordered_multi_mapには追加されていない。</p>
<h3 id="try_emplace">try_emplace</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Args&gt;
pair&lt;iterator, <span class="dt">bool</span>&gt;
try_emplace(<span class="at">const</span> <span class="dt">key_type</span>&amp; k, Args&amp;&amp;... args);

<span class="kw">template</span> &lt;<span class="kw">class</span>... Args&gt;
iterator
try_emplace(
    const_iterator hint,
    <span class="at">const</span> <span class="dt">key_type</span>&amp; k, Args&amp;&amp;... args);</code></pre></div>
<p>従来のemplaceは、キーに対応する要素が存在しない場合、要素がargsからemplace構築されて追加される。もし、キーに対応する要素が存在する場合、要素は追加されない。要素が追加されない時、argsがムーブされるかどうかは実装定義である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="bu">std::</span>unique_ptr&lt;<span class="dt">int</span>&gt; &gt; m ;

    <span class="co">// すでに要素が存在する</span>
    m[<span class="dv">0</span>] = <span class="kw">nullptr</span> ;

    <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="co">// emplaceは失敗する</span>
    <span class="kw">auto</span> [iter, is_emplaced] = m.emplace( <span class="dv">0</span>, <span class="bu">std::</span>move(ptr) ) ;

    <span class="co">// 結果は実装により異なる</span>
    <span class="co">// ptrはムーブされているかもしれない</span>
    <span class="dt">bool</span> b = ( ptr != <span class="kw">nullptr</span> ) ;
}</code></pre></div>
<p>この場合、実際にmapに要素は追加されていないのに、ptrはムーブされてしまうかもしれない。</p>
<p>このため、C++17では、要素が追加されなかった場合argsはムーブされないことが保証されるtry_emplaceが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="bu">std::</span>unique_ptr&lt;<span class="dt">int</span>&gt; &gt; m ;

    <span class="co">// すでに要素が存在する</span>
    m[<span class="dv">0</span>] = <span class="kw">nullptr</span> ;

    <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="co">// emplaceは失敗する</span>
    <span class="kw">auto</span> [iter, is_emplaced] = m.emplace( <span class="dv">0</span>, <span class="bu">std::</span>move(ptr) ) ;

    <span class="co">// trueであることが保証される</span>
    <span class="co">// ptrはムーブされていない</span>
    <span class="dt">bool</span> b = ( ptr != <span class="kw">nullptr</span> ) ;
}</code></pre></div>
<h3 id="insert_or_assign">insert_or_assign</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> M&gt;
pair&lt;iterator, <span class="dt">bool</span>&gt;
insert_or_assign(<span class="at">const</span> <span class="dt">key_type</span>&amp; k, M&amp;&amp; obj);

<span class="kw">template</span> &lt;<span class="kw">class</span> M&gt;
iterator
insert_or_assign(
    const_iterator hint,
    <span class="at">const</span> <span class="dt">key_type</span>&amp; k, M&amp;&amp; obj);</code></pre></div>
<p>insert_or_assignはkeyに連想された要素が存在する場合は要素を代入し、存在しない場合は要素を追加する。operator []との違いは、要素が代入されたか追加されたかが、戻り値のpairのboolでわかるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; m ;
    m[<span class="dv">0</span>] = <span class="dv">0</span> ;

    {
        <span class="co">// 代入</span>
        <span class="co">// is_insertedはfalse</span>
        <span class="kw">auto</span> [iter, is_inserted] = m.insert_or_assign( <span class="dv">0</span>, <span class="dv">1</span> ) ;
    }

    {
        <span class="co">// 追加</span>
        <span class="co">// is_insertedはtrue</span>
        <span class="kw">auto</span> [iter, is_inserted] = m.insert_or_assign( <span class="dv">1</span>, <span class="dv">1</span> ) ;
    }
}</code></pre></div>
<h2 id="連想コンテナーへのsplice操作">連想コンテナーへのsplice操作</h2>
<p>C++17では、連想コンテナーと非順序連想コンテナーでsplice操作がサポートされた。</p>
<p>対象のコンテナーはmap, set, multimap, multiset, unordered_map, unordered_set, unordered_multimap, unordered_multisetだ。</p>
<p>splice操作とはlistで提供されている操作で、アロケーター互換のlistのオブジェクトの要素をストレージと所有権ごと別のオブジェクトに移動する機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    a.splice( <span class="bu">std::</span>end(a), b, <span class="bu">std::</span>begin(b) ) ;

    <span class="co">// aは{1,2,3,4}</span>
    <span class="co">// bは{5,6}</span>

    b.splice( <span class="bu">std::</span>end(b), a ) ;

    <span class="co">// aは{}</span>
    <span class="co">// bは{5,6,1,2,3,4}</span>

}</code></pre></div>
<p>連想コンテナーでは、ノードハンドルという仕組みを用いて、コンテナーのオブジェクトから要素の所有権をコンテナーの外に出す仕組みで、splice操作を行う。</p>
<h3 id="merge">merge</h3>
<p>すべての連想コンテナーと非順序連想コンテナーは、メンバー関数mergeを持っている。コンテナーa, bがアロケーター互換のとき、a.merge(b)は、コンテナーbの要素の所有権をすべてコンテナーaに移す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="co">// bの要素をすべてaに移す</span>
    a.merge(b) ;

    <span class="co">// aは{1,2,3,4,5,6}</span>
    <span class="co">// bは{}</span>
}</code></pre></div>
<p>もし、キーの重複を許さないコンテナーの場合で、値が重複した場合、重複した要素は移動しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    a.merge(b) ;

    <span class="co">// aは{1,2,3,4,5,6}</span>
    <span class="co">// bは{1,2,3}</span>

}</code></pre></div>
<p>mergeによって移動された要素を指すポインターとイテレーターは、要素の移動後も妥当である。ただし、所属するコンテナーのオブジェクトが変わる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;


    <span class="kw">auto</span> iterator = <span class="bu">std::</span>begin(b) ;
    <span class="kw">auto</span> pointer = &amp;*iterator ;

    a.merge(b) ;

    <span class="co">// iteratorとpointerはまだ妥当</span>
    <span class="co">// ただし要素はaに所属する</span>
}</code></pre></div>
<h3 id="ノードハンドル">ノードハンドル</h3>
<p>ノードハンドルとは、コンテナーオブジェクトから要素を構築したストレージの所有権を切り離す機能だ。</p>
<p>ノードハンドルの型は、各コンテナーのネストされた型名node_typeとなる。例えばstd::set&lt;int&gt;のノードハンドル型は、std::set&lt;int&gt;::node_typeとなる。</p>
<p>ノードハンドルは以下のようなメンバーを持っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> node_handle
{
<span class="kw">public</span> :
    <span class="co">// ネストされた型名</span>
    <span class="kw">using</span> <span class="dt">value_type</span> = ... ;        <span class="co">// set限定、要素型</span>
    <span class="kw">using</span> <span class="dt">key_type</span> = ... ;          <span class="co">// map限定、キー型</span>
    <span class="kw">using</span> <span class="dt">mapped_type</span> = ... ;       <span class="co">// map限定、マップ型</span>
    <span class="kw">using</span> <span class="dt">allocator_type</span> = ... ;    <span class="co">// アロケーターの型</span>

    <span class="co">// デフォルトコンストラクター</span>
    <span class="co">// ムーブコンストラクター</span>
    <span class="co">// ムーブ代入演算子</span>


    <span class="co">// 値へのアクセス</span>
    <span class="dt">value_type</span> &amp; value() <span class="at">const</span> ;   <span class="co">// set限定</span>
    <span class="dt">key_type</span> &amp; key() <span class="at">const</span> ;        <span class="co">// map限定</span>
    <span class="dt">mapped_type</span> &amp; mapped() <span class="at">const</span> ;  <span class="co">// map限定</span>

    <span class="co">// アロケーターへのアクセス</span>
    <span class="dt">allocator_type</span> get_allocator() <span class="at">const</span> ;

    <span class="co">// 空かどうかの判定</span>
    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span> ;
    <span class="dt">bool</span> empty() <span class="at">const</span> <span class="kw">noexcept</span> ;

    <span class="dt">void</span> swap( node_handle &amp; ) ;
} ;</code></pre></div>
<p>setのノードハンドルはメンバー関数valueで値を得る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n = c.extract(<span class="dv">2</span>) ;

    <span class="co">// n.value() == 2</span>
    <span class="co">// cは{1,3}</span>
}</code></pre></div>
<p>mapのノードハンドルはメンバー関数keyとmappedでそれぞれの値を得る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; m =
    {
        {<span class="dv">1</span>,<span class="dv">1</span>}, {<span class="dv">2</span>,<span class="dv">2</span>}, {<span class="dv">3</span>,<span class="dv">3</span>}
    } ;

    <span class="kw">auto</span> n = m.extract(<span class="dv">2</span>) ;

    <span class="co">// n.key() == 2 </span>
    <span class="co">// n.mapped() == 2</span>
    <span class="co">// mは{{1,1},{3,3}}</span>

}</code></pre></div>
<p>ノードハンドルはノードをコンテナーから切り離し、所有権を得る。そのため、ノードハンドルによって得たノードは、元のコンテナーから独立し、元のコンテナーオブジェクトの破棄の際にも破棄されない。ノードハンドルのオブジェクトの破棄時に破棄される。このため、ノードハンドルはアロケーターのコピーも持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ;

    {
        <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
        <span class="co">// 所有権の移動</span>
        n = c.extract( <span class="bu">std::</span>begin(c) ) ;
        <span class="co">// cが破棄される</span>
    }

    <span class="co">// OK</span>
    <span class="co">// ノードハンドルによって所有権が移動している。</span>
    <span class="dt">int</span> x = n.value() ;

    <span class="co">// nが破棄される</span>
}</code></pre></div>
<h3 id="extract-ノードハンドルの取得">extract : ノードハンドルの取得</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">node_type</span> extract( const_iterator position ) ;
<span class="dt">node_type</span> extract( <span class="at">const</span> <span class="dt">key_type</span> &amp; x ) ;</code></pre></div>
<p>連想コンテナーと非順序連想コンテナーのメンバー関数extractは、ノードハンドルを取得するためのメンバー関数だ。</p>
<p>メンバー関数extract(position)は、イテレーターのpositionが指す要素を、コンテナーから除去して、その要素を所有するノードハンドルを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n1 = c.extract( <span class="bu">std::</span>begin(c) ) ;

    <span class="co">// cは{2,3}</span>

    <span class="kw">auto</span> n2 = c.extract( <span class="bu">std::</span>begin(c) ) ;

    <span class="co">// cは{3}</span>

}</code></pre></div>
<p>メンバー関数extract(x)は、キーxがコンテナーに存在する場合、その要素をコンテナーから除去して、その要素を所有するノードハンドルを返す。存在しない場合、空のノードハンドルを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n1 = c.extract( <span class="dv">1</span> ) ;
    <span class="co">// cは{2,3}</span>

    <span class="kw">auto</span> n2 = c.extract( <span class="dv">2</span> ) ;
    <span class="co">// cは{3}</span>

    <span class="co">// キー4は存在しない</span>
    <span class="kw">auto</span> n3 = c.extract( <span class="dv">4</span> ) ;
    <span class="co">// cは{3}</span>
    <span class="co">// n3.empty() == true</span>
}</code></pre></div>
<p>キーの重複を許すコンテナーの場合、複数あるうちのひとつの所有権が開放される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>multiset&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>} ;
    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;
    <span class="co">// cは{1,1}</span>
}</code></pre></div>
<h3 id="insert-ノードハンドルから要素の追加">insert : ノードハンドルから要素の追加</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// キーの重複を許さないコンテナーの場合</span>
<span class="dt">insert_return_type</span>  insert(<span class="dt">node_type</span>&amp;&amp; nh);
<span class="co">// キーの重複を許すmultiコンテナーの場合</span>
iterator  insert(<span class="dt">node_type</span>&amp;&amp; nh);

<span class="co">// ヒントつきのinsert</span>
iterator            insert(const_iterator hint, <span class="dt">node_type</span>&amp;&amp; nh);</code></pre></div>
<p>ノードハンドルをコンテナーのメンバー関数insertの実引数に渡すと、ノードハンドルから所有権をコンテナーに移動する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="kw">auto</span> n = a.extract(<span class="dv">1</span>) ;

    b.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// n.empty() == true</span>
}</code></pre></div>
<p>ノードハンドルが空の場合、何も起こらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ;

    <span class="co">// 何も起こらない</span>
    c.insert( <span class="bu">std::</span>move(n) ) ;
}</code></pre></div>
<p>キーの重複を許さないコンテナーに、すでにコンテナーに存在するキーと等しい値を所有するノードハンドルをinsertしようとすると、insertは失敗する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;
    c.insert( <span class="dv">1</span> ) ;

    <span class="co">// 失敗する</span>
    c.insert( <span class="bu">std::</span>move(n) ) ; 
}</code></pre></div>
<p>第一引数にイテレーターhintを受け取るinsertの挙動は、従来のinsertと同じだ。要素がhintの直前に追加されるのであれば償却定数時間で処理が終わる。</p>
<p>ノードハンドルを実引数に受け取るinsertの戻り値の型は、キーの重複を許すmultiコンテナーの場合iterator。キーの重複を許さないコンテナーの場合、insert_return_typeとなる。</p>
<p>multiコンテナーの場合、戻り値は追加した要素を指すイテレーターとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>multiset&lt;<span class="dt">int</span>&gt; c { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;

    <span class="kw">auto</span> n = c.extract( <span class="dv">1</span> ) ;

    <span class="kw">auto</span> iter = c.insert( n ) ;

    <span class="co">// cは{1,2,3}</span>
    <span class="co">// iterは1を指す</span>
}</code></pre></div>
<p>キーの重複を許さないコンテナーの場合、コンテナーにネストされた型名insert_return_typeが戻り値の型となる。例えばset&lt;int&gt;の場合、set&lt;int&gt;::insert_return_typeとなる。</p>
<p>insert_return_typeの具体的な名前は規格上規定されていない。insert_return_typeは以下のようなデータメンバーを持つ型となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> <span class="dt">insert_return_type</span>
{
    iterator position ;
    <span class="dt">bool</span> inserted ;
    <span class="dt">node_type</span> node ;
} ;</code></pre></div>
<p>positionはinsertによってコンテナーに所有権を移動して追加された要素を指すイテレーター、insertedは要素の追加が行われた場合にtrueとなるbool、nodeは要素の追加が失敗したときにノードハンドルの所有権が移動されるノードハンドルとなる。</p>
<p>insertに渡したノードハンドルが空のとき、insertedはfalse、positionはend()、nodeは空になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ; <span class="co">// 空</span>

    <span class="kw">auto</span> [position, inserted, node] = c.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// inserted == false</span>
    <span class="co">// position == c.end()</span>
    <span class="co">// node.empty() == true</span>
}</code></pre></div>
<p>insertが成功したとき、insertedはtrue、positionは追加された要素を指す、nodeは空になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;

    <span class="kw">auto</span> [position, inserted, node] = c.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// inserted == true</span>
    <span class="co">// position == c.find(1)</span>
    <span class="co">// node.empty() == true</span>
}</code></pre></div>
<p>insertが失敗した時、つまりすでに同一のキーがコンテナーに存在した時、insertedはfalse、nodeはinsertを呼び出す前のノードハンドルの値、positionはコンテナーの中の追加しようとしたキーに等しい要素を指す。insertに渡したノードハンドルは未規定の値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> n = c.extract(<span class="dv">1</span>) ;
    c.insert(<span class="dv">1</span>) ;

    <span class="kw">auto</span> [position, inserted, node] = c.insert( <span class="bu">std::</span>move(n) ) ;

    <span class="co">// nは未規定の値。</span>
    <span class="co">// inserted == false</span>
    <span class="co">// nodeはinsert( std::move(n) )を呼び出す前のnの値</span>
    <span class="co">// position == c.find(1)</span>
}</code></pre></div>
<p>規格はこの場合のnの値について規定していないが、最もあり得る実装としては、nはnodeにムーブされるので、nは空になり、ムーブ後の状態になる。</p>
<h3 id="ノードハンドルの利用例">ノードハンドルの利用例</h3>
<p>ノードハンドルの典型的な使い方は以下の通り。</p>
<h4 id="ストレージの再確保なしにコンテナーの一部の要素だけ別のコンテナーに移す">ストレージの再確保なしに、コンテナーの一部の要素だけ別のコンテナーに移す</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; b = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="kw">auto</span> n = a.extract(<span class="dv">1</span>) ;
    b.insert( <span class="bu">std::</span>move(n) ) ;
}</code></pre></div>
<h4 id="コンテナーの寿命を超えて要素を存続させる">コンテナーの寿命を超えて要素を存続させる</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt;::<span class="dt">node_type</span> n ;

    {
        <span class="bu">std::</span>set&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
        n = c.extract(<span class="dv">1</span>) ;
        <span class="co">// cが破棄される</span>
    }

    <span class="co">// コンテナーの破棄後も存続する</span>
    <span class="dt">int</span> value = n.value() ;
}</code></pre></div>
<h4 id="mapのキーを変更する">mapのキーを変更する</h4>
<p>mapではキーは変更できない。キーを変更したければ、元の要素は削除して、新しい要素を追加する必要がある。これには動的なストレージの解放と確保が必要になる。</p>
<p>ノードハンドルを使えば、既存の要素のストレージに対して、所有権をmapから引き剥がした上で、キーを変更して、もう一度mapに差し戻すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="bu">std::</span>string, <span class="bu">std::</span>string &gt; m =
    {
        {<span class="st">&quot;cat&quot;</span>, <span class="st">&quot;meow&quot;</span>},
        {<span class="st">&quot;DOG&quot;</span>, <span class="st">&quot;bow&quot;</span>}, <span class="co">// キーを間違えたので変更したい</span>
        {<span class="st">&quot;cow&quot;</span>, <span class="st">&quot;moo&quot;</span>}
    } ;

    <span class="co">// 所有権を引き剥がす</span>
    <span class="kw">auto</span> n = m.extract(<span class="st">&quot;DOG&quot;</span>) ;
    <span class="co">// キーを変更</span>
    n.key() = <span class="st">&quot;dog&quot;</span> ;
    <span class="co">// 差し戻す</span>
    m.insert( <span class="bu">std::</span>move(n) ) ;
}</code></pre></div>
<h2 id="コンテナーアクセス関数">コンテナーアクセス関数</h2>
<p>ヘッダーファイル&lt;iterator&gt;に、コンテナーアクセス関数として、フリー関数版のsize, empty, dataが追加された。それぞれ、メンバー関数のsize, empty, dataを呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="bu">std::</span>size(v) ; <span class="co">// v.size()</span>
    <span class="bu">std::</span>empty(v) ; <span class="co">// v.empty()</span>
    <span class="bu">std::</span>data(v) ; <span class="co">// v.data() </span>
}</code></pre></div>
<p>このフリー関数は配列やstd::initializer_list&lt;T&gt;にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">10</span>] ;

    <span class="bu">std::</span>size(a) ; <span class="co">// 10</span>
    <span class="bu">std::</span>empty(a) ; <span class="co">// 常にfalse</span>
    <span class="bu">std::</span>data(a) ; <span class="co">// a</span>
}</code></pre></div>
<h2 id="clamp">clamp</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;
clamp(<span class="at">const</span> T&amp; v, <span class="at">const</span> T&amp; lo, <span class="at">const</span> T&amp; hi);
<span class="kw">template</span>&lt;<span class="kw">class</span> T, <span class="kw">class</span> Compare&gt;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;
clamp(<span class="at">const</span> T&amp; v, <span class="at">const</span> T&amp; lo, <span class="at">const</span> T&amp; hi, Compare comp);</code></pre></div>
<p>ヘッダーファイル&lt;algorithm&gt;に追加されたclamp(v, lo, hi)は値vがloより小さい場合はloを、hiより高い場合はhiを、それ以外の場合はvを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>clamp( <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">10</span> ) ; <span class="co">// 5</span>
    <span class="bu">std::</span>clamp( <span class="dv">-5</span>, <span class="dv">0</span>, <span class="dv">10</span> ) ; <span class="co">// 0</span>
    <span class="bu">std::</span>clamp( <span class="dv">50</span>, <span class="dv">0</span>, <span class="dv">10</span> ) ; <span class="co">// 10</span>
}</code></pre></div>
<p>compを実引数に取るclampはcompを値の比較に使う</p>
<p>clampには浮動小数点数も使えるが、NaNは渡せない。</p>
<h2 id="次元hypot">3次元hypot</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> hypot(<span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z);
<span class="dt">double</span> hypot(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> z);
<span class="dt">long</span> <span class="dt">double</span> hypot(<span class="dt">long</span> <span class="dt">double</span> x, <span class="dt">long</span> <span class="dt">double</span> y, <span class="dt">long</span> <span class="dt">double</span> z);</code></pre></div>
<p>ヘッダーファイル&lt;cmath&gt;に3次元のhypotが追加された。</p>
<p>戻り値：</p>
<p><span class="math display">\[
\sqrt{x^2+y^2+z^2}
\]</span></p>
<h2 id="atomictis_always_lock_free">atomic&lt;T&gt;::is_always_lock_free</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> atomic
{
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_always_lock_free = ... ;
} ;</code></pre></div>
<p>C++17で&lt;atomic&gt;に追加されたatomic&lt;T&gt;::is_always_lock_freeは、atomic&lt;T&gt;の実装がすべての実行においてロックフリーであるとコンパイル時に保証できる場合、trueになるstatic constexprなbool型のデータメンバーだ。</p>
<p>atomicには、他にもboolを返すメンバー関数is_lock_freeがあるが、これは実行時にロックフリーであるかどうかを判定できる。is_always_lock_freeはコンパイル時にロックフリーであるかどうかを判定できる。</p>
<h2 id="scoped_lock-可変長引数lock_guard">scoped_lock : 可変長引数lock_guard</h2>
<p>std::scoped_lockクラス&lt;T ...&gt;は可変長引数版のlock_guardだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>mutex a, b, c, d ;

    {
        <span class="co">// a,b,c,dをlockする</span>
        <span class="bu">std::</span>scoped_lock l( a, b, c, d ) ;
        <span class="co">// a,b,c,dをunlockする</span>
    }
}</code></pre></div>
<p>std::scoped_lockのコンストラクターは複数のロックのオブジェクトのリファレンスを取り、それぞれにデッドロックを起こさない方法でメンバー関数lockを呼び出す。デストラクターはメンバー関数unlockを呼び出す。</p>
<h2 id="stdbyte">std::byte</h2>
<p>C++17ではバイトを表現する型としてstd::byteがライブラリに追加された。これは、コア言語の一部であり、<a href="#std.byte">別項で詳しく解説を行っている</a>。</p>
<h2 id="最大公約数gcdと最小公倍数lcm">最大公約数(gcd)と最小公倍数(lcm)</h2>
<p>C++17ではヘッダーファイル&lt;numeric&gt;に最大公約数(gcd)と最小公倍数(lcm)が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;

    <span class="cf">while</span>( <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b )
    {
        <span class="bu">std::</span>cout
            &lt;&lt; <span class="st">&quot;gcd: &quot;</span> &lt;&lt; gcd(a,b)
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">lcm: &quot;</span> &lt;&lt; lcm(a,b) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h3 id="gcd-最大公約数">gcd : 最大公約数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> M, <span class="kw">class</span> N&gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>common_type_t&lt;M,N&gt; gcd(M m, N n)
{
    <span class="cf">if</span> ( n == <span class="dv">0</span> )
        <span class="cf">return</span> m ;
    <span class="cf">else</span>
        <span class="cf">return</span> gcd( n, <span class="bu">std::</span>abs(m) % <span class="bu">std::</span>abs(n) ) ; 
}</code></pre></div>
<p>gcd(m, n)はmとnがともにゼロの場合ゼロを返す。それ以外の場合、<span class="math inline">\(|m|\)</span>と<span class="math inline">\(|n|\)</span>の最大公約数(Greatest Common Divisor)を返す。</p>
<h3 id="lcm-最小公倍数">lcm : 最小公倍数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> M, <span class="kw">class</span> N&gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>common_type_t&lt;M,N&gt; lcm(M m, N n)
{
    <span class="cf">if</span> ( m == <span class="dv">0</span> || n == <span class="dv">0</span> )
        <span class="cf">return</span> <span class="dv">0</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>abs(m) / gcd( m, n ) * <span class="bu">std::</span>abs(n) ;
}</code></pre></div>
<p>lcm(m,n)は、mとnのどちらかがゼロの場合ゼロを返す。それ以外の場合、<span class="math inline">\(|m|\)</span>と<span class="math inline">\(|n|\)</span>の最小公倍数(Least Common Multiple)を返す。</p>
<h1 id="ファイルシステム">ファイルシステム</h1>
<p>ヘッダーファイル &lt;filesystem&gt; で定義されている標準ライブラリのファイルシステムは、ファイルやディレクトリーとその属性を扱うためのライブラリだ。</p>
<p>一般に「ファイルシステム」といった場合、例えばLinuxのext4、Microsoft WindowsのFATやNTFS、Apple MacのHFS+やAPFSといったファイルとその属性を表現するためのストレージ上のデータ構造を意味する。C++の標準ライブラリのファイルシステムとは、そのようなファイルシステムを実現するデータ構造を操作するライブラリではない。ファイルシステムというデータ構造で抽象化された、ファイルやディレクトリーとその属性、それに付随する要素、例えばパスやファイルやディレクトリーを操作するためのライブラリのことだ。</p>
<p>また、ファイルシステムライブラリでは、「ファイル」という用語は単に通常のファイルのみならず、ディレクトリー、シンボリックリンク、FIFO(名前付きパイプ)、ソケットなどの特殊なファイルも含む。</p>
<p>本書ではファイルシステムライブラリのすべてを詳細に解説していない。ファイルシステムライブラリは量が膨大なので、特定の関数の意味については、C++コンパイラーに付属のリファレンスマニュアルなどを参照するとよい。</p>
<h2 id="名前空間">名前空間</h2>
<p>ファイルシステムライブラリはstd::filesystem名前空間スコープの下に宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem<span class="bu">::</span>path p(<span class="st">&quot;/bin&quot;</span>) ;
}</code></pre></div>
<p>この名前空間は長いので、ファイルシステムライブラリを使うときは、関数のブロックスコープ単位でusingディレクティブを使うか、名前空間エイリアスを使って短い別名をつけるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> using_directive()
{
    <span class="co">// usingディレクティブ</span>
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;/etc&quot;</span>) ;
}

<span class="dt">void</span> namespace_alias()
{
    <span class="co">// 名前空間エイリアス</span>
    <span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem ;

    fs::path p(<span class="st">&quot;/usr&quot;</span>) ;
}</code></pre></div>
<h2 id="posix準拠">POSIX準拠</h2>
<p>C++のファイルシステムのファイル操作の挙動は、POSIX規格に従う。実装によってはPOSIXに規定された挙動を提供できない場合もある。その場合は制限の範囲内で、できるだけPOSIXに近い挙動を行う。実装がどのような意味のある挙動も提供できない場合、エラーが通知される。</p>
<h2 id="ファイルシステムの全体像">ファイルシステムの全体像</h2>
<p>ファイルシステムライブラリの全体像を簡単に箇条書きすると以下の通り。</p>
<ul>
<li>クラスpathでファイルパス文字列を扱う</li>
<li>例外クラスfilesystem_errorとクラスerror_codeでエラー通知</li>
<li>クラスfile_statusでファイルの情報とパーミッションの取得、設定</li>
<li>クラスdirectory_entryでディレクトリーの情報の取得、設定</li>
<li>クラスdirectory_iteratorでディレクトリー構造をイテレーターとしてたどる</li>
<li>多数のフリー関数でファイルとディレクトリーの操作</li>
</ul>
<h2 id="エラー処理">エラー処理</h2>
<p>ファイルシステムライブラリでエラーが発生した場合、エラーの通知方法には2種類の方法がある。例外を使う方法と、ヘッダーファイル&lt;system_error&gt;で定義されているエラー通知用のクラスstd::error_codeへのリファレンスを実引数として渡してエラー内容を受け取る方法だ。</p>
<p>エラー処理の方法は、エラーの起こる期待度によって選択できる。一般に、エラーがめったに起こらない場合、エラーが起こるのは予期していない場合、エラー処理には例外を使ったほうがよい。エラーが頻繁に起こる場合、エラーが起こることが予期できる場合、エラー処理には例外を使わないほうがよい。</p>
<h3 id="例外-1">例外</h3>
<p>ファイルシステムライブラリの関数のうち、std::error_code &amp;型を実引数に取らない関数は、以下のようにエラー通知を行う。</p>
<ul>
<li><p>OSによるファイルシステム操作においてエラーが発生した場合、std::filesystem::filesystem_error型の例外がthrowされる。一つのpathを実引数に取る関数の場合、filesystem_errorのメンバー関数path1で実引数のpathが得られる。2つのpathを実引数に取る関数の場合、filesystem_errorのメンバー関数path1, path2で第一、第二引数がそれぞれ得られる。filesystem_errorはエラー内容に応じたerror_codeを持つ</p></li>
<li><p>ストレージの確保に失敗した場合、既存の例外による通知が行われる</p></li>
<li><p>デストラクターは例外を投げない</p></li>
</ul>
<p>例外を使ったエラー処理は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="cf">try</span> {
        <span class="co">// ファイル名から同じファイル名へのコピーによるエラー</span>
        path file(<span class="st">&quot;foobar.txt&quot;</span>) ;
        <span class="bu">std::</span>ofstream{ file } ;
        copy_file( file, file ) ;
       
    } <span class="cf">catch</span>( filesystem_error &amp; e )
    { <span class="co">// エラーの場合</span>
        <span class="kw">auto</span> path1 = e.path1() ; <span class="co">// 第一引数</span>
        <span class="kw">auto</span> path2 = e.path2() ; <span class="co">// 第二引数</span>
        <span class="kw">auto</span> error_code = e.code() ; <span class="co">// error_code</span>
        
        <span class="bu">std::</span>cout
            &lt;&lt; <span class="st">&quot;error number: &quot;</span> &lt;&lt; error_code.value ()
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">error message: &quot;</span> &lt;&lt; error_code.message() 
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path1: &quot;</span> &lt;&lt; path<span class="dv">1</span>
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<p>filesystem_errorは以下のようなクラスになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>filesystem {
    <span class="kw">class</span> filesystem_error : <span class="kw">public</span> system_error {
    <span class="kw">public</span>:
        <span class="co">// 第一引数</span>
        <span class="at">const</span> path&amp; path1() <span class="at">const</span> <span class="kw">noexcept</span>;
        <span class="co">// 第二引数</span>
        <span class="at">const</span> path&amp; path2() <span class="at">const</span> <span class="kw">noexcept</span>;
        <span class="co">// エラー内容を人間が読めるnull終端文字列で返す</span>
        <span class="at">const</span> <span class="dt">char</span>* what() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>;
    };
}</code></pre></div>
<h3 id="非例外">非例外</h3>
<p>ファイルシステムライブラリの関数のうち、std::error_code &amp;型を実引数に取る関数は、以下のようにエラー通知を行う。</p>
<ul>
<li>OSによるファイルシステム操作においてエラーが発生した場合、error_code &amp;型の実引数がエラー内容に応じて設定される。エラーがない場合、error_code &amp;型の実引数に対してメンバー関数clear()が呼ばれる。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// ファイル名から同じファイル名へのコピーによるエラー</span>
    path file(<span class="st">&quot;foobar.txt&quot;</span>) ;
    <span class="bu">std::</span>ofstream{ file } ;
    <span class="bu">std::</span>error_code error_code;
    copy_file( file, file, error_code ) ;

    <span class="cf">if</span> ( error_code )
    { <span class="co">// エラーの場合</span>
        <span class="kw">auto</span> path1 = file ; <span class="co">// 第一引数</span>
        <span class="kw">auto</span> path2 = file ; <span class="co">// 第二引数</span>
        
        <span class="bu">std::</span>cout
            &lt;&lt; <span class="st">&quot;error number: &quot;</span> &lt;&lt; error_code.value ()
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">error message: &quot;</span> &lt;&lt; error_code.message() 
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path1: &quot;</span> &lt;&lt; path<span class="dv">1</span>
            &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">path2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h2 id="path-ファイルパス文字列クラス">path : ファイルパス文字列クラス</h2>
<p>std::filesystem::pathはファイルパスを文字列で表現するためのクラスだ。文字列を表現するクラスとしてC++にはすでにstd::stringがあるが、ファイルパスという文字列を表現するために、別の専用クラスが作られた。</p>
<p>クラスpathは以下の機能を提供する。</p>
<ul>
<li>ファイルパス文字列の表現</li>
<li>ファイルパス文字列の操作</li>
</ul>
<p>pathはファイルパス文字列の表現と操作だけを提供するクラスで、物理ファイルシステムへの変更のコミットはしない。</p>
<p>ファイルパス文字列がどのように表現されているかは実装により異なる。POSIX環境では文字型をchar型としてUTF-8エンコードで表現するOSが多いが、Microsoft Windowsで本書執筆現在、文字型をwchar_tとしてUTF-16エンコードで表現する慣習になっている。</p>
<p>また、OSによってはラテンアルファベットの大文字小文字を区別しなかったり、区別はするが無視されたりする実装もある。</p>
<p>クラスpathはそのようなファイルパス文字列の差異を吸収してくれる。</p>
<p>クラスpathには以下のようなネストされた型名がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>filesystem {
<span class="kw">class</span> path {
<span class="kw">public</span>:
    <span class="kw">using</span> <span class="dt">value_type</span> = see below ;
    <span class="kw">using</span> <span class="dt">string_type</span> = basic_string&lt;<span class="dt">value_type</span>&gt;;
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">value_type</span> preferred_separator = see below ;
} ;</code></pre></div>
<p>value_typeとstring_typeはpathが内部でファイルパス文字列を表現するのに使う文字と文字列の型だ。preferred_separatorは、推奨されるディレクトリー区切り文字だ。例えばPOSIX互換環境では<code>/</code>が用いられるが、Microsoft Windowsでは<code>\</code>が使われている。</p>
<h3 id="ファイルパスの文字列">ファイルパスの文字列</h3>
<p>ファイルパスは文字列で表現する。C++の文字列のエンコードには以下のものがある。</p>
<ul>
<li>char: ネイティブナローエンコード</li>
<li>wchar_t: ネイティブワイドエンコード</li>
<li>char: UTF-8エンコード</li>
<li>char16_t: UTF-16エンコード</li>
<li>char32_t: UTF-32エンコード</li>
</ul>
<p>path::value_typeがどの文字型を使い、どの文字列エンコードを使っているかは実装依存だ。pathはどの文字列エンコードが渡されても、path::value_typeの文字型と文字エンコードになるように自動的に変換が行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// ネイティブナローエンコード</span>
    path p1( <span class="st">&quot;/dev/null&quot;</span> ) ;
    <span class="co">// ネイティブワイドエンコード</span>
    path p2( <span class="st">L&quot;/dev/null&quot;</span> ) ;
    <span class="co">// UTF-16エンコード</span>
    path p3( <span class="st">u&quot;/dev/null&quot;</span> ) ;
    <span class="co">// UTF-32エンコード</span>
    path p4( <span class="st">U&quot;/dev/null&quot;</span> ) ;
}</code></pre></div>
<p>なので、どの文字列エンコードで渡しても動く。</p>
<p>C++ではUTF-8エンコードの文字型はcharで、これはネイティブナローエンコードの文字型と同じなので、型システムによって区別できない。そのため、UTF-8文字列リテラルを渡すと、ネイティブナローエンコードとして認識される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// ネイティブナローエンコードとして解釈される</span>
    path p( <span class="st">u8&quot;ファイル名&quot;</span> ) ;
}</code></pre></div>
<p>このコードは、ネイティブナローエンコードがUTF-8ではない場合、動く保証のない移植性の低いコードだ。UTF-8エンコードを移植性の高い方法でファイルパスとして使いたい場合、u8pathを使うとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// UTF-8エンコードとして解釈される</span>
    <span class="co">// 実装の使う文字エンコードに変換される</span>
    path = u8path( <span class="st">u8&quot;ファイル名&quot;</span> ) ;
}</code></pre></div>
<p>u8path(Source)はSourceをUTF-8エンコードされた文字列として扱うので、通常の文字列リテラルを渡すと、ネイティブナローエンコードがUTF-8ではない環境では問題になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// UTF-8エンコードとして解釈される</span>
    <span class="co">// ネイティブナローエンコードがUTF-8ではない場合、問題になる</span>
    path = u8path( <span class="st">&quot;ファイル名&quot;</span> ) ;
}</code></pre></div>
<p>u8pathを使う場合は、文字列は必ずUTF-8エンコードしなければならない。</p>
<p>環境によっては、ファイルパスに使える文字に制限があり、また特定の文字列は特別な意味を持つ予約語になっていることもあるので、移植性の高いプログラムの作成に当たってはこの点でも注意が必要だ。例えば、環境によっては大文字小文字の区別をしないかもしれない。また、CONやAUXのような文字列が特別な意味を持つかもしれない。</p>
<p>pathに格納されているファイルパス文字列を取得する方法は、環境依存の文字列エンコードとファイルパスの表現方法の差異により、様々な方法が用意されている。</p>
<p>ファイルパス文字列のフォーマットには以下の2つがある。</p>
<ul>
<li>ネイティブ: 実装依存のフォーマット</li>
<li>ジェネリック: 汎用的な標準のフォーマット</li>
</ul>
<p>POSIX準拠の環境においては、ネイティブとジェネリックは全く同じだ。POSIX準拠ではない環境では、ネイティブとジェネリックは異なるフォーマットを持つ可能性がある。</p>
<p>例えば、Microsoft Windowsでは、ネイティブのファイルパス文字列はディレクトリーの区切り文字にPOSIX準拠の<code>/</code>ではなく<code>\</code>を使っている。</p>
<p>まずメンバー関数nativeとc_strがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> path {
{
<span class="kw">public</span> :
    <span class="at">const</span> <span class="dt">string_type</span>&amp; native() <span class="at">const</span> <span class="kw">noexcept</span>;
    <span class="at">const</span> <span class="dt">value_type</span>* c_str() <span class="at">const</span> <span class="kw">noexcept</span>;
} ;</code></pre></div>
<p>これはクラスpathが内部で使っている実装依存のネイティブな文字列型をそのまま返すものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p = current_path() ;

    <span class="co">// 実装依存のbasic_stringの特殊化</span>
    path::<span class="dt">string_type</span> str = p.native() ;

    <span class="co">// 実装依存の文字型</span>
    path::<span class="dt">value_type</span> <span class="at">const</span> * ptr = p.c_str() ;
    
}</code></pre></div>
<p>このメンバー関数を使うコードは移植性に注意が必要だ。</p>
<p>strの型はpath::string_typeで、ptrの型は実装依存のpath::value_type const *だ。path::value_typeとpath::string_typeは、charやwchar_t、std::stringやstd::wstringのようなC++が標準で定義する型ではない可能性がある。</p>
<p>そして、path::string_typeへの変換関数operator string_type()がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;

    <span class="kw">auto</span> p = current_path() ;

    <span class="co">// 暗黙の型変換</span>
    path::<span class="dt">string_type</span> str = p ;
}</code></pre></div>
<p>pathのoperator string_type()は、ネイティブの文字列型を既存のファイルストリームライブラリでオープンできる形式に変換して返す。例えば空白文字を含むファイルパスのために、二重引用符で囲まれている文字列に変換されるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path name(<span class="st">&quot;foo bar.txt&quot;</span>) ;
    <span class="bu">std::</span>basic_ofstream&lt;path::<span class="dt">value_type</span>&gt; file( name ) ;
    file &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>ネイティブのファイルパス文字列をstring, wstring, u16string, u32stringに変換して取得するメンバー関数に以下のものがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> path {
<span class="kw">public</span> :
    <span class="bu">std::</span>string string() <span class="at">const</span>;
    <span class="bu">std::</span>wstring wstring() <span class="at">const</span>;
    <span class="bu">std::</span>string u8string() <span class="at">const</span>;
    <span class="bu">std::</span>u16string u16string() <span class="at">const</span>;
    <span class="bu">std::</span>u32string u32string() <span class="at">const</span>;
} ;</code></pre></div>
<p>このうち、メンバー関数stringはネイティブナローエンコードされたstd::string、メンバー関数u8stringはUTF-8エンコードされたstd::stringを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path name(<span class="st">&quot;hello.txt&quot;</span>) ;
    <span class="bu">std::</span>ofstream file( name.string() ) ;
    file &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>ファイルパス文字列をジェネリックに変換して返すgeneric_string()系のメンバー関数がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> path {
<span class="kw">public</span> :
    <span class="bu">std::</span>string generic_string() <span class="at">const</span>;
    <span class="bu">std::</span>wstring generic_wstring() <span class="at">const</span>;
    <span class="bu">std::</span>string generic_u8string() <span class="at">const</span>;
    <span class="bu">std::</span>u16string generic_u16string() <span class="at">const</span>;
    <span class="bu">std::</span>u32string generic_u32string() <span class="at">const</span>
} ;</code></pre></div>
<p>使い方はネイティブな文字列を返すstring()系のメンバー関数と同じだ。</p>
<p>ファイルパスの文字列の文字型と文字列エンコードは環境ごとに異なるので、移植性の高いコードを書くときには注意が必要だ。</p>
<p>現実的には、モダンなPOSIX準拠の環境では、文字型はchar、文字列型はstd::string、エンコードはUTF-8になる。</p>
<p>Microsoft WindowsのWin32サブシステムとMSVCはPOSIX準拠ではなく、本書執筆時点では、歴史的経緯により、文字型はwchar_t、文字列型はstd::wstring、エンコードはUTF-16となっている。</p>
<h3 id="ファイルパスの操作">ファイルパスの操作</h3>
<p>クラスpathはファイルパス文字列の操作を提供している。std::stringとは違い、findやsubstrのような操作は提供していないが、ファイルパス文字列に特化した操作を提供している。</p>
<p>operator /, operator /=はセパレーターで区切ったファイルパス文字列の追加を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;/&quot;</span>) ;

    <span class="co">// &quot;/usr&quot;</span>
    p /= <span class="st">&quot;usr&quot;</span> ;
    <span class="co">// &quot;usr/local/include&quot;</span>
    p = p / <span class="st">&quot;local&quot;</span> / <span class="st">&quot;include&quot;</span> ;
}</code></pre></div>
<p>operator +=は単なる文字列の結合を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;/&quot;</span>) ;

    <span class="co">// &quot;/usr&quot;</span>
    p += <span class="st">&quot;usr&quot;</span> ;
    <span class="co">// &quot;/usrlocal&quot;</span>
    p += <span class="st">&quot;local&quot;</span> ;
    <span class="co">// &quot;/usrlocalinclude&quot;</span>
    p += <span class="st">&quot;include&quot;</span> ;
}</code></pre></div>
<p>operator /と違い、operator +は存在しない。</p>
<p>その他にも、pathは様々なファイルパス文字列に対する操作を提供している。以下はその一例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p( <span class="st">&quot;/home/cpp/src/main.cpp&quot;</span> ) ;

    <span class="co">// &quot;main.cpp&quot;</span>
    path filename = p.filename() ;
    <span class="co">// &quot;main&quot;</span>
    path stem = p.stem() ;
    <span class="co">// &quot;.cpp&quot;</span>
    path extension = p.extension() ;
    <span class="co">// &quot;/home/cpp/src/main.o&quot;</span>
    p.replace_extension(<span class="st">&quot;o&quot;</span>) ;
    <span class="co">// &quot;/home/cpp/src/&quot;</span>
    p.remove_filename() ;
}</code></pre></div>
<p>pathはファイルパス文字列に対してよく行う文字列処理を提供している。例えばファイル名だけ抜き出す処理、拡張子だけ抜き出す処理、拡張子を変える処理などだ。</p>
<h2 id="file_status">file_status</h2>
<p>クラスfile_statusはファイルのタイプとパーミッションを保持するクラスだ。</p>
<p>ファイルのタイプとパーミッションはファイルパス文字列を指定して取得する方法が別途あるが、その方法では毎回物理ファイルシステムへのアクセスが発生する。file_statusはファイルのタイプとパーミッション情報を保持するクラスとして、いわばキャッシュの役割を果たす。</p>
<p>file_statusは物理ファイルシステムへの変更のコミットはしない。</p>
<p>file_statusクラスはstatus(path)もしくはstatus(path, error_code)で取得できる。あるいは、directory_entryのメンバー関数status()から取得できる。</p>
<p>タイプというのは、ファイルが種類を表すenum型file_typeで、通常のファイルやディレクトリーやシンボリックリンクといったファイルの種類を表す。</p>
<p>パーミッションというのは、ファイルの権限を表すビットマスクのenum型permsで、ファイルの所有者とグループと他人に対す読み込み、書き込み、実行のそれぞれの権限を表している。この値はPOSIXの値を同じになっている。</p>
<p>ファイルのタイプとパーミッションを取得するメンバー関数は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> <span class="dt">file_type</span> {
<span class="kw">public</span> :
    <span class="dt">file_type</span> type() <span class="at">const</span> <span class="kw">noexcept</span>;
    perms permissions() <span class="at">const</span> <span class="kw">noexcept</span>;
} ;</code></pre></div>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="dt">int</span> regular_files = <span class="dv">0</span> ;
    <span class="dt">int</span> execs = <span class="dv">0</span> ;

    <span class="bu">std::</span>for_each( iter, end, [&amp;]( <span class="kw">auto</span> entry )
    {
        <span class="kw">auto</span> file_status = entry.status() ;
        <span class="co">// is_regular_file( file_status )でも可</span>
        <span class="cf">if</span> ( file_status.type() == <span class="dt">file_type</span>::regular )
            ++regular_files ;

        <span class="kw">constexpr</span> <span class="kw">auto</span> exec_bits = 
            perms::owner_exec | perms::group_exec | perms::others_exec ;

        <span class="kw">auto</span> permissions = file_status.permissions() ;
        <span class="cf">if</span> ( (  permissions != perms::unknown) &amp;&amp;
                (permissions &amp; exec_bits) != perms::none ) 
            ++execs ;
    } ) ;

    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;Current directory has &quot;</span>
        &lt;&lt; regular_files
        &lt;&lt; <span class="st">&quot; regular files.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
        &lt;&lt; execs
        &lt;&lt; <span class="st">&quot; files are executable.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
}</code></pre></div>
<p>このプログラムは、カレントディレクトリーにある通常のファイルの数と、実行可能なファイルの数を表示する。</p>
<p>ファイルパーミッションを表現するenum型permsは、パーミッションが不明な場合perms::unknownになる。この値は0xFFFFなのでビット演算をする場合には注意が必要だ。</p>
<p>それ以外のpermsの値はPOSIXに準拠しているが、permsはscoped enum型なので、明示的なキャストが必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="bu">std::</span>filesystem<span class="bu">::</span>perms a = <span class="bn">0755</span> ;

<span class="co">// OK</span>
<span class="bu">std::</span>filesystem<span class="bu">::</span>perms b = <span class="bu">std::</span>filesystem<span class="bu">::</span>perms(<span class="bn">0755</span>) ;</code></pre></div>
<p>ファイルのタイプとパーミッションを書き換えるメンバー関数は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> type(<span class="dt">file_type</span> ft) <span class="kw">noexcept</span>;
<span class="dt">void</span> permissions(perms prms) <span class="kw">noexcept</span>;</code></pre></div>
<p>ただし、file_statusというのは単なるキャッシュ用のクラスなので、file_statusのタイプとパーミッションを「書き換える」というのは、単にfile_statusのオブジェクトに保持されている値を書き換えるだけで、物理ファイルシステムに反映されるものではない。物理ファイルシステムを書き換えるには、フリー関数のpermissionsを使う。</p>
<h2 id="directory_entry">directory_entry</h2>
<p>クラスdirectory_entryはファイルパス文字列を保持し、ファイルパスの指し示すファイルの情報を取得できるクラスだ。</p>
<p>物理ファイルシステムからファイルの情報を毎回読むのは非効率的だ。directory_entryはいわばファイル情報のキャッシュとしての用途を持つ。</p>
<p>directory_entryは物理ファイルシステムから情報を読み込むだけで、変更のコミットはしない。</p>
<p>directory_entryの構築は、コンストラクターに引数としてpathを与える他、directory_iteratorとrecursive_directory_iteratorからも得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    path p(<span class="st">&quot;.&quot;</span>) ;

    <span class="co">// ファイルパス文字列から得る</span>
    directory_entry e1(p) ;

    <span class="co">// イテレーターから得る</span>
    directory_iterator i1(p) ;
    directory_entry e2 = *i1 ;

    recursive_directory_iterator i2(p) ;
    directory_entry e3 = *i2 ;
}</code></pre></div>
<p>directory_entryには様々なファイル情報を取得するメンバー関数があるが、これは同じ機能のものがフリー関数でも用意されている。directory_entryを使うと、ファイル情報をキャッシュできるため、同じファイルパスに対して、物理ファイルシステムの変更がないときに複数回のファイル情報取得を行うのが効率的になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    directory_entry entry(<span class="st">&quot;/home/cpp/foo&quot;</span>) ;

    <span class="co">// 存在確認</span>
    <span class="dt">bool</span> b = entry.exists() ;

    <span class="co">// &quot;/home/cpp/foo&quot;</span>
    path p = entry.path() ;
    file_status s = entry.status() ;

    <span class="co">// ファイルサイズを取得</span>
    <span class="bu">std::</span>uintmax_t size = entry.file_size() ;

    {
        <span class="bu">std::</span>ofstream foo( entry.path() ) ;
        foo &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
    }

    <span class="co">// 物理ファイルシステムから情報を更新</span>
    entry.refresh() ;
    <span class="co">// もう一度ファイルサイズを取得</span>
    size = entry.file_size() ;

    <span class="co">// 情報を取得するファイルパスを</span>
    <span class="co">// &quot;/home/cpp/bar&quot;</span>
    <span class="co">// に置き換えてrefresh()を呼び出す</span>
    entry.replace_filename(<span class="st">&quot;bar&quot;</span>) ;
}</code></pre></div>
<p>directory_entryはキャッシュ用のクラスで、自動的に物理ファイルシステムの変更に追随しないので、最新の情報を取得するには、明示的にメンバー関数refreshを呼び出す必要がある。</p>
<h2 id="directory_iterator">directory_iterator</h2>
<p>directory_iteratorは、あるディレクトリー下に存在するファイルパスをイテレーターの形式で列挙するためのクラスだ。</p>
<p>例えば、カレントディレクトリー下のファイルパスをすべて列挙するコードは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;
    directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;
    <span class="bu">std::</span>copy( iter, end,
        <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ) ;
}</code></pre></div>
<p>directory_iteratorはコンストラクターとしてpathを渡すと、そのディレクトリー下の最初のファイルに相当するdirectory_entryを返すイテレーターとなる。コンストラクターで指定されたディレクトリー下にファイルが存在しない場合、終端イテレーターになる。</p>
<p>directory_iteratorのデフォルトコンストラクターは終端イテレーターになる。終端イテレーターはデリファレンスできない。</p>
<p>directory_iterator::value_typeはdirectory_entryで、イテレーターのカテゴリーは入力イテレーターとなる。</p>
<p>directory_iteratorはカレントディレクトリー(.)と親ディレクトリー(..)は列挙しない。</p>
<p>directory_iteratorがディレクトリー下のファイルをどのような順番で列挙するかは未規定だ。</p>
<p>directory_iteratorによって返されるファイルパスは存在しない可能性があるので、ファイルが存在することを当てにしてはいけない。例えば、存在しないファイルへのシンボリックリンクかもしれない。</p>
<p>directory_iteratorのオブジェクトが作成されたあとに物理ファイルシステムになされた変更は、反映されるかどうか未規定である。</p>
<p>directory_iteratorのコンストラクターは列挙時の動作を指定できるdirectory_optionsを実引数に受け取ることができる。しかし、C++17の標準規格の範囲ではdirectory_iteratorの挙動を変更するdirectory_optionsは規定されていない。</p>
<h3 id="エラー処理-1">エラー処理</h3>
<p>directory_iteratorは構築時にエラーが発生することがある。このエラーを例外ではなくerror_codeで受け取りたい場合、コンストラクターの実引数でerror_codeへのリファレンスを渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="bu">std::</span>error_code err ;

    directory_iterator iter(<span class="st">&quot;this-directory-does-not-exist&quot;</span>, err) ;

    <span class="cf">if</span> ( err )
    {
        <span class="co">// エラー処理</span>
    }
}</code></pre></div>
<p>directory_iteratorはインクリメント時にエラーが発生することがある。このエラーを例外ではなくerror_codeで受け取りたい場合、メンバー関数incrementを呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ; 

    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="bu">std::</span>error_code err ;

    <span class="cf">for</span> ( ; iter != end &amp;&amp; !err ; iter.increment( err ) )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }

    <span class="cf">if</span> ( err )
    {
        <span class="co">// エラー処理</span>
    }
}</code></pre></div>
<h2 id="recursive_directory_iterator">recursive_directory_iterator</h2>
<p>recursive_directory_iteratorは指定されたディレクトリー下に存在するサブディレクトリーの下も含めて、すべてのファイルを列挙する。使い方はdirectory_iteratorとほぼ同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ; 
    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="bu">std::</span>copy(  iter, end,
                <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ) ;
}</code></pre></div>
<p>メンバー関数options, depth, recursion_pending, pop, disable_recursion_pendingをデリファレンスできないイテレーターに対して呼び出した際の挙動は未定義だ。</p>
<h3 id="オプション">オプション</h3>
<p>recursive_directory_iteratorはコンストラクターの実引数にdirectory_options型のscoped enum値を取ることによって、挙動を変更できる。directory_options型のenum値はビットマスクになっていて、以下の3つのビットマスク値が規定されている。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">デフォルト。ディレクトリーシンボリックリンクをスキップ。パーミッション違反はエラー</td>
</tr>
<tr class="even">
<td align="left">follow_directory_symlink</td>
<td align="left">ディレクトリーシンボリックリンクの中も列挙</td>
</tr>
<tr class="odd">
<td align="left">skip_permission_denied</td>
<td align="left">パーミッション違反のディレクトリーはスキップ</td>
</tr>
</tbody>
</table>
<p>このうち取りうる組み合わせは、none, follow_directory_symlink, skip_permission_denied, follow_directory_symlink | skip_permission_deniedの4種類になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ; 
    recursive_directory_iterator
        iter(<span class="st">&quot;/&quot;</span>, directory_options::skip_permission_denied), end ;

    <span class="bu">std::</span>copy(  iter, end,
                <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ) ;
}</code></pre></div>
<p>follow_directory_symlinkは、親ディレクトリーへのシンボリックリンクが存在する場合、イテレーターが終端イテレーターに到達しない可能性があるので注意すること。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="co">// 自分自身を含むディレクトリーに対するシンボリックリンク</span>
    create_symlink(<span class="st">&quot;.&quot;</span>, <span class="st">&quot;foo&quot;</span>) ;

    recursive_directory_iterator
        iter(<span class="st">&quot;.&quot;</span>, directory_options::follow_directory_symlink), end ;

    <span class="co">// エラー、もしくは終了しない</span>
    <span class="bu">std::</span>copy( iter, end, <span class="bu">std::</span>ostream_iterator&lt;path&gt;(<span class="bu">std::</span>cout) ) ;
}</code></pre></div>
<p>recursive_directory_iteratorの現在のdirectory_optionsを得るには、メンバー関数optionsを呼ぶ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    directory_options options() <span class="at">const</span> ;
} ;</code></pre></div>
<h3 id="depth-深さ取得">depth : 深さ取得</h3>
<p>recursive_directory_iteratorが現在列挙しているディレクトリーの深さを知るには、メンバー関数depthを呼ぶ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    <span class="dt">int</span> depth() <span class="at">const</span> ;
} ;</code></pre></div>
<p>最初のディレクトリーの深さは0で、次のサブディレクトリーの深さは1、それ以降のサブディレクトリーも同様に続く。</p>
<h3 id="pop-現在のディレクトリーの列挙中止">pop : 現在のディレクトリーの列挙中止</h3>
<p>メンバー関数popを呼ぶと、現在列挙中のディレクトリーの列挙を取りやめ、親ディレクトリーに戻る。現在のディレクトリーが初期ディレクトリーの場合、つまりdepth() == 0の場合は、終端イテレーターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    <span class="dt">void</span> pop();
    <span class="dt">void</span> pop(error_code&amp; ec);
} ;</code></pre></div>
<p>例えば、カレントディレクトリーが以下のようなディレクトリーツリーで、イテレーターが以下に書かれた順番でファイルを列挙する環境の場合、</p>
<pre><code>a
b
b/a
b/c
b/d
c
d</code></pre>
<p>以下のようなプログラムを実行すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem ;

    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="kw">auto</span> <span class="at">const</span> p = canonical(<span class="st">&quot;b/a&quot;</span>) ;

    <span class="cf">for</span> ( ; iter != end ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

        <span class="cf">if</span> ( canonical(iter-&gt;path()) == p )
            iter.pop() ;
    }
}</code></pre></div>
<p>標準出力が指すファイルとその順番は以下のようになる。</p>
<pre><code>a
b
b/a
c
d</code></pre>
<p>&quot;b/a&quot;に到達した時点でpop()が呼ばれるので、それ以上のディレクトリーb下の列挙が中止され、親ディレクトリーであるカレントディレクトリーに戻る。</p>
<h3 id="recursion_pending-現在のディレクトリーの再帰をスキップ">recursion_pending : 現在のディレクトリーの再帰をスキップ</h3>
<p>disable_recursion_pendingは現在のディレクトリーの下を再帰的に列挙することをスキップする機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> recursive_directory_iterator {
<span class="kw">public</span> :
    <span class="dt">bool</span> recursion_pending() <span class="at">const</span> ;
    <span class="dt">void</span> disable_recursion_pending() ;
} ;</code></pre></div>
<p>recursion_pending()は、直前のイテレーターのインクリメント操作の後にdisable_recursion_pending()が呼ばれていない場合、trueを返す。そうでない場合はfalseを返す。</p>
<p>言い換えれば、disable_recursion_pending()を呼んだ直後で、まだイテレーターのインクリメント操作をしていない場合、recursion_pneding()はfalseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;
    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = iter.recursion_pending() ;

    iter.disable_recursion_pending() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = iter.recursion_pending() ;

    ++iter ;
    <span class="co">//  true</span>
    <span class="dt">bool</span> b3 = iter.recursion_pending() ;


    iter.disable_recursion_pending() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b4 = iter.recursion_pending() ;
}</code></pre></div>
<p>現在recursive_directory_iteratorが指しているファイルパスがディレクトリーである場合、そのイテレーターをインクリメントすると、そのディレクトリー下を再帰的に列挙することになる。しかし、recursion_pending()がfalseを返す場合、ディレクトリーの最適的な列挙はスキップされる。インクリメント操作が行われた後はrecursion_pending()の結果はtrueに戻る。</p>
<p>つまり、disable_recursion_pendingは、現在指しているディレクトリー下を再帰的に列挙することをスキップする機能を提供する。</p>
<p>例えば、カレントディレクトリーが以下のようなディレクトリーツリーで、イテレーターが以下に書かれた順番でファイルを列挙する環境の場合、</p>
<pre><code>a
b
b/a
b/c
b/d
c
d</code></pre>
<p>以下のようなプログラムを実行すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem ;

    recursive_directory_iterator iter(<span class="st">&quot;.&quot;</span>), end ;

    <span class="kw">auto</span> <span class="at">const</span> p = canonical(<span class="st">&quot;b/a&quot;</span>) ;

    <span class="cf">for</span> ( ; iter != end ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

        <span class="cf">if</span> ( iter-&gt;is_directory() )
            iter.disable_recursion_pending() ;
    }
}</code></pre></div>
<p>標準出力が指すファイルとその順番は以下のようになる。</p>
<pre><code>a
b
c
d</code></pre>
<p>このプログラムはディレクトリーであれば必ずdisable_recursion_pending()が呼ばれるので、サブディレクトリーの再帰的な列挙は行われず、結果的に動作はdirectory_iteratorと同じになる。</p>
<p>disable_recursion_pendingを呼び出すことによって、選択的にディレクトリーの再帰的な列挙をスキップさせることができる。</p>
<h2 id="ファイルシステム操作関数">ファイルシステム操作関数</h2>
<h3 id="ファイルパス取得">ファイルパス取得</h3>
<h4 id="current_path">current_path</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path current_path();
path current_path(error_code&amp; ec);</code></pre></div>
<p>カレント・ワーキング・ディレクトリー(current working directory)への絶対パスを返す。</p>
<h4 id="temp_directory_path">temp_directory_path</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path temp_directory_path();
path temp_directory_path(error_code&amp; ec);</code></pre></div>
<p>一時ファイルを作成するのに最適な一時ディレクトリー(temporary directory)へのファイルパスを返す。</p>
<h3 id="ファイルパス操作">ファイルパス操作</h3>
<h4 id="absolute">absolute</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path absolute(<span class="at">const</span> path&amp; p);
path absolute(<span class="at">const</span> path&amp; p, error_code&amp; ec);</code></pre></div>
<p>pへの絶対パスを返す。pの指すファイルが存在しない場合の挙動は未規定。</p>
<h4 id="canonical">canonical</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path canonical(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base = current_path());
path canonical(<span class="at">const</span> path&amp; p, error_code&amp; ec);
path canonical(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base, error_code&amp; ec);</code></pre></div>
<p>存在するファイルへのファイルパスpへの、シンボリックリンク、カレントディレクトリー(.)、親ディレクトリー(..)の存在しない絶対パスを返す。</p>
<h4 id="wealky_canonical">wealky_canonical</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path weakly_canonical(<span class="at">const</span> path&amp; p);
path weakly_canonical(<span class="at">const</span> path&amp; p, error_code&amp; ec);</code></pre></div>
<p>ファイルパスpのシンボリックリンクが解決され、正規化されたパスを返す。ファイルパスの正規化についての定義は長くなるので省略。</p>
<h4 id="relative">relative</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path relative(<span class="at">const</span> path&amp; p, error_code&amp; ec);
path relative(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base = current_path());
path relative(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base, error_code&amp; ec);</code></pre></div>
<p>ファイルパスbaseからファイルパスpに対する相対パスを返す。</p>
<h4 id="proximate">proximate</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path proximate(<span class="at">const</span> path&amp; p, error_code&amp; ec);
path proximate(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base = current_path());
path proximate(<span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; base, error_code&amp; ec);</code></pre></div>
<p>ファイルパスbaseからのファイルパスpに対する相対パスが空パスでなければ相対パスを返す。相対パスが空パスならばpが返る。</p>
<h3 id="作成">作成</h3>
<h4 id="create_directory">create_directory</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> create_directory(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> create_directory(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>pの指すディレクトリーをひとつ作成する。新しいディレクトリーが作成できた場合はtrueを、作成できなかった場合はfalseを返す。pが既存のディレクトリーを指していて新しいディレクトリーが作成できなかった場合はエラーにはならない。単にfalseが返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> create_directory(
    <span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; existing_p);

<span class="dt">bool</span> create_directory(
    <span class="at">const</span> path&amp; p, <span class="at">const</span> path&amp; existing_p,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>新しく作成するディレクトリーpのアトリビュートを既存のディレクトリーexisting_pと同じものにする。</p>
<h4 id="create_directories">create_directories</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> create_directories(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> create_directories(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスpの中のディレクトリーで存在しないものをすべて作成する。</p>
<p>以下のプログラムは、カレントディレクトリーの下のディレクトリーaの下のディレクトリーbの下にディレクトリーcを作成する。もし、途中のディレクトリーであるa, bが存在しない場合、それも作成する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;
    create_directories(<span class="st">&quot;./a/b/c&quot;</span>) ;
}</code></pre></div>
<p>戻り値は、ディレクトリーを作成した場合true、そうでない場合false。</p>
<h4 id="create_directory_symlink">create_directory_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> create_directory_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink);
<span class="dt">void</span> create_directory_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ディレクトリーtoに解決されるシンボリックリンクnew_symlinkを作成する。</p>
<p>一部のOSでは、ディレクトリーへのシンボリックリンクとファイルへのシンボリックリンクを作成時に明示的に区別する必要がある。ポータブルなコードはディレクトリーへのシンボリックリンクを作成するときにはcreate_symlinkではなくcreate_directory_symlinkを使うべきである。</p>
<p>一部のOSはシンボリックリンクをサポートしていない。ポータブルなコードでは注意すべきである。</p>
<h4 id="create_symlink">create_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> create_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink);
<span class="dt">void</span> create_symlink(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_symlink,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスtoに解決されるシンボリックリンクnew_symlinkを作成する。</p>
<h4 id="create_hard_link">create_hard_link</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> create_hard_link(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_hard_link);
<span class="dt">void</span> create_hard_link(
    <span class="at">const</span> path&amp; to, <span class="at">const</span> path&amp; new_hard_link,
    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスtoに解決されるハードリンクnew_hard_linkを作成する。</p>
<h3 id="コピー">コピー</h3>
<h4 id="copy_file">copy_file</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to);
<span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
                error_code&amp; ec) <span class="kw">noexcept</span>;
<span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
                copy_options options);
<span class="dt">bool</span> copy_file( <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
                copy_options options,
                error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスfromのファイルをファイルパスtoにコピーする。</p>
<p>copy_optionsはコピーの挙動を変えるビットマスクのenum型で、以下のenum値がサポートされている。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">デフォルト、ファイルがすでに存在する場合はエラー</td>
</tr>
<tr class="even">
<td align="left">skip_existing</td>
<td align="left">既存のファイルを上書きしない。スキップはエラーとして報告しない</td>
</tr>
<tr class="odd">
<td align="left">overwrite_existing</td>
<td align="left">既存のファイルを上書きする</td>
</tr>
<tr class="even">
<td align="left">update_existing</td>
<td align="left">既存のファイルが上書きしようとするファイルより古ければ上書きする</td>
</tr>
</tbody>
</table>
<h4 id="copy">copy</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to);
<span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
            error_code&amp; ec) <span class="kw">noexcept</span>;
<span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
            copy_options options);
<span class="dt">void</span> copy(  <span class="at">const</span> path&amp; from, <span class="at">const</span> path&amp; to,
            copy_options options,
            error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスfromのファイルをファイルパスtoにコピーする。</p>
<p>copy_optionsはコピーの挙動を変えるビットマスク型のenum型で、以下のenum値がサポートされている。</p>
<ul>
<li>サブディレクトリーに関する指定</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">デフォルト、サブディレクトリーはコピーしない</td>
</tr>
<tr class="even">
<td align="left">recursive</td>
<td align="left">サブディレクトリーとその中身もコピーする</td>
</tr>
</tbody>
</table>
<ul>
<li>シンボリックリンクに関する指定</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">デフォルト、シンボリックリンクをフォローする</td>
</tr>
<tr class="even">
<td align="left">copy_symlinks</td>
<td align="left">シンボリックリンクをシンボリックリンクとしてコピーする。シンボリックリンクが指すファイルを直接コピーしない</td>
</tr>
<tr class="odd">
<td align="left">skip_symlinks</td>
<td align="left">シンボリックリンクを無視する</td>
</tr>
</tbody>
</table>
<ul>
<li>コピー方法に関する指定</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">デフォルト、ディレクトリー下の中身をコピーする</td>
</tr>
<tr class="even">
<td align="left">directories_only</td>
<td align="left">ディレクトリー構造のみをコピーする。非ディレクトリーファイルはコピーしない</td>
</tr>
<tr class="odd">
<td align="left">create_symlinks</td>
<td align="left">ファイルをコピーするのではなく、シンボリックリンクを作成する。コピー先がカレントディレクトリーではない場合、コピー元のファイルパスは絶対パスでなければならない</td>
</tr>
<tr class="even">
<td align="left">create_hard_links</td>
<td align="left">ファイルをコピーするのではなく、ハードリンクを作成する</td>
</tr>
</tbody>
</table>
<h4 id="copy_symlink">copy_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> copy_symlink(  <span class="at">const</span> path&amp; existing_symlink,
                    <span class="at">const</span> path&amp; new_symlink);
<span class="dt">void</span> copy_symlink(  <span class="at">const</span> path&amp; existing_symlink,
                    <span class="at">const</span> path&amp; new_symlink,
                    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>existing_symlinkをnew_symlinkにコピーする。</p>
<h3 id="削除">削除</h3>
<h4 id="remove">remove</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> remove(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> remove(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスpの指すファイルが存在するのであれば削除する。ファイルがシンボリックリンクの場合、シンボリックリンクファイルが削除される。フォロー先は削除されない。</p>
<p>戻り値として、ファイルが存在しない場合falseを返す。それ以外の場合trueを返す。error_codeでエラー通知を受け取る関数オーバーロードでは、エラーならばfalseが変える。</p>
<h4 id="remove_all">remove_all</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">uintmax_t</span> remove_all(<span class="at">const</span> path&amp; p);
<span class="dt">uintmax_t</span> remove_all(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスpの下の存在するファイルをすべて削除したあと、pの指すファイルも削除する。</p>
<p>つまり、pがディレクトリーファイルを指していて、そのディレクトリー下にサブディレクトリーやファイルが存在する場合、それらがすべて削除され、ディレクトリーpも削除される。</p>
<p>pがディレクトリーではないファイルを指す場合、pが削除される。</p>
<p>戻り値として、削除したファイルの個数が返る。error_codeでエラー通知を受け取る関数オーバーロードの場合、エラーならばstatic_cast&lt;uintmax_t&gt;(-1)が返る。</p>
<h3 id="変更">変更</h3>
<h4 id="permissions">permissions</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> permissions(   <span class="at">const</span> path&amp; p, perms prms,
                    perm_options opts=perm_options::replace);
<span class="dt">void</span> permissions(   <span class="at">const</span> path&amp; p, perms prms,
                    error_code&amp; ec) <span class="kw">noexcept</span>;
<span class="dt">void</span> permissions(   <span class="at">const</span> path&amp; p, perms prms,
                    perm_options opts,
                    error_code&amp; ec);</code></pre></div>
<p>ファイルパスpのパーミッションを変更する。</p>
<p>optsはperm_options型のenum値、replace, add, removeのうちいずれかひとつと、別途nofollowを指定することができる。省略した場合はreplaceになる。</p>
<p>カレントディレクトリーに存在するファイルfooを、すべてのユーザーに対して実行権限を付加するには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    permissions( <span class="st">&quot;./foo&quot;</span>, perms(<span class="bn">0111</span>), perm_options::add ) ;
}</code></pre></div>
<p>perm_optionsは以下のようなenum値を持つ。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">replace</td>
<td align="left">ファイルのパーミッションをprmsで置き換える</td>
</tr>
<tr class="even">
<td align="left">add</td>
<td align="left">ファイルのパーミッションにprmsで指定されたものを追加する</td>
</tr>
<tr class="odd">
<td align="left">remove</td>
<td align="left">ファイルのパーミッションからprmsで指定されたものを取り除く</td>
</tr>
<tr class="even">
<td align="left">nofollow</td>
<td align="left">ファイルがシンボリックリンクの場合、シンボリックリンクのフォロー先のファイルではなく、シンボリックリンクそのもののパーミッションを変更する</td>
</tr>
</tbody>
</table>
<p>例えば、パーミッションを置き換えつつ、シンボリックリンクそのもののパーミッションを書き換えたい場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">perm_options opts = perm_options::replace | perm_options::nofollow ;</code></pre></div>
<p>と書く。</p>
<h4 id="rename">rename</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rename(<span class="at">const</span> path&amp; old_p, <span class="at">const</span> path&amp; new_p);
<span class="dt">void</span> rename(<span class="at">const</span> path&amp; old_p, <span class="at">const</span> path&amp; new_p,
            error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルold_pをファイルnew_pにリネームする。</p>
<p>old_pとnew_pが同じ存在するファイルを指す場合、何もしない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std:filesystem ;

    <span class="co">// 何もしない</span>
    rename(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;foo&quot;</span>) ;
}</code></pre></div>
<p>それ以外の場合、リネームに伴って以下のような挙動も発生する。</p>
<p>もし、リネーム前にnew_pが既存のファイルを指していた場合、リネームに伴ってnew_pは削除される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;

    {
        <span class="bu">std::</span>ofstream old_p(<span class="st">&quot;old_p&quot;</span>), new_p(<span class="st">&quot;new_p&quot;</span>) ;

        old_p &lt;&lt; <span class="st">&quot;old_p&quot;</span> ;
        new_p &lt;&lt; <span class="st">&quot;new_p&quot;</span> ;
    }

    <span class="co">// ファイルold_pの内容は&quot;old_p&quot;</span>
    <span class="co">// ファイルnew_pの内容は&quot;new_p&quot;</span>

    <span class="co">// ファイルold_pをnew_pにリネーム</span>
    <span class="co">// もともとのnew_pは削除される</span>
    rename(<span class="st">&quot;old_p&quot;</span>, <span class="st">&quot;new_p&quot;</span>) ;

    <span class="bu">std::</span>ifstream new_p(<span class="st">&quot;new_p&quot;</span>) ;

    <span class="bu">std::</span>string text ;
    new_p &gt;&gt; text ;

    <span class="co">// &quot;old_p&quot;</span>
    <span class="bu">std::</span>cout &lt;&lt; text ;
}</code></pre></div>
<p>もし、new_pが既存の空ディレクトリーを指していた場合、POSIX準拠OSであれば、リネームに伴ってnew_pは削除される。他のOSではエラーになるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;

    create_directory(<span class="st">&quot;old_p&quot;</span>) ;
    create_directory(<span class="st">&quot;new_p&quot;</span>) ;

    <span class="co">// POSIX準拠環境であればエラーにならないことが保証される</span>
    rename(<span class="st">&quot;old_p&quot;</span>, <span class="st">&quot;new_p&quot;</span>) ;
}</code></pre></div>
<p>old_pがシンボリックリンクの場合、フォロー先ではなくシンボリックリンクファイルがリネームされる。</p>
<h4 id="resize_file">resize_file</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> resize_file(   <span class="at">const</span> path&amp; p, <span class="dt">uintmax_t</span> new_size);
<span class="dt">void</span> resize_file(   <span class="at">const</span> path&amp; p, <span class="dt">uintmax_t</span> new_size,
                    error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスpathの指すファイルのファイルサイズをnew_sizeにする。</p>
<p>リサイズはPOSIXのtruncate()で行われたかのように振る舞う。つまり、ファイルを小さくリサイズした場合、余計なデータは捨てられる。ファイルを大きくリサイズした場合、増えたデータはnullバイト(<code>\0</code>)でパディングされる。ファイルの最終アクセス日時も更新される。</p>
<h3 id="情報取得">情報取得</h3>
<h4 id="ファイルタイプの判定">ファイルタイプの判定</h4>
<p>ファイルタイプを表現するfile_type型のenumがあり、そのenum値は以下のようになっている。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">ファイルタイプが決定できないかエラー</td>
</tr>
<tr class="even">
<td align="left">not_found</td>
<td align="left">ファイルが発見できなかったことを示す疑似ファイルタイプ</td>
</tr>
<tr class="odd">
<td align="left">regular</td>
<td align="left">通常のファイル</td>
</tr>
<tr class="even">
<td align="left">directory</td>
<td align="left">ディレクトリーファイル</td>
</tr>
<tr class="odd">
<td align="left">symlink</td>
<td align="left">シンボリックリンクファイル</td>
</tr>
<tr class="even">
<td align="left">block</td>
<td align="left">ブロックスペシャルファイル</td>
</tr>
<tr class="odd">
<td align="left">fifo</td>
<td align="left">FIFOもしくはパイプファイル</td>
</tr>
<tr class="even">
<td align="left">socket</td>
<td align="left">ソケットファイル</td>
</tr>
<tr class="odd">
<td align="left">unknown</td>
<td align="left">ファイルは存在するがファイルタイプは決定できない</td>
</tr>
</tbody>
</table>
<p>この他に、実装依存のファイルタイプが追加されている可能性がある。</p>
<p>ファイルタイプを調べるには、file_statusのメンバー関数typeの戻り値を調べればよい。</p>
<p>以下のプログラムは、カレントディレクトリーに存在するファイルfooがディレクトリーかどうかを調べるコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="kw">auto</span> s = status(<span class="st">&quot;./foo&quot;</span>) ;
    <span class="dt">bool</span> b = s.type() == <span class="dt">file_type</span>::directory ;
}</code></pre></div>
<p>また、statusもしくはpathからファイルタイプがディレクトリーであるかどうかを判定できるis_directoryも用意されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>filesystem ;

    <span class="dt">bool</span> b1 = is_directory(<span class="st">&quot;./foo&quot;</span>) ;

    <span class="kw">auto</span> s = status(<span class="st">&quot;./foo&quot;</span>) ;
    <span class="dt">bool</span> b2 = is_directory(s) ;
}</code></pre></div>
<p>file_statusはファイル情報をキャッシュするので、物理ファイルシステムに変更を加えない状態で、同じファイルに対して何度もファイル情報を取得する場合は、file_statusを使ったほうがよい。</p>
<p>このようなis_xという形式のフリー関数は、いずれも以下の形式を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> is_x(file_status s) <span class="kw">noexcept</span>;
<span class="dt">bool</span> is_x(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> is_x(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>以下はフリー関数の名前と、どのファイルタイプであるかを判定する表だ。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">is_regular_file</td>
<td align="left">通常のファイル</td>
</tr>
<tr class="even">
<td align="left">is_directory</td>
<td align="left">ディレクトリーファイル</td>
</tr>
<tr class="odd">
<td align="left">is_symlink</td>
<td align="left">シンボリックリンクファイル</td>
</tr>
<tr class="even">
<td align="left">is_block</td>
<td align="left">ブロックスペシャルファイル</td>
</tr>
<tr class="odd">
<td align="left">is_fifo</td>
<td align="left">FIFOもしくはパイプファイル</td>
</tr>
<tr class="even">
<td align="left">is_socket</td>
<td align="left">ソケットファイル</td>
</tr>
</tbody>
</table>
<p>また、単一のファイルタイプを調べるのではない以下のような名前のフリー関数が存在する。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">is_other</td>
<td align="left">ファイルが存在し、通常のファイルでもディレクトリーでもシンボリックリンクでもないタイプ</td>
</tr>
<tr class="even">
<td align="left">is_empty</td>
<td align="left">ファイルがディレクトリーの場合、ディレクトリー下が空であればtrueを返す。<br>ファイルが非ディレクトリーの場合、ファイルサイズが0であればtrueを返す。</td>
</tr>
</tbody>
</table>
<h4 id="status">status</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">file_status status(<span class="at">const</span> path&amp; p);
file_status status(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスpのファイルの情報を格納するfile_statusを返す。</p>
<p>pがシンボリックリンクの場合、フォロー先のファイルのfile_statusを返す。</p>
<h4 id="status_known">status_known</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> status_known(file_status s) <span class="kw">noexcept</span>;</code></pre></div>
<p>s.type() != file_type::noneを返す。</p>
<h4 id="symlink_status">symlink_status</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">file_status symlink_status(<span class="at">const</span> path&amp; p);
file_status symlink_status(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>statusと同じだが、pがシンボリックリンクの場合、そのシンボリックリンクファイルのstatusを返す。</p>
<h4 id="equivalent">equivalent</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> equivalent(<span class="at">const</span> path&amp; p1, <span class="at">const</span> path&amp; p2);
<span class="dt">bool</span> equivalent(<span class="at">const</span> path&amp; p1, <span class="at">const</span> path&amp; p2,
                error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>p1とp2が物理ファイルシステム上、同一のファイルである場合、trueを返す。そうでない場合falseを返す。</p>
<h4 id="exists">exists</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> exists(file_status s) <span class="kw">noexcept</span>;
<span class="dt">bool</span> exists(<span class="at">const</span> path&amp; p);
<span class="dt">bool</span> exists(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>s, pが指すファイルが存在するのであればtrueを返す。そうでない場合falseを返す。</p>
<h4 id="file_size">file_size</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">uintmax_t</span> file_size(<span class="at">const</span> path&amp; p);
<span class="dt">uintmax_t</span> file_size(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>pの指すファイルのファイルサイズを返す。</p>
<p>ファイルが存在しない場合エラーとなる。ファイルが通常のファイルの場合、ファイルサイズを返す。それ以外の場合、挙動は実装依存となる。</p>
<p>エラー通知をerror_codeで受け取る関数オーバーロードでエラーの時、戻り値はstatic_cast&lt;uintmax_t&gt;(-1)となる。</p>
<h4 id="hard_link_count">hard_link_count</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">uintmax_t</span> hard_link_count(<span class="at">const</span> path&amp; p);
<span class="dt">uintmax_t</span> hard_link_count(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>pの指すファイルのハードリンク数を返す。</p>
<p>エラー通知をerror_codeで受け取る関数オーバーロードでエラーの時、戻り値はstatic_cast&lt;uintmax_t&gt;(-1)となる。</p>
<h4 id="last_write_time">last_write_time</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">file_time_type</span> last_write_time( <span class="at">const</span> path&amp; p);
<span class="dt">file_time_type</span> last_write_time( <span class="at">const</span> path&amp; p,
                                error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>pの指すファイルの最終更新日時を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> last_write_time(   <span class="at">const</span> path&amp; p, <span class="dt">file_time_type</span> new_time);
<span class="dt">void</span> last_write_time(   <span class="at">const</span> path&amp; p, <span class="dt">file_time_type</span> new_time,
                        error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>pの指すファイルの最終更新日時をnew_timeにする。</p>
<p>last_write_time(p, new_time)を呼び出した後に、last_write_time(p) == new_timeである保証はない。なぜならば、物理ファイルシステムの実装に起因する時刻の分解能や品質の問題があるからだ。</p>
<p>file_time_typeは、std::chrono_time_pointの特殊化で以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>filesystem {
    <span class="kw">using</span> file_time_time = <span class="bu">std::</span>chrono<span class="bu">::</span>time_point&lt; trivial-clock &gt; ;
}</code></pre></div>
<p>trivial-clockとは、クロック(より正確にはTrivialClock)の要件を満たすクロックで、ファイルシステムのタイムスタンプの値を正確に表現できるものとされている。クロックの具体的な型は実装依存なので、完全にポータブルなコードではファイルシステムで時間を扱うのは極めて困難になる。せいぜい現在時刻を設定するとか、差分の時間を設定するぐらいしかできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono ;
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// 最終更新日時を取得</span>
    <span class="kw">auto</span> timestamp = last_write_time( <span class="st">&quot;foo&quot;</span> ) ;

    <span class="co">// 時刻を1時間すすめる</span>
    timestamp += <span class="er">1h</span> ;
    <span class="co">// 更新</span>
    last_write_time( <span class="st">&quot;foo&quot;</span>, timestamp ) ;


    <span class="co">// 現在時刻を取得</span>
    <span class="kw">auto</span> now = <span class="dt">file_time_type</span>::clock::now() ;

    last_write_time( <span class="st">&quot;foo&quot;</span>, now ) ;
}</code></pre></div>
<p>ただし、多くの実装ではfile_time_typeとして、time_point&lt;std::chrono::system_clock&gt;が使われている。file_time_type::clockがsystem_clockであれば、system_clock::to_time_tとsystem_clock::from_time_tによってtime_t型との相互変換ができるために、幾分マシになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// file_time_type::clockがsystem_clockである場合</span>

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono ;

    <span class="co">// 最終更新日時を文字列で得る</span>
    <span class="kw">auto</span> time_point_value = last_write_time( <span class="st">&quot;foo&quot;</span> ) ;
    <span class="dt">time_t</span> time_t_value =
        system_clock::<span class="dt">to_time_t</span>( time_point_value ) ;
    <span class="bu">std::</span>cout &lt;&lt; ctime( &amp;time_t_value ) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

   
    <span class="co">// 最終更新日時を2017-10-12 19:02:58に設定</span>
    tm struct_tm{} ;
    struct_tm.tm_year = <span class="dv">2017</span> - <span class="dv">1900</span> ;
    struct_tm.tm_mon = <span class="dv">9</span> ;
    struct_tm.tm_mday = <span class="dv">12</span> ;
    struct_tm.tm_hour = <span class="dv">19</span> ;
    struct_tm.tm_min = <span class="dv">2</span> ;
    struct_tm.tm_sec = <span class="dv">58</span> ;

    <span class="dt">time_t</span> timestamp = <span class="bu">std::</span>mktime( &amp;struct_tm ) ;
    <span class="kw">auto</span> tp = system_clock::<span class="dt">from_time_t</span>( timestamp ) ;

    last_write_time( <span class="st">&quot;foo&quot;</span>, tp ) ;
}</code></pre></div>
<p>あまりマシになっていないように見えるのは、C++では現在&lt;chrono&gt;から利用できるC++風のモダンなカレンダーライブラリがないからだ。この問題は将来の規格改定で改善されるだろう。</p>
<h4 id="read_symlink">read_symlink</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">path read_symlink(<span class="at">const</span> path&amp; p);
path read_symlink(<span class="at">const</span> path&amp; p, error_code&amp; ec);</code></pre></div>
<p>シンボリックリンクpの解決される先のファイルパスを返す。</p>
<p>pがシンボリックリンクではない場合はエラーになる。</p>
<h4 id="space">space</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">space_info space(<span class="at">const</span> path&amp; p);
space_info space(<span class="at">const</span> path&amp; p, error_code&amp; ec) <span class="kw">noexcept</span>;</code></pre></div>
<p>ファイルパスpが指す先の容量を取得する。</p>
<p>クラスspace_infoは以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> space_info {
    <span class="dt">uintmax_t</span> capacity;
    <span class="dt">uintmax_t</span> free;
    <span class="dt">uintmax_t</span> available;
};</code></pre></div>
<p>この関数は、POSIXのstatvfs関数を呼び出した結果のstruct statvfsのf_blocks, f_bfree, f_bavailメンバーを、それぞれf_frsizeで乗じて、space_infoのメンバーcapacity, free, availableとして返す。値の決定できないメンバーにはstatic_cast&lt;uintmax_t&gt;(-1)が代入される。</p>
<p>エラー通知をerror_codeで返す関数オーバーロードがエラーの場合、space_infoのメンバーにはすべてstatic_cast&lt;uintmax_t&gt;(-1)が代入される。</p>
<p>space_infoのメンバーの意味をわかりやすく説明すると、以下の表のようになる。</p>
<table>
<thead>
<tr class="header">
<th align="left">名前</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">capacity</td>
<td align="left">総容量</td>
</tr>
<tr class="even">
<td align="left">free</td>
<td align="left">空き容量</td>
</tr>
<tr class="odd">
<td align="left">available</td>
<td align="left">権限のないユーザーが使える空き容量</td>
</tr>
</tbody>
</table>
</body>
</html>
